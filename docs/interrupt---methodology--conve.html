<!DOCTYPE html>
<html>
<head>
   <title>Introduction &gt; Appendix &gt; Alpha &gt; Interrupts / IPL and AST &gt; Interrupt - Methodology &amp; Convention</title>
   <meta name="viewport" content="width=device-width, initial-scale=1">
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />   
   <meta http-equiv="X-UA-Compatible" content="IE=edge" />
   <meta name="generator" content="Help &amp; Manual" />
   <meta name="keywords" content="" />
   <meta name="description" content="IPR-ORDER-OF-OPERATIONS.TXT &nbsp;(ASCII) &nbsp;## Goal &nbsp;Define a concrete, stepwise &quot;state transition script&quot; for an EV6 (21264) interrupt delivery and return path, expressed as *bitwi" />
   <link type="text/css" href="default.css" rel="stylesheet" />
   <link type="text/css" href="custom.css" rel="stylesheet" />

   <style TYPE="text/css" media="screen"> 
      html, body { margin:0; 
        padding:0; 
        background: #ffffff; 
      } 
      div#printheader { display: none; }
      #idheader { 
        width:100%; 
        height:auto; 
        padding: 0; 
        margin: 0;
        position: fixed;
        top: 0;
        z-index: 2;
      } 
      /* The "min-height" for "#idheader table" ensures that the (blue) header of the topic
         has at least the same height as the header of the navigation panel left of it */
      #idheader table { background: #2C5D88; min-height: 59px }             
      #idheader h1 { color: #FFF }     
      #idnav {
        text-align: right;
        width: 126px;
        vertical-align: middle;        
      } 
      #idnav a { text-decoration: none }
      #idnav span {
        display: inline-block;
        width: 24px;
        height: 24px;
        margin-left: 4px;
        background:url('hm_webhelp_buttons_grey.png') top left no-repeat;
      } 
      #idnav a span {
        background-image:url('hm_webhelp_buttons_white.png');
      } 
      #idnav a span:hover {
        background-image:url('hm_webhelp_buttons_orange.png');
      } 
      #idnav span.hmbtnprev { background-position: 0 -32px }
      #idnav span.hmbtnnext { background-position: -24px -32px }
      #idnav span.hmbtntop  { background-position: -48px -32px }
      #idnav span.hmbtntoggle  { width: 20px; background-position: -70px -32px }
      #idnav span.hmbtnprint  { background-position: -88px -32px }

      #callout-table, #overview-table {display:block; position:relative; top:0; left:0;}
      #callout-icon {display:block; position:absolute; top:-11px; left:-11px;}
      #callout-icon-flag {display:block; position:absolute; top:-11px; left:-8px;}
      #callout-table a {text-decoration: none; color: blue;}
      #callout-table a:visited {text-decoration: none; color: blue;}
      #overview-table a {text-decoration: none; color: black;}
      #overview-table a:visited {text-decoration: none; color: black;}
      #callout-table a:hover, #overview-table a:hover {text-decoration: underline;}       
      p.help-url { margin: 20px 0 5px 0; text-align: center; font-size: 80%; text-decoration: none }      
      #switchtoggles { text-align: right; padding: 0 2px 0 0; font-size: 90%; } 
      .sync-toc { color: #FFF; font-size: 8pt; font-weight: bold; display: none; }
      .sync-toc a { color: #FFF; text-decoration: none; font-weight: bold;}
      .sync-toc a:visited { color: #FFF; }
      .sync-toc a:hover { text-decoration: underline; }
      a.hmanchor { display: inline-block; margin-top: -4em; padding-top: 4em }	  
   </style>
   <style TYPE="text/css" media="print">
      div#idheader, img.dropdown-toggle-icon, p.help-url { display:none } 
   </style>
   <script type="text/javascript" src="jquery.js"></script>
   <script type="text/javascript" src="helpman_settings.js"></script>
   <script type="text/javascript" src="helpman_topicinit.js"></script>

   <script type="text/javascript">
     HMSyncTOC("index.html", "interrupt---methodology--conve.html");
   </script>
   <script type="text/javascript" src="highlight.js"></script>
   <script type="text/javascript">
     $(document).ready(function(){highlight();});
   </script>
</head>
<body>


<div id="printheader"><h1 class="p_Heading1" style="page-break-after: avoid;"><span class="f_Heading1">Interrupt - Methodology &amp; Convention</span></h1>
</div>
<div id="idheader">
<div id="idheaderbg">
<table style="width:100%;border:none;margin:0px;" cellspacing="0" cellpadding="0"> 
  <tr>
    <td class="topichead" style="text-align:left; vertical-align:bottom">
      <p class="sync-toc">&lt;&lt; <a rel="nofollow" href="index.html?interrupt---methodology--conve.html" target="_top">Click to Display Table of Contents</a> &gt;&gt;</p>
      <p class="crumbs"><b>Navigation:</b>&nbsp;
      
      <a href="introduction.html">Introduction</a> &gt; <a href="appendix---trait-examples.html">Appendix</a> &gt; <a href="alpha.html">Alpha</a> &gt; <a href="interrupts-_-ipl-and-ast.html">Interrupts / IPL and AST</a>&nbsp;&gt;</p>
   
      <h1 class="p_Heading1" style="page-break-after: avoid;"><span class="f_Heading1">Interrupt - Methodology &amp; Convention</span></h1>

    </td>
    <td class="topichead" id="idnav">
      
      <a href="ipi---inter-processor-interrup.html" title="Previous Topic"><span class="hmbtnprev"></span></a>
      <a href="interrupts-_-ipl-and-ast.html" title="Parent Chapter"><span class="hmbtntop"></span></a>
      <a href="box-architecture.html" title="Next Topic"><span class="hmbtnnext"></span></a>
      
    </td>
  </tr>  
</table>
</div>
</div>  

<div id="idcontent"><div id="innerdiv">
<!-- Ask Internet Explorer 6.users to update their obsolete and dangerous browser --> 
<!--[if lt IE 7]><div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;'><a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://storage.ie6countdown.com/assets/100/images/banners/warning_bar_0000_us.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today." /></a></div><![endif]-->

<!--ZOOMRESTART-->
<p class="p_Normal">IPR-ORDER-OF-OPERATIONS.TXT &nbsp;(ASCII)</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">## Goal</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Define a concrete, stepwise &quot;state transition script&quot; for an EV6 (21264) interrupt</p>
<p class="p_Normal">delivery and return path, expressed as *bitwise deltas* to architectural state.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">## Conventions used here</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">* &quot;PALmode&quot; is indicated by PC[0] (LSB). PC[0]=1 means PALmode active.</p>
<p class="p_Normal">* &quot;CM&quot; (Current Mode) is a field in the processor status state (PS). On EV6,</p>
<p class="p_Normal"> &nbsp;PS contains the architectural mode state (K/E/S/U). PAL execution is effectively</p>
<p class="p_Normal"> &nbsp;at Kernel privilege.</p>
<p class="p_Normal">* ICCSR is the Interrupt Control and CPU Status Register (EV6 IPR) that gates</p>
<p class="p_Normal"> &nbsp;delivery (interrupt enable, IPL, pending summary, etc.). Exact bit names vary</p>
<p class="p_Normal"> &nbsp;by implementation, but the ordering requirements are stable.</p>
<p class="p_Normal">* EXC_ADDR is the Exception Address IPR: restart/continuation PC for the event.</p>
<p class="p_Normal">* EXC_SUM is the Exception Summary IPR: reason classification (interrupt vs fault,</p>
<p class="p_Normal"> &nbsp;and which class), plus sticky indicators.</p>
<p class="p_Normal">* HWPCB points to the per-CPU Hardware PCB save area used by PAL entry/exit.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Important: the EV6 reference manual distinguishes &quot;what the hardware must do</p>
<p class="p_Normal">architecturally&quot; from &quot;what PALcode does as policy&quot;. Below is the architectural</p>
<p class="p_Normal">minimum plus the typical EV6 PAL policy actions, clearly separated.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">---</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">## A. INTERRUPT REQUEST ARRIVES (NO PALMODE)</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">A0. External condition asserts an interrupt request</p>
<p class="p_Normal">- Source can be I/O interrupt controller, timer, IPI, corrected MCHK, etc.</p>
<p class="p_Normal">- Bitwise effect:</p>
<p class="p_Normal">* Some per-CPU pending latch is set. Architecturally visible as a pending</p>
<p class="p_Normal">condition via ICCSR (pending summary / request bits) and/or via a</p>
<p class="p_Normal">platform-specific interrupt controller CSR. The CPU does not vector yet.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">A1. Eligibility check point (performed at defined points in the pipeline)</p>
<p class="p_Normal">Hardware evaluates:</p>
<p class="p_Normal">- PC[0] == 0 &nbsp;(not in PALmode)</p>
<p class="p_Normal">- Interrupts enabled (ICCSR.IE == 1, and/or PS.IE == 1 depending on EV6</p>
<p class="p_Normal">implementation; EV6 uses ICCSR as the primary gate)</p>
<p class="p_Normal">- IPL allows delivery (ICCSR.IPL &lt; request_level) or equivalent.</p>
<p class="p_Normal">- No higher-priority synchronous exception is taking precedence.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">```</p>
<p class="p_Normal">This is a &quot;check step&quot; in your sequence model. No state changes yet.</p>
<p class="p_Normal">```</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">A2. Commit-to-deliver (the moment the CPU decides &quot;this interrupt will be taken&quot;)</p>
<p class="p_Normal">Ordering requirements you listed begin here.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">```</p>
<p class="p_Normal">A2.1 Pipeline drain / precise state point</p>
<p class="p_Normal"> &nbsp; &nbsp; - Required architectural property:</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; * All older instructions are completed (retired) with their architected</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; effects, or an older exception wins and this interrupt is deferred.</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; * For interrupts, EV6 requires a precise point: the continuation PC</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; corresponds to the next instruction that would have executed.</p>
<p class="p_Normal"> &nbsp; &nbsp; - Typical EV6 requirement also includes completion of outstanding</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; D-cache fills prior to vectoring (as you stated).</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">A2.2 Latch the continuation PC into EXC_ADDR</p>
<p class="p_Normal"> &nbsp; &nbsp; - Bitwise effect:</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; * EXC_ADDR := continuation_pc</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; (continuation_pc is the address of the next instruction to execute</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if the interrupt had not occurred; i.e., restart point.)</p>
<p class="p_Normal"> &nbsp; &nbsp; - NOTE:</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; * EXC_ADDR itself does not &quot;cause PALmode&quot;; it is just storage.</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; * The LSB convention is about the PC that becomes active; EXC_ADDR</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; typically holds a non-PAL address (PC[0]=0) for normal return.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">A2.3 Record reason/classification into EXC_SUM</p>
<p class="p_Normal"> &nbsp; &nbsp; - Bitwise effect:</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; * EXC_SUM.INTERRUPT_CLASS (or equivalent summary bits) set.</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; * EXC_SUM may also capture &quot;which vector family&quot; (INTERRUPT vs MCHK</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; vs ARITH vs ITB/DTB vs CALL_PAL). Exact encoding is EV6-specific,</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; but the key point is: EXC_SUM is written BEFORE PAL dispatch so PAL</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; can interrogate it.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">A2.4 Enter PALmode (hardware state transition)</p>
<p class="p_Normal"> &nbsp; &nbsp; - Bitwise effect (architectural):</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; * PC[0] becomes 1 for the active fetch PC (PAL dispatch address).</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; (Implementation may set an internal PAL flag derived from PC[0].)</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; * Current privilege becomes Kernel for PAL execution:</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PS.CM := KERNEL</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; (If your model has an explicit IER_CM or PS&lt;CM&gt;, treat this as the</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;single authoritative update point.)</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; * Interrupt delivery is disabled while in PAL:</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ICCSR.IE := 0 &nbsp; (and/or PS.IE := 0 if modeled separately)</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; This is the &quot;Disable Interrupts when entering PALmode&quot; step.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">A2.5 Disable or bypass I-stream VA translation for PAL fetch</p>
<p class="p_Normal"> &nbsp; &nbsp; - Bitwise effect:</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; * &quot;I-stream mapping enable&quot; is forced off for PAL fetch</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; (often modeled as ITB enable gating).</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; * In an emulator: treat this as &quot;PAL fetch uses physical addressing&quot;</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; unless your model already implements the EV6 PAL I-stream rules.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">A2.6 Load PAL vector PC (dispatch)</p>
<p class="p_Normal"> &nbsp; &nbsp; - Bitwise effect:</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; * New PC := PAL_BASE + vector_offset_for_interrupt</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; * Force PC[0] := 1 (PALmode indicator)</p>
<p class="p_Normal"> &nbsp; &nbsp; - Vector offset depends on event class; &quot;interrupt&quot; vectors are distinct</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; from faults (DTB miss, etc.).</p>
<p class="p_Normal">```</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">At this point, PALcode begins executing.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">---</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">## B. PAL INTERRUPT HANDLING (POLICY, STILL IPR-CENTRIC)</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">B0. PAL begins with interrupts effectively disabled</p>
<p class="p_Normal">- Already achieved by A2.4.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">B1. PAL determines the specific interrupt source</p>
<p class="p_Normal">- Reads:</p>
<p class="p_Normal">* ICCSR (pending summary/level)</p>
<p class="p_Normal">* Platform interrupt controller registers (not IPR, but often memory-mapped)</p>
<p class="p_Normal">* IPIR state if it is an IPI</p>
<p class="p_Normal">- Bitwise effect:</p>
<p class="p_Normal">* None yet (reads only).</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">B2. PAL performs acknowledgment/clear at the appropriate layer</p>
<p class="p_Normal">- IMPORTANT separation:</p>
<p class="p_Normal">* CPU-level &quot;pending&quot; summary may clear by:</p>
<p class="p_Normal">- writing ICCSR (if the architecture provides W1C semantics), and/or</p>
<p class="p_Normal">- reading a platform &quot;ack&quot; register, and/or</p>
<p class="p_Normal">- servicing the interrupt controller so it deasserts the level.</p>
<p class="p_Normal">* Many EV6 systems are level-triggered; the CPU pending will reassert if</p>
<p class="p_Normal">the platform source is not cleared.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">```</p>
<p class="p_Normal">In your sequence model, make this explicit as:</p>
<p class="p_Normal"> &nbsp;- &quot;Clear platform source&quot; step (non-IPR)</p>
<p class="p_Normal"> &nbsp;- &quot;Clear CPU summary latch&quot; step (IPR, if applicable)</p>
<p class="p_Normal">```</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">B3. PAL decides whether and when to re-enable interrupts inside PAL</p>
<p class="p_Normal">- Often: PAL keeps interrupts disabled except in carefully controlled windows.</p>
<p class="p_Normal">- If re-enabled:</p>
<p class="p_Normal">ICCSR.IE := 1</p>
<p class="p_Normal">but PALmode remains active (PC[0]=1), so delivery may still be constrained</p>
<p class="p_Normal">by EV6 rules (implementation policy).</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">---</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">## C. RETURN FROM PAL (HW_REI PATH)</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">C0. PAL prepares return state (if needed)</p>
<p class="p_Normal">- PAL may update:</p>
<p class="p_Normal">* EXC_ADDR (rare, but possible if it wants to redirect return)</p>
<p class="p_Normal">* HWPCB save slots</p>
<p class="p_Normal">* PS fields (if PAL is responsible for restoring a prior mode snapshot)</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">```</p>
<p class="p_Normal">In a minimal interrupt handler, EXC_ADDR already contains the correct return PC.</p>
<p class="p_Normal">```</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">C1. Execute HW_REI (hardware return from exception/interrupt)</p>
<p class="p_Normal">This is the &quot;point of no ambiguity&quot; where the hardware consumes IPR state.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">```</p>
<p class="p_Normal">C1.1 Load return PC from EXC_ADDR</p>
<p class="p_Normal"> &nbsp; &nbsp; - Bitwise effect:</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; * New PC := EXC_ADDR</p>
<p class="p_Normal"> &nbsp; &nbsp; - PALmode determination:</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; * If New PC[0] == 0, hardware exits PALmode.</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; * If New PC[0] == 1, hardware remains in PALmode (used for chaining</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; or returning into PAL).</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">C1.2 Exit PALmode (typical interrupt return case)</p>
<p class="p_Normal"> &nbsp; &nbsp; If New PC[0] == 0:</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; - Bitwise effects:</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; * PALmode flag cleared (derived from PC[0]=0).</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; * Re-enable I-stream VA translation (restore ITB enable gating).</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; * Restore interrupt enable state:</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ICCSR.IE := 1 &nbsp;(or restored from a saved PS/IE snapshot)</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; * Restore current mode:</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PS.CM := prior_mode</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (On a pure interrupt return to kernel, prior_mode is often kernel;</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;on user return, prior_mode is user.)</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp; NOTE ON &quot;which register owns Kernel Mode&quot;:</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; - Treat PS.CM (processor status current mode) as the single owner.</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; ICCSR does NOT own the current privilege mode; it owns interrupt</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; gating and priority (IPL) policy. If you have an IER_CM field in</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; your codebase, it should either be an alias to PS.CM or eliminated</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; to avoid dual sources of truth.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">C1.3 Exception summary cleanup (optional but typical)</p>
<p class="p_Normal"> &nbsp; &nbsp; - Some EXC_SUM bits are sticky until explicitly cleared by PAL.</p>
<p class="p_Normal"> &nbsp; &nbsp; - Model explicitly:</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; EXC_SUM.interrupt_taken := 0 &nbsp; (if defined as a latch)</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; or:</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; EXC_SUM := (EXC_SUM &amp; ~INT_BITS)</p>
<p class="p_Normal"> &nbsp; &nbsp; depending on your EV6 definition.</p>
<p class="p_Normal">```</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">---</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">## D. YOUR &quot;TRIVIAL SEQUENCE&quot; REWRITTEN AS A STRICT STEP TABLE</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Below is your list normalized and de-duplicated, with explicit deltas:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">1. Interrupt pending asserted</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"> &nbsp; * ICCSR.PENDING := 1 (or equivalent summary becomes 1)</p>
<p class="p_Normal"> &nbsp; * No vector yet.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">2. Eligibility check</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"> &nbsp; * Require PC[0]==0, ICCSR.IE==1, IPL allows.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">3. Drain to precise point</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"> &nbsp; * Pipeline drained; outstanding D-cache fills completed (EV6 rule you cited).</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">4. Save continuation PC</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"> &nbsp; * EXC_ADDR := continuation_pc &nbsp;(typically PC[0]=0)</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">5. Record event class</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"> &nbsp; * EXC_SUM := EXC_SUM OR INT_CLASS_BITS</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">6. Enter PALmode and disable interrupts</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"> &nbsp; * Active fetch PC will be PAL vector PC with PC[0]=1</p>
<p class="p_Normal"> &nbsp; * PS.CM := KERNEL</p>
<p class="p_Normal"> &nbsp; * ICCSR.IE := 0</p>
<p class="p_Normal"> &nbsp; * I-stream mapping forced off for PAL fetch</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">7. Dispatch PAL vector</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"> &nbsp; * PC := PAL_BASE + INTERRUPT_VECTOR_OFFSET</p>
<p class="p_Normal"> &nbsp; * PC[0] := 1</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">8. PAL services interrupt source (policy)</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"> &nbsp; * Read ICCSR/platform regs</p>
<p class="p_Normal"> &nbsp; * Clear platform source</p>
<p class="p_Normal"> &nbsp; * Optionally clear ICCSR pending latch if writable-clearing exists</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">9. HW_REI executed</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"> &nbsp; * PC := EXC_ADDR</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">10. Exit PALmode if PC[0]==0</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;* PALmode cleared</p>
<p class="p_Normal"> &nbsp; &nbsp;* I-stream mapping restored</p>
<p class="p_Normal"> &nbsp; &nbsp;* ICCSR.IE restored to 1 (or restored snapshot)</p>
<p class="p_Normal"> &nbsp; &nbsp;* PS.CM restored to prior mode (Kernel or User)</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">11. Resume fetch at PC with normal interrupt gating</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">---</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">## E. WHAT I NEED FROM YOUR HEADERS (NO QUESTIONS, JUST A CHECKLIST)</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">When you upload your interrupt headers, I will map them to this sequence and</p>
<p class="p_Normal">produce a &quot;bit-delta audit&quot; that answers, for each step:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">* Which write occurs (ICCSR, EXC_ADDR, EXC_SUM, PS, HWPCB)</p>
<p class="p_Normal">* Exactly which bits are set/cleared (W1C/W1S semantics if used)</p>
<p class="p_Normal">* Where PALmode is derived (PC[0] only, or duplicated flags)</p>
<p class="p_Normal">* Where &quot;disable interrupts&quot; is implemented (ICCSR.IE vs PS.IE duplication)</p>
<p class="p_Normal">* Where &quot;current mode&quot; is implemented (PS.CM only, not ICCSR)</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">If your current code stores &quot;PALmode&quot; and &quot;CM&quot; in multiple places, I will</p>
<p class="p_Normal">recommend a single-source-of-truth rule and show the exact reorder-safe update</p>
<p class="p_Normal">points to avoid OoO artifacts in the emulator.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Upload the headers when ready.</p>
<p class="p_Normal">&nbsp;</p>

<!--ZOOMSTOP-->
</div></div>
<script type="text/javascript">

  

  $(document).ready(function(){
    $(window).bind('resize', function() {
      var y = $('#idheader').height(); 
      $('#idcontent').css('margin-top', y);
      var par = window.parent;
      if ($( par ).width() <= $( window ).width()+20) {
        $('#idheader').css('position', 'relative');
        $('#idcontent').css('margin-top', 0);
        $('#idbacktotop').css('display', 'block');
        $('.hmanchor').css('margin-top', -20);
	$('.hmanchor').css('padding-top', 20);
      }
      else {
        $('#idheader').css('position', 'fixed');
        $('#idcontent').css('margin-top', $('#idheader').height());
        $('#idbacktotop').css('display', 'none');
        $('.hmanchor').css('margin-top', -y-20);
	$('.hmanchor').css('padding-top', y+20);
      }
    });
    
    $(window).resize(); //trigger event for initially small displays
  });

if ((!parent.hmNavigationFrame) && (parent.location) && (parent.location.href)) { $('.sync-toc').show();$('p.crumbs').hide();}

</script>
</body>
</html>
