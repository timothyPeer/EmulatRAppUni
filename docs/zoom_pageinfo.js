pageinfo = [[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null],
	[0,0,0,0,null]];
pagedata = [ ["./10_1-purpose-of-this-chapter.html","Introduction &#62; Architecture Overview &#62; Chapter 10 – Devices and Memory-Mapped I/O (MMIO) &#62; 10.1 Purpose of This Chapter","This chapter defines how EMulatR models devices and memory-mapped I/O (MMIO), and how device interactions integrate with the AlphaCPU pipeline, th...",""],
["./10_10-mmio-and-serialization.html","Introduction &#62; Architecture Overview &#62; Chapter 10 – Devices and Memory-Mapped I/O (MMIO) &#62; 10.10 MMIO and Serialization","10.10.1 Implicit Ordering  MMIO accesses are implicitly serialized relative to each other. No explicit barrier is required to ensure ordering...",""],
["./10_11-pal-and-device-control.html","Introduction &#62; Architecture Overview &#62; Chapter 10 – Devices and Memory-Mapped I/O (MMIO) &#62; 10.11 PAL and Device Control","Some device operations require PAL mode: device initialization, interrupt routing configuration, DMA enablement, and system-wide device control. A...",""],
["./10_12-smp-and-error-handling.html","Introduction &#62; Architecture Overview &#62; Chapter 10 – Devices and Memory-Mapped I/O (MMIO) &#62; 10.12 SMP and Error Handling","10.12.1 SMP Considerations  In SMP systems: devices are globally visible (all CPUs can access any MMIO region), MMIO ordering is global (stro...",""],
["./10_13-summary.html","Introduction &#62; Architecture Overview &#62; Chapter 10 – Devices and Memory-Mapped I/O (MMIO) &#62; 10.13 Summary","The EMulatR device and MMIO subsystem provides a strongly ordered, interrupt-driven device model that matches Alpha AXP hardware behavior.",""],
["./10_2-design-philosophy.html","Introduction &#62; Architecture Overview &#62; Chapter 10 – Devices and Memory-Mapped I/O (MMIO) &#62; 10.2 Design Philosophy","EMulatR follows real Alpha hardware principles for device modeling:",""],
["./10_3-device-model-overview.html","Introduction &#62; Architecture Overview &#62; Chapter 10 – Devices and Memory-Mapped I/O (MMIO) &#62; 10.3 Device Model Overview","10.3.1 What a Device Is  In EMulatR, a device is an object that owns one or more MMIO address ranges, exposes registers via MMIO, executes op...",""],
["./10_3_2-device-attachment.html","Introduction &#62; Architecture Overview &#62; Chapter 10 – Devices and Memory-Mapped I/O (MMIO) &#62; 10.4 Device Registration and Catalog","10.4.1 DeviceCatalog  DeviceCatalog (mmio_DeviceCatalog.h, 130 lines) is the template database for all device types. It stores DeviceTemplate...",""],
["./10_4-mmio-address-space.html","Introduction &#62; Architecture Overview &#62; Chapter 10 – Devices and Memory-Mapped I/O (MMIO) &#62; 10.5 MMIOManager - MMIO Address Space","10.5.1 MMIO vs RAM Routing  MMIO regions are distinguished from RAM by address range, not instruction type. When GuestMemory::findRoute(pa) r...",""],
["./10_5-mmio-access-semantics.html","Introduction &#62; Architecture Overview &#62; Chapter 10 – Devices and Memory-Mapped I/O (MMIO) &#62; 10.6 MMIO Access Semantics","10.6.1 Strong Ordering Rules  MMIO accesses are strongly ordered: no reordering, no buffering, no speculation, no combining, no deferral. Eve...",""],
["./10_6-device-registers.html","Introduction &#62; Architecture Overview &#62; Chapter 10 – Devices and Memory-Mapped I/O (MMIO) &#62; 10.7 Device Registers and Side Effects","Devices expose control and status registers via MMIO. Typical register types include command registers, status registers, data registers, interrup...",""],
["./10_7-asynchronous-device-opera.html","Introduction &#62; Architecture Overview &#62; Chapter 10 – Devices and Memory-Mapped I/O (MMIO) &#62; 10.8 Asynchronous Operations and DMA","10.8.1 Device Execution Model  After receiving a command via MMIO write, the device begins work asynchronously. CPU execution continues immed...",""],
["./10_9-interrupt-signaling.html","Introduction &#62; Architecture Overview &#62; Chapter 10 – Devices and Memory-Mapped I/O (MMIO) &#62; 10.9 Interrupt Signaling","10.9.1 Device Interrupts  Devices signal completion via interrupts. The process: device completes work, device asserts interrupt line (via IR...",""],
["./11_1-purpose-of-this-chapter.html","Introduction &#62; Architecture Overview &#62; Chapter 11 - Architectural Invariants &#62; 11.1 Purpose of This Chapter","This chapter defines the architectural invariants of EMulatR.",""],
["./11_10-invariant-violations.html","Introduction &#62; Architecture Overview &#62; Chapter 11 - Architectural Invariants &#62; 11.10 Invariant Violations","Any violation of an architectural invariant indicates a design bug or an implementation defect. Performance, convenience, or simplicity never just...",""],
["./11_11-summary.html","Introduction &#62; Architecture Overview &#62; Chapter 11 - Architectural Invariants &#62; 11.11 Summary","Architectural invariants define what EMulatR is. They are the foundation on which all future features must stand.",""],
["./11_2-execution-and-pipeline-in.html","Introduction &#62; Architecture Overview &#62; Chapter 11 - Architectural Invariants &#62; 11.2 Execution and Pipeline Invariants","11.2.1 Precise Execution  All exceptions are precise. When an exception is delivered: all prior instructions have completed, no later instruc...",""],
["./11_3-memory-model-invariants.html","Introduction &#62; Architecture Overview &#62; Chapter 11 - Architectural Invariants &#62; 11.3 Memory Model Invariants","11.3.1 Weak Ordering by Default  Memory is weakly ordered. Loads and stores may reorder. Stores may be deferred (via per-CPU write buffers). ...",""],
["./11_4-load-locked-_-store-condi.html","Introduction &#62; Architecture Overview &#62; Chapter 11 - Architectural Invariants &#62; 11.4 Load-Locked / Store-Conditional Invariants","11.4.1 Reservation Model  LL/SC uses reservations, not locks. Reservations are per-CPU, cache-line granular (64 bytes), optimistic, and non-b...",""],
["./11_5-privilege-and-pal-invaria.html","Introduction &#62; Architecture Overview &#62; Chapter 11 - Architectural Invariants &#62; 11.5 Privilege and PAL Invariants","11.5.1 Absolute Privileged Boundary  Execution is either PAL or non-PAL. There is no intermediate privilege state. Privilege cannot be escala...",""],
["./11_6-exception-and-interrupt-i.html","Introduction &#62; Architecture Overview &#62; Chapter 11 - Architectural Invariants &#62; 11.6 Exception and Interrupt Invariants","11.6.1 Classification  Faults are synchronous (detected in EX, associated with a specific instruction). Traps are synchronous but post-commit...",""],
["./11_7-smp-invariants.html","Introduction &#62; Architecture Overview &#62; Chapter 11 - Architectural Invariants &#62; 11.7 SMP Invariants","11.7.1 True Symmetry  All CPUs are peers. No CPU has implicit authority. No global CPU lock exists.  Enforced by: ExecutionCoordinator c...",""],
["./11_8-device-and-mmio-invariant.html","Introduction &#62; Architecture Overview &#62; Chapter 11 - Architectural Invariants &#62; 11.8 Device and MMIO Invariants","11.8.1 Asynchronous Devices  Devices operate asynchronously. CPU never blocks on device execution. Completion is interrupt-driven or polled. ...",""],
["./11_9-debugging-and-observabili.html","Introduction &#62; Architecture Overview &#62; Chapter 11 - Architectural Invariants &#62; 11.9 Debugging and Observability Invariants","11.9.1 Determinism  Given the same inputs, execution is deterministic. SMP ordering differences are intentional and observable. No hidden tim...",""],
["./12_1-purpose-of-this-chapter.html","Introduction &#62; Architecture Overview &#62; Chapter 12 – AlphaCPU Core &#62; 12.1 Purpose of This Chapter","This chapter defines the AlphaCPU core object and its responsibilities within EMulatR. This is the first chapter of Group 2 (Core Processor Implem...",""],
["./12_10-cpu-local-events.html","Introduction &#62; Architecture Overview &#62; Chapter 12 – AlphaCPU Core &#62; 12.10 CPU-Local Events","AlphaCPU manages CPU-local pending events via PendingEvent_cpuLocal — a lightweight structure separate from FaultDispatcher&#39;s architectural events...",""],
["./12_11-error-handling.html","Introduction &#62; Architecture Overview &#62; Chapter 12 – AlphaCPU Core &#62; 12.11 Error Handling","AlphaCPU defines four error severity levels:  enum class ErrorSeverity {  WARNING, // Log only  RECOVERABLE, // Queue fault, contin...",""],
["./12_12-performance-and-instrume.html","Introduction &#62; Architecture Overview &#62; Chapter 12 – AlphaCPU Core &#62; 12.12 Performance and Instrumentation","AlphaCPU tracks performance counters: m_localInstrCount (instructions retired) and m_localCycleCount (cycles elapsed). The architectural cycle cou...",""],
["./12_13-summary.html","Introduction &#62; Architecture Overview &#62; Chapter 12 – AlphaCPU Core &#62; 12.13 Summary","AlphaCPU is the sole execution authority in EMulatR. Nothing executes unless AlphaCPU allows it.",""],
["./12_2-alphacpu-as-the-unit-of-e.html","Introduction &#62; Architecture Overview &#62; Chapter 12 – AlphaCPU Core &#62; 12.2 AlphaCPU as the Unit of Execution","Each AlphaCPU instance represents one physical Alpha processor. One AlphaCPU = one hardware CPU. Each AlphaCPU runs independently in its own QThre...",""],
["./12_3-ownership-model.html","Introduction &#62; Architecture Overview &#62; Chapter 12 – AlphaCPU Core &#62; 12.3 Ownership Model","12.3.1 AlphaCPU Owns  AlphaCPU directly owns or controls the following per-CPU subsystems (created in the constructor):  // Box Ownershi...",""],
["./12_4-cpu-lifecycle.html","Introduction &#62; Architecture Overview &#62; Chapter 12 – AlphaCPU Core &#62; 12.4 CPU Lifecycle","12.4.1 Creation  AlphaCPUs are created by the ExecutionCoordinator (as CPUWorker instances). The constructor AlphaCPU(cpuId, cBox, parent) pe...",""],
["./12_5-the-alphacpu-run-loop.html","Introduction &#62; Architecture Overview &#62; Chapter 12 – AlphaCPU Core &#62; 12.5 The AlphaCPU Run Loop","12.5.1 executeLoop()  The run loop (executeLoop() in AlphaCPU.cpp) is the clocked execution engine. Each iteration represents one hardware cy...",""],
["./12_6-pipeline-integration.html","Introduction &#62; Architecture Overview &#62; Chapter 12 – AlphaCPU Core &#62; 12.6 Pipeline Integration","AlphaCPU owns the AlphaPipeline and drives it explicitly. The pipeline is initialized when executeLoop() calls injectOtherBoxes() to connect all e...",""],
["./12_7-interrupt-and-exception-h.html","Introduction &#62; Architecture Overview &#62; Chapter 12 – AlphaCPU Core &#62; 12.7 Interrupt and Exception Handling","12.7.1 Interrupt Handling  AlphaCPU checks for interrupts at the start of every cycle (before fetch). The handleInterrupt() method:  voi...",""],
["./12_8-pal-integration.html","Introduction &#62; Architecture Overview &#62; Chapter 12 – AlphaCPU Core &#62; 12.8 PAL Integration","AlphaCPU provides two overloads of enterPalMode() — one for simple vector+faultPC entry, one for classified entry with PalEntryReason. Both follow...",""],
["./12_9-smp-awareness.html","Introduction &#62; Architecture Overview &#62; Chapter 12 – AlphaCPU Core &#62; 12.9 SMP Awareness","Each AlphaCPU knows its CPUId (m_cpuId, assigned at construction), participates in SMP coordination via injected references (m_reservationManager,...",""],
["./13_1-purpose-of-this-chapter.html","Introduction &#62; Architecture Overview &#62; Chapter 13 – AlphaPipeline Implementation &#62; 13.1 Purpose of This Chapter","This chapter documents the AlphaPipeline implementation: the internal execution conveyor that moves decoded instructions (\"grains\") from...",""],
["./13_10-exception-precision.html","Introduction &#62; Architecture Overview &#62; Chapter 13 – AlphaPipeline Implementation &#62; 13.10 Exception Precision","Exceptions are detected early (in EX) but delivered late (in WB). When a fault is detected in stage_EX(), slot.faultPending is set to true with th...",""],
["./13_11-branch-handling.html","Introduction &#62; Architecture Overview &#62; Chapter 13 – AlphaPipeline Implementation &#62; 13.11 Branch Handling","Branches are resolved in EX stage. IBox predicts the target during fetch and stores the prediction in slot.predictionTarget/predictionValid. In EX...",""],
["./13_12-ll_sc-and-determinism.html","Introduction &#62; Architecture Overview &#62; Chapter 13 – AlphaPipeline Implementation &#62; 13.12 LL/SC and Determinism","The pipeline enforces LL/SC semantics: speculation is allowed between LDL_L and STL_C, but reservations are cleared on exceptions, interrupts, bar...",""],
["./13_13-summary.html","Introduction &#62; Architecture Overview &#62; Chapter 13 – AlphaPipeline Implementation &#62; 13.13 Summary","The AlphaPipeline is simple in structure, strict in correctness, and aggressively deterministic.",""],
["./13_2-pipeline-role-and-design.html","Introduction &#62; Architecture Overview &#62; Chapter 13 – AlphaPipeline Implementation &#62; 13.2 Pipeline Role and Design","The AlphaPipeline is a single-issue, in-order, cycle-driven pipeline that models Alpha AXP execution with weak ordering and precise exceptions. Ke...",""],
["./13_3-pipeline-structure---ring.html","Introduction &#62; Architecture Overview &#62; Chapter 13 – AlphaPipeline Implementation &#62; 13.3 Pipeline Structure - Ring Buffer","13.3.1 Stage Constants  static constexpr int STAGE_COUNT = 6; static constexpr int STAGEIF = 0; // Instruction Fetch (youngest) static conste...",""],
["./13_4-pipelineslot-structure.html","Introduction &#62; Architecture Overview &#62; Chapter 13 – AlphaPipeline Implementation &#62; 13.4 PipelineSlot Structure","Each stage holds a PipelineSlot (PipeLineSlot.h, 409 lines) representing one in-flight instruction. Key fields:",""],
["./13_5-pipeline-execution---tick.html","Introduction &#62; Architecture Overview &#62; Chapter 13 – AlphaPipeline Implementation &#62; 13.5 Pipeline Execution - tick() and execute()","13.5.1 tick()  tick() is called once per cycle by AlphaCPU::runOneInstruction(). It supplies the IBox fetch result to the pipeline, calls exe...",""],
["./13_6-stage-implementations.html","Introduction &#62; Architecture Overview &#62; Chapter 13 – AlphaPipeline Implementation &#62; 13.6 Stage Implementations","13.6.1 stage_IF() — Instruction Fetch  Consumes the FetchResult from m_pendingFetch (supplied by IBox via supplyFetchResult()). Transfers the...",""],
["./13_7-stall-mechanics.html","Introduction &#62; Architecture Overview &#62; Chapter 13 – AlphaPipeline Implementation &#62; 13.7 Stall Mechanics","A PipelineSlot may stall (slot.stalled = true) due to: memory barrier pending (needsMemoryBarrier &#38;&#38; !memoryBarrierCompleted), write buffe...",""],
["./13_8-flush-semantics.html","Introduction &#62; Architecture Overview &#62; Chapter 13 – AlphaPipeline Implementation &#62; 13.8 Flush Semantics","Pipeline flush occurs on: branch misprediction (slot.flushPipeline from EX), exception delivery (from runOneInstruction after BoxResult), interrup...",""],
["./13_9-serialization-and-barrier.html","Introduction &#62; Architecture Overview &#62; Chapter 13 – AlphaPipeline Implementation &#62; 13.9 Serialization and Barriers in Pipeline","Barrier instructions (MB, WMB, EXCB, TRAPB) do not execute work — they enforce ordering. In EX stage, the grain sets slot.needsMemoryBarrier = tru...",""],
["./14_1-ibox---instruction-box.html","Introduction &#62; Architecture Overview &#62; Chapter 14 – Execution Domains (&#8220;Boxes&#8221;) &#62; 14.1 IBox – Instruction Box","The IBox is the instruction-supply front end of the emulated processor. It owns the fetch-decode pipeline and manages two levels of decode caching...",""],
["./14_2-ebox---integer-execution-.html","Introduction &#62; Architecture Overview &#62; Chapter 14 – Execution Domains (&#8220;Boxes&#8221;) &#62; 14.2 EBox – Integer Execution Box","The EBox is the integer execution unit. On the 21264 silicon, the Ebox contained four 64-bit adders, four logic units, two barrel shifters, and by...",""],
["./14_3-fbox---floating-point-exe.html","Introduction &#62; Architecture Overview &#62; Chapter 14 – Execution Domains (&#8220;Boxes&#8221;) &#62; 14.3 FBox – Floating-Point Execution Box","The FBox handles all IEEE 754 floating-point arithmetic. On the 21264, the Fbox comprised two floating-point pipelines (add and multiply), a divid...",""],
["./14_4-mbox---memory-box.html","Introduction &#62; Architecture Overview &#62; Chapter 14 – Execution Domains (&#8220;Boxes&#8221;) &#62; 14.4 MBox – Memory Box","The MBox executes all memory-referencing instructions: integer and floating-point loads and stores, unaligned accesses, locked load/store-conditio...",""],
["./14_5-cbox---cache-_-control-bo.html","Introduction &#62; Architecture Overview &#62; Chapter 14 – Execution Domains (&#8220;Boxes&#8221;) &#62; 14.5 CBox – Cache / Control Box","The CBox manages the cache subsystem, write buffering, memory barriers, branch prediction, and control-flow transfer instructions. On the 21264, t...",""],
["./14_6-palbox---privileged-archi.html","Introduction &#62; Architecture Overview &#62; Chapter 14 – Execution Domains (&#8220;Boxes&#8221;) &#62; 14.6 PalBox – Privileged Architecture Library Execution Box","The PalBox is an EmulatR-specific execution domain that has no direct hardware counterpart on the 21264 die. On real Alpha silicon, PALcode execut...",""],
["./14_7-box-interaction-model.html","Introduction &#62; Architecture Overview &#62; Chapter 14 – Execution Domains (&#8220;Boxes&#8221;) &#62; 14.7 Box Interaction Model","The six boxes do not call each other directly. Instead, they communicate through four shared mechanisms:",""],
["./14_8-repository-directory-mapp.html","Introduction &#62; Architecture Overview &#62; Chapter 14 – Execution Domains (&#8220;Boxes&#8221;) &#62; 14.8 Repository Directory Mapping","All box source code is located in the top level of the repository at https://github.com/timothyPeer/EmulatRAppUni.git, organized as follows:",""],
["./15_1-memory-is-shared_-not-own.html","Introduction &#62; Architecture Overview &#62; Chapter 15 – Memory System Implementation Details &#62; 15.1 Memory Is Shared, Not Owned","EMulatR implements a single shared physical address space, called GuestMemory, accessible by all CPUs. There is one unified physical address space...",""],
["./15_10-smp-visibility-guarantee.html","Introduction &#62; Architecture Overview &#62; Chapter 15 – Memory System Implementation Details &#62; 15.10 SMP Visibility Guarantees","In SMP systems, each CPU has independent write buffers managed by the WriteBufferManager. Barriers coordinate global visibility through the Memory...",""],
["./15_11-memory-fault-handling.html","Introduction &#62; Architecture Overview &#62; Chapter 15 – Memory System Implementation Details &#62; 15.11 Memory Fault Handling","Memory faults may occur during address translation (TLB miss), access permission checks (KRE/KWE/ERE/EWE/SRE/SWE/URE/UWE), alignment checks, MMIO ...",""],
["./15_12-diagnostics-and-dma-cohe.html","Introduction &#62; Architecture Overview &#62; Chapter 15 – Memory System Implementation Details &#62; 15.12 Diagnostics and DMA Coherency","15.12.1 Diagnostic Hooks  GuestMemory provides classifyPhysicalAddress(pa) which returns a human-readable string identifying the subsystem an...",""],
["./15_13-architectural-invariants.html","Introduction &#62; Architecture Overview &#62; Chapter 15 – Memory System Implementation Details &#62; 15.13 Architectural Invariants (Normative)","The following invariants are normative. Violating any invariant breaks Alpha architectural correctness.",""],
["./15_14-repository-directory-map.html","Introduction &#62; Architecture Overview &#62; Chapter 15 – Memory System Implementation Details &#62; 15.14 Repository Directory Mapping","All memory system source code is located in the repository at https://github.com/timothyPeer/EmulatRAppUni.git, organized as follows:",""],
["./15_2-guestmemory-vs-safememory.html","Introduction &#62; Architecture Overview &#62; Chapter 15 – Memory System Implementation Details &#62; 15.2 GuestMemory vs SafeMemory (Critical Separation)","15.2.1 GuestMemory – PA Router and Semantic Authority",""],
["./15_3-guestmemory-region-suppor.html","Introduction &#62; Architecture Overview &#62; Chapter 15 – Memory System Implementation Details &#62; 15.3 GuestMemory Region Support and PA Routing","15.3.1 PA Routing Table  GuestMemory maintains a QVector&#60;PARouteEntry&#62; routing table that maps contiguous physical address ranges to su...",""],
["./15_4-sparsememorybacking---on-.html","Introduction &#62; Architecture Overview &#62; Chapter 15 – Memory System Implementation Details &#62; 15.4 SparseMemoryBacking – On-Demand Page Allocator","SparseMemoryBacking is the physical storage engine behind SafeMemory. It implements on-demand page allocation so that the emulator can declare a 3...",""],
["./15_5-load-and-store-semantics.html","Introduction &#62; Architecture Overview &#62; Chapter 15 – Memory System Implementation Details &#62; 15.5 Load and Store Semantics","15.5.1 Loads – Synchronous and Visible  All loads in EMulatR complete synchronously during the EX stage. The MBox calls GuestMemory::readRout...",""],
["./15_6-write-buffer-implementati.html","Introduction &#62; Architecture Overview &#62; Chapter 15 – Memory System Implementation Details &#62; 15.6 Write Buffer Implementation","15.6.1 Per-CPU Write Buffer State  The WriteBufferManager maintains a CPUWriteBufferState for each CPU, containing a fixed array of 8 WriteBu...",""],
["./15_7-mmio-access-semantics.html","Introduction &#62; Architecture Overview &#62; Chapter 15 – Memory System Implementation Details &#62; 15.7 MMIO Access Semantics","MMIO accesses are strongly ordered. They are never buffered in the write buffer, execute synchronously, cannot be reordered relative to other MMIO...",""],
["./15_8-ll_sc-reservation-trackin.html","Introduction &#62; Architecture Overview &#62; Chapter 15 – Memory System Implementation Details &#62; 15.8 LL/SC Reservation Tracking","15.8.1 ReservationManager Design  Reservations are tracked by the ReservationManager in cpuCoreLib/, not by GuestMemory or SafeMemory. Each C...",""],
["./15_9-memory-barrier-coordinati.html","Introduction &#62; Architecture Overview &#62; Chapter 15 – Memory System Implementation Details &#62; 15.9 Memory Barrier Coordination","15.9.1 Barrier Mechanics  Memory barriers do not perform memory I/O. Instead, they stall the pipeline, prevent fetch and speculation, wait un...",""],
["./16_1-device-differentiation-an.html","Introduction &#62; Architecture Overview &#62; Chapter 16 – Device Model &#38; DMA &#62; 16.1 Device Differentiation and Class Hierarchy","16.1.1 Device Classes  EMulatR distinguishes devices by function, bus attachment, and I/O characteristics. The mmio_DeviceClass enumeration i...",""],
["./16_11-architectural-invariants.html","Introduction &#62; Architecture Overview &#62; Chapter 16 – Device Model &#38; DMA &#62; 16.11 Architectural Invariants (Normative)","The following invariants govern the device and DMA subsystem. Violation of any invariant constitutes an emulator bug.",""],
["./16_12-repository-directory-map.html","Introduction &#62; Architecture Overview &#62; Chapter 16 – Device Model &#38; DMA &#62; 16.12 Repository Directory Mapping","The device and DMA subsystem spans several library directories:",""],
["./16_2-mmio-routing-implementati.html","Introduction &#62; Architecture Overview &#62; Chapter 16 – Device Model &#38; DMA &#62; 16.2 MMIO Routing Implementation","16.2.1 Routing Path: VA to Device Handler  When a guest load or store instruction targets a device register, the access follows a multi-stage...",""],
["./16_3-endianness-and-device-reg.html","Introduction &#62; Architecture Overview &#62; Chapter 16 – Device Model &#38; DMA &#62; 16.3 Endianness and Device Registers","16.3.1 Alpha Is Always Little-Endian  All Alpha processors (21064, 21164, 21264/EV6) are natively little-endian. There is no big-endian mode ...",""],
["./16_4-asynchronous-device-threa.html","Introduction &#62; Architecture Overview &#62; Chapter 16 – Device Model &#38; DMA &#62; 16.4 Asynchronous Device Threading (QThread Model)","16.4.1 Threading Architecture  EMulatR uses Qt&#39;s QThread framework for all concurrent execution. Each AlphaCPU runs in its own QThread (manag...",""],
["./16_5-scsi-subsystem.html","Introduction &#62; Architecture Overview &#62; Chapter 16 – Device Model &#38; DMA &#62; 16.5 SCSI Subsystem","16.5.1 SCSI Architecture in EMulatR  The SCSI subsystem follows a layered structure that separates protocol types from bus controllers and fr...",""],
["./16_6-tape-drive-emulation-and-.html","Introduction &#62; Architecture Overview &#62; Chapter 16 – Device Model &#38; DMA &#62; 16.6 Tape Drive Emulation and Format Variants","16.6.1 Virtual Tape Architecture  EMulatR emulates SCSI tape drives via the SCSITape class, which presents standard sequential-access SCSI se...",""],
["./16_7-network-and-fibre-channel.html","Introduction &#62; Architecture Overview &#62; Chapter 16 – Device Model &#38; DMA &#62; 16.7 Network and Fibre Channel Devices","16.7.1 Network Adapter Emulation  Network interface emulation presents a PCI NIC to the guest OS with standard MMIO-mapped control registers,...",""],
["./16_8-irq-integration-architect.html","Introduction &#62; Architecture Overview &#62; Chapter 16 – Device Model &#38; DMA &#62; 16.8 IRQ Integration Architecture","16.8.1 IRQ System Migration  The device interrupt architecture in EMulatR has been migrated away from the legacy IRQController class. Device ...",""],
["./16_9-dma-implementation.html","Introduction &#62; Architecture Overview &#62; Chapter 16 – Device Model &#38; DMA &#62; 16.9 DMA Implementation","16.9.1 DMA Data Flow  DMA (Direct Memory Access) allows devices to read from and write to GuestMemory directly, without CPU intervention for ...",""],
["./17_1-alpha-virtual-address-for.html","Introduction &#62; Architecture Overview &#62; Chapter 17 – Address Translation, TLB, and PTE &#62; 17.1 Alpha Virtual Address Format","17.1.1 VA Structure  The Alpha AXP virtual address format is implementation-dependent, selected at CPU/board bring-up, not inferred from VA b...",""],
["./17_10-architectural-invariants.html","Introduction &#62; Architecture Overview &#62; Chapter 17 – Address Translation, TLB, and PTE &#62; 17.10 Architectural Invariants (Normative)","The following invariants govern the address translation subsystem. Violation of any invariant constitutes an emulator bug.",""],
["./17_11-repository-directory-map.html","Introduction &#62; Architecture Overview &#62; Chapter 17 – Address Translation, TLB, and PTE &#62; 17.11 Repository Directory Mapping","The address translation subsystem spans the following directories:",""],
["./17_2-pte-representation.html","Introduction &#62; Architecture Overview &#62; Chapter 17 – Address Translation, TLB, and PTE &#62; 17.2 PTE Representation","17.2.1 AlphaPTE – Canonical Structure  The AlphaPTE struct (pteLib/alpha_pte_core.h) represents the canonical Page Table Entry format. It pro...",""],
["./17_3-translation-path.html","Introduction &#62; Architecture Overview &#62; Chapter 17 – Address Translation, TLB, and PTE &#62; 17.3 Translation Path","17.3.1 Where Translation Occurs  Address translation occurs in MBox during the EX stage. The Ev6Translator (pteLib/ev6Translation_struct.h, ~...",""],
["./17_4-spam-tlb-cache-architectu.html","Introduction &#62; Architecture Overview &#62; Chapter 17 – Address Translation, TLB, and PTE &#62; 17.4 SPAM TLB Cache Architecture","17.4.1 What SPAM Is  SPAM (Set Prediction and Access Memory) is the name for the per-CPU PTE cache in EMulatR. It models the Alpha EV6 Transl...",""],
["./17_5-ev6silicontlb-and-layer-a.html","Introduction &#62; Architecture Overview &#62; Chapter 17 – Address Translation, TLB, and PTE &#62; 17.5 Ev6SiliconTLB and Layer Architecture","17.5.1 Three-Layer Design  The translation subsystem enforces strict layering to maintain separation of concerns:  Layer 0 — Silicon (SP...",""],
["./17_6-replacement-policies.html","Introduction &#62; Architecture Overview &#62; Chapter 17 – Address Translation, TLB, and PTE &#62; 17.6 Replacement Policies","TemplatePolicyBase.h defines the base classes and policies for cache replacement and invalidation strategies used by SPAMShardManager and SPAMBuck...",""],
["./17_7-asn-management-and-cohere.html","Introduction &#62; Architecture Overview &#62; Chapter 17 – Address Translation, TLB, and PTE &#62; 17.7 ASN Management and Coherence","17.7.1 Address Space Numbers  The Alpha architecture tags TLB entries with an Address Space Number (ASN) to avoid full TLB flushes on context...",""],
["./17_8-tlb-invalidation-and-shoo.html","Introduction &#62; Architecture Overview &#62; Chapter 17 – Address Translation, TLB, and PTE &#62; 17.8 TLB Invalidation and Shootdown","17.8.1 Local Invalidation Operations  Local TLB invalidation operates on a single CPU&#39;s SPAM shard. These operations are triggered by IPR wri...",""],
["./17_9-ibox-instruction-translat.html","Introduction &#62; Architecture Overview &#62; Chapter 17 – Address Translation, TLB, and PTE &#62; 17.9 IBox Instruction Translation","IBox performs instruction address translation independently of MBox data translation. During the Fetch (IF) stage, IBox translates the current PC ...",""],
["./18_1-exception-classification.html","Introduction &#62; Architecture Overview &#62; Chapter 18 – Fault Dispatcher &#38; Precise Exceptions &#62; 18.1 Exception Classification","18.1.1 Two-Level Classification  Every exceptional event in EMulatR carries a two-level classification. The high-level PendingEventKind (exce...",""],
["./18_10-architectural-invariants.html","Introduction &#62; Architecture Overview &#62; Chapter 18 – Fault Dispatcher &#38; Precise Exceptions &#62; 18.10 Architectural Invariants (Normative)","The following invariants govern the fault dispatch subsystem. Violation of any invariant constitutes an emulator bug.",""],
["./18_11-repository-directory-map.html","Introduction &#62; Architecture Overview &#62; Chapter 18 – Fault Dispatcher &#38; Precise Exceptions &#62; 18.11 Repository Directory Mapping","The fault dispatch subsystem spans several library directories:",""],
["./18_2-pendingevent-structure.html","Introduction &#62; Architecture Overview &#62; Chapter 18 – Fault Dispatcher &#38; Precise Exceptions &#62; 18.2 PendingEvent Structure","18.2.1 Unified Event Carrier  PendingEvent (faultLib/PendingEvent_Refined.h, ~420 lines) is the single structure that carries all information...",""],
["./18_3-exceptionfactory.html","Introduction &#62; Architecture Overview &#62; Chapter 18 – Fault Dispatcher &#38; Precise Exceptions &#62; 18.3 ExceptionFactory","ExceptionFactory_inl (exceptionLib/ExceptionFactory_inl.h, ~150 lines) provides typed construction helpers that create correctly-populated Pending...",""],
["./18_4-faultdispatcher-implement.html","Introduction &#62; Architecture Overview &#62; Chapter 18 – Fault Dispatcher &#38; Precise Exceptions &#62; 18.4 FaultDispatcher Implementation","18.4.1 Per-CPU Authority  There is one FaultDispatcher per CPU, accessed via globalFaultDispatcher(cpuId). The FaultDispatcher is the central...",""],
["./18_5-exception-to-pal-vector-m.html","Introduction &#62; Architecture Overview &#62; Chapter 18 – Fault Dispatcher &#38; Precise Exceptions &#62; 18.5 Exception-to-PAL Vector Mapping","18.5.1 ExceptionMapping  ExceptionMapping_inl::mapClassToPalVector() (exceptionLib/ExceptionMapping_inl.h) is the single source of truth for ...",""],
["./18_6-pipeline-fault-detection-.html","Introduction &#62; Architecture Overview &#62; Chapter 18 – Fault Dispatcher &#38; Precise Exceptions &#62; 18.6 Pipeline Fault Detection and Delivery Flow","18.6.1 Detect-Early / Deliver-Late Model  EMulatR implements the Alpha precise exception model through a detect-early/deliver-late pattern. F...",""],
["./18_7-pal-mode-entry.html","Introduction &#62; Architecture Overview &#62; Chapter 18 – Fault Dispatcher &#38; Precise Exceptions &#62; 18.7 PAL Mode Entry","18.7.1 enterPalMode() Sequence  All exception and interrupt delivery paths converge on AlphaCPU::enterPalMode(), which performs the atomic tr...",""],
["./18_8-precise-exception-guarant.html","Introduction &#62; Architecture Overview &#62; Chapter 18 – Fault Dispatcher &#38; Precise Exceptions &#62; 18.8 Precise Exception Guarantees","18.8.1 Architectural Guarantees  When an exception is delivered, the following guarantees hold: all prior instructions have completed (every ...",""],
["./18_9-barrier-interaction.html","Introduction &#62; Architecture Overview &#62; Chapter 18 – Fault Dispatcher &#38; Precise Exceptions &#62; 18.9 Barrier Interaction","Exceptions interact with the serialization and reservation systems through several mechanisms that ensure exception safety:",""],
["./19_1-interrupt-sources.html","Introduction &#62; Architecture Overview &#62; Chapter 19 – Interrupt Architecture &#38; IPI &#62; 19.1 Interrupt Sources","19.1.1 Device Interrupts  External devices (MMIO controllers, timers, disks, NICs) assert interrupts when DMA completes, an error occurs, or ...",""],
["./19_2-irqpendingstate-implement.html","Introduction &#62; Architecture Overview &#62; Chapter 19 – Interrupt Architecture &#38; IPI &#62; 19.2 IRQPendingState Implementation","19.2.1 Per-CPU Tracking Structure  IRQPendingState (coreLib/IRQPendingState.h, ~378 lines) is the per-CPU interrupt tracking structure. It is...",""],
["./19_3-interrupt-routing.html","Introduction &#62; Architecture Overview &#62; Chapter 19 – Interrupt Architecture &#38; IPI &#62; 19.3 Interrupt Routing","19.3.1 InterruptRouter  InterruptRouter (coreLib/InterruptRouter.h, ~505 lines) handles interrupt routing policy — determining which CPU rece...",""],
["./19_4-interrupt-sampling-and-de.html","Introduction &#62; Architecture Overview &#62; Chapter 19 – Interrupt Architecture &#38; IPI &#62; 19.4 Interrupt Sampling and Delivery","Interrupts are sampled during the pre-cycle phase of the AlphaCPU run loop, before pipeline advancement. The delivery sequence for the CPU thread ...",""],
["./19_5-ipi-architecture.html","Introduction &#62; Architecture Overview &#62; Chapter 19 – Interrupt Architecture &#38; IPI &#62; 19.5 IPI Architecture","19.5.1 Design Decision: Unified Interrupt Path  EMulatR intentionally does not create a second interrupt system for IPIs. Instead, IPIs are i...",""],
["./19_6-memory-barrier-coordinati.html","Introduction &#62; Architecture Overview &#62; Chapter 19 – Interrupt Architecture &#38; IPI &#62; 19.6 Memory Barrier Coordination","19.6.1 MemoryBarrierCoordinator  MemoryBarrierCoordinator (memoryLib/MemoryBarrierCoordinator.h, ~278 lines) is a singleton accessed via glob...",""],
["./19_7-tlb-shootdown-protocol.html","Introduction &#62; Architecture Overview &#62; Chapter 19 – Interrupt Architecture &#38; IPI &#62; 19.7 TLB Shootdown Protocol","TLB shootdown is the primary use case for IPIs. When a CPU modifies page tables, other CPUs may have stale TLB entries. Without invalidation, memo...",""],
["./19_8-architectural-invariants-.html","Introduction &#62; Architecture Overview &#62; Chapter 19 – Interrupt Architecture &#38; IPI &#62; 19.8 Architectural Invariants (Normative)","The following invariants govern the interrupt and IPI subsystem. Violation of any invariant breaks SMP correctness.",""],
["./19_9-repository-directory-mapp.html","Introduction &#62; Architecture Overview &#62; Chapter 19 – Interrupt Architecture &#38; IPI &#62; 19.9 Repository Directory Mapping","The interrupt and IPI subsystem spans the following directories:",""],
["./1_5-non-goalschapter1.html","Introduction &#62; Architecture Overview &#62; Chapter 1 - System Overview &#62; 1.5 Non-Goals","The following are explicit non-goals. These constraints keep the system maintainable and verifiable.",""],
["./1_6-control-and-data-flowchapter1.html","Introduction &#62; Architecture Overview &#62; Chapter 1 - System Overview &#62; 1.6 Control and Data Flow","At a high level, execution flows through the system as follows:",""],
["./1_7-architectural-invariants.html","Introduction &#62; Architecture Overview &#62; Chapter 1 - System Overview &#62; 1.7 Architectural Invariants","The following rules must always hold. Violating any invariant is a correctness bug, not an optimization opportunity. These invariants are authorit...",""],
["./1_8-how-to-read-this-guidechapter1.html","Introduction &#62; Architecture Overview &#62; Chapter 1 - System Overview &#62; 1.8 How to Read This Guide","This guide is organized into two groups. Group 1 (Chapters 1–11) defines the architecture: what must be true regardless of implementation. Group 2...",""],
["./20_1-palbox-execution-domain.html","Introduction &#62; Architecture Overview &#62; Chapter 20 – Boot Sequence, PAL, and SRM Integration &#62; 20.1 PalBox Execution Domain","20.1.1 Role and Design  The PalBox is an EmulatR-specific execution domain that has no direct hardware counterpart on the 21264 die. On real ...",""],
["./20_10-architectural-invariants.html","Introduction &#62; Architecture Overview &#62; Chapter 20 – Boot Sequence, PAL, and SRM Integration &#62; 20.10 Architectural Invariants (Normative)","The following invariants govern the PAL emulation subsystem. Violation of any invariant constitutes an emulator bug.",""],
["./20_11-repository-directory-map.html","Introduction &#62; Architecture Overview &#62; Chapter 20 – Boot Sequence, PAL, and SRM Integration &#62; 20.11 Repository Directory Mapping","The PAL emulation subsystem spans the following directories:",""],
["./20_2-palservice-delegation.html","Introduction &#62; Architecture Overview &#62; Chapter 20 – Boot Sequence, PAL, and SRM Integration &#62; 20.2 PalService Delegation","PalBox delegates most implementation to PalService (owned via std::unique_ptr&#60;PalService&#62;). PalBox methods follow a uniform pattern:",""],
["./20_3-call_pal-dispatch-and-vec.html","Introduction &#62; Architecture Overview &#62; Chapter 20 – Boot Sequence, PAL, and SRM Integration &#62; 20.3 CALL_PAL Dispatch and Vector Calculation","20.3.1 CALL_PAL Instruction  CALL_PAL is the only architecturally valid entry point into PAL mode (aside from exception/interrupt vectors). I...",""],
["./20_4-pal-mode-entry-and-exit.html","Introduction &#62; Architecture Overview &#62; Chapter 20 – Boot Sequence, PAL, and SRM Integration &#62; 20.4 PAL Mode Entry and Exit","20.4.1 enterPal() Entry Sequence  PalBoxBase::enterPal() performs the complete PAL mode transition in a fixed sequence:  BoxResult enter...",""],
["./20_5-shadow-registers-and-hwpc.html","Introduction &#62; Architecture Overview &#62; Chapter 20 – Boot Sequence, PAL, and SRM Integration &#62; 20.5 Shadow Registers and HWPCB","20.5.1 PAL Shadow Registers  When PAL mode is entered, shadow registers are activated providing a separate register workspace for PAL code. P...",""],
["./20_6-privileged-instructions.html","Introduction &#62; Architecture Overview &#62; Chapter 20 – Boot Sequence, PAL, and SRM Integration &#62; 20.6 Privileged Instructions","The following instructions are legal only in PAL mode. Outside PAL mode, each generates an OPCDEC (illegal instruction) fault.",""],
["./20_7-pal-function-inventory.html","Introduction &#62; Architecture Overview &#62; Chapter 20 – Boot Sequence, PAL, and SRM Integration &#62; 20.7 PAL Function Inventory","The PalBox supports approximately 80 PAL functions from the GrainMaster.tsv master opcode table, organized by category. All entries have Type PALc...",""],
["./20_8-cserve-and-srm-console-in.html","Introduction &#62; Architecture Overview &#62; Chapter 20 – Boot Sequence, PAL, and SRM Integration &#62; 20.8 CSERVE and SRM Console Integration","20.8.1 CSERVE Architecture  CALL_PAL CSERVE (function 0x09) is the only officially supported I/O interface used by the SRM console prior to O...",""],
["./20_9-boot-sequence.html","Introduction &#62; Architecture Overview &#62; Chapter 20 – Boot Sequence, PAL, and SRM Integration &#62; 20.9 Boot Sequence","20.9.1 Phase 0 — Static Construction  Before any CPU runs, all global subsystems are constructed: GuestMemory (physical RAM allocated, MMIO r...",""],
["./21_1-determinism-as-a-design-g.html","Introduction &#62; Architecture Overview &#62; Chapter 21 – Debugging, Tracing, and Determinism &#62; 21.1 Determinism as a Design Goal","21.1.1 Definition  Determinism in EMulatR means: given the same initial state, with the same inputs, and the same configuration, the emulator...",""],
["./21_10-architectural-invariants.html","Introduction &#62; Architecture Overview &#62; Chapter 21 – Debugging, Tracing, and Determinism &#62; 21.10 Architectural Invariants (Normative)","The following invariants govern the debugging, tracing, and determinism subsystem. Violating any invariant invalidates emulator credibility.",""],
["./21_11-repository-directory-map.html","Introduction &#62; Architecture Overview &#62; Chapter 21 – Debugging, Tracing, and Determinism &#62; 21.11 Repository Directory Mapping","The debugging, tracing, and determinism infrastructure spans the following locations:",""],
["./21_2-sources-of-nondeterminism.html","Introduction &#62; Architecture Overview &#62; Chapter 21 – Debugging, Tracing, and Determinism &#62; 21.2 Sources of Nondeterminism","EMulatR explicitly identifies potential nondeterminism sources and applies control strategies to each:",""],
["./21_3-exectrace-instrumentation.html","Introduction &#62; Architecture Overview &#62; Chapter 21 – Debugging, Tracing, and Determinism &#62; 21.3 EXECTRACE Instrumentation System","21.3.1 Architecture  Instrumentation is controlled by the AXP_INSTRUMENTATION_TRACE compile-time flag. When enabled, EXECTRACE macros (coreLi...",""],
["./21_4-subsystem-logging-(debug_.html","Introduction &#62; Architecture Overview &#62; Chapter 21 – Debugging, Tracing, and Determinism &#62; 21.4 Subsystem Logging (DEBUG_LOG)","Every major subsystem includes DEBUG_LOG instrumentation for operational diagnostics. Unlike the EXECTRACE system (which targets architectural tra...",""],
["./21_5-tracing-by-subsystem.html","Introduction &#62; Architecture Overview &#62; Chapter 21 – Debugging, Tracing, and Determinism &#62; 21.5 Tracing by Subsystem","21.5.1 Instruction Tracing  Instruction tracing records: PC at fetch, decoded instruction (opcode, function, ra/rb/rc), grain identity (point...",""],
["./21_6-logreader-diagnostic-appl.html","Introduction &#62; Architecture Overview &#62; Chapter 21 – Debugging, Tracing, and Determinism &#62; 21.6 LogReader Diagnostic Application","The LogReader is a separate Qt-based GUI application (tools/LogReader/) that provides real-time diagnostic monitoring of the running emulator. It ...",""],
["./21_7-breakpoints-and-watchpoin.html","Introduction &#62; Architecture Overview &#62; Chapter 21 – Debugging, Tracing, and Determinism &#62; 21.7 Breakpoints and Watchpoints","21.7.1 Breakpoints  Supported breakpoint types: PC breakpoints (halt when PC matches a specified address), instruction-class breakpoints (hal...",""],
["./21_8-deterministic-replay.html","Introduction &#62; Architecture Overview &#62; Chapter 21 – Debugging, Tracing, and Determinism &#62; 21.8 Deterministic Replay","EMulatR supports deterministic replay by recording external inputs (console keystrokes, device events), interrupt injection points (cycle number a...",""],
["./21_9-smp-debugging-considerati.html","Introduction &#62; Architecture Overview &#62; Chapter 21 – Debugging, Tracing, and Determinism &#62; 21.9 SMP Debugging Considerations","SMP debugging introduces challenges that do not exist in single-CPU configurations. Each CPU has an independent trace stream. There is no implicit...",""],
["./22_1-definition-of-correctness.html","Introduction &#62; Architecture Overview &#62; Chapter 22 – Testing, Validation, and Architectural Compliance &#62; 22.1 Definition of Correctness","Correctness in EMulatR is defined architecturally, not microarchitecturally. The emulator claims correctness when:",""],
["./22_10-known-deviations-and-non.html","Introduction &#62; Architecture Overview &#62; Chapter 22 – Testing, Validation, and Architectural Compliance &#62; 22.10 Known Deviations and Non-Goals","EMulatR explicitly documents its deviations from silicon behavior and its non-goals. These are documented choices, not omissions.",""],
["./22_11-architectural-invariants.html","Introduction &#62; Architecture Overview &#62; Chapter 22 – Testing, Validation, and Architectural Compliance &#62; 22.11 Architectural Invariants (Normative)","The following invariants govern the testing, validation, and compliance framework. Violation of any invariant invalidates compliance claims.",""],
["./22_12-final-compliance-stateme.html","Introduction &#62; Architecture Overview &#62; Chapter 22 – Testing, Validation, and Architectural Compliance &#62; 22.12 Final Compliance Statement","EMulatR is not validated by optimism or anecdote. It is validated by deterministic execution, layered testing, explicit invariants, and architectu...",""],
["./22_2-layered-validation-strate.html","Introduction &#62; Architecture Overview &#62; Chapter 22 – Testing, Validation, and Architectural Compliance &#62; 22.2 Layered Validation Strategy","Validation is structured in five layers, each with a clear responsibility and escalating scope. Tests at each layer must pass before the next laye...",""],
["./22_3-determinism-as-a-validati.html","Introduction &#62; Architecture Overview &#62; Chapter 22 – Testing, Validation, and Architectural Compliance &#62; 22.3 Determinism as a Validation Tool","Determinism is not merely a debugging aid — it is a validation instrument. By enforcing deterministic execution (Chapter 21), the emulator gains c...",""],
["./22_4-exception-and-fault-valid.html","Introduction &#62; Architecture Overview &#62; Chapter 22 – Testing, Validation, and Architectural Compliance &#62; 22.4 Exception and Fault Validation","Exception correctness is validated by triggering known fault conditions and verifying the complete delivery chain:",""],
["./22_5-memory-ordering-and-ll_sc.html","Introduction &#62; Architecture Overview &#62; Chapter 22 – Testing, Validation, and Architectural Compliance &#62; 22.5 Memory Ordering and LL/SC Validation","22.5.1 Memory Ordering Validation  Memory model validation focuses on: visibility ordering (stores become visible to other CPUs in the correc...",""],
["./22_6-pal-and-privilege-boundar.html","Introduction &#62; Architecture Overview &#62; Chapter 22 – Testing, Validation, and Architectural Compliance &#62; 22.6 PAL and Privilege Boundary Validation","PAL validation ensures that the privileged boundary is absolute and that no violation escapes detection.",""],
["./22_7-device-and-dma-validation.html","Introduction &#62; Architecture Overview &#62; Chapter 22 – Testing, Validation, and Architectural Compliance &#62; 22.7 Device and DMA Validation","Device validation focuses on the contract between devices and the architectural execution model.",""],
["./22_8-regression-testing-policy.html","Introduction &#62; Architecture Overview &#62; Chapter 22 – Testing, Validation, and Architectural Compliance &#62; 22.8 Regression Testing Policy","Every validated behavior becomes a regression test. The regression policy is strict and non-negotiable:",""],
["./22_9-architectural-compliance-.html","Introduction &#62; Architecture Overview &#62; Chapter 22 – Testing, Validation, and Architectural Compliance &#62; 22.9 Architectural Compliance Matrix","EMulatR maintains a living compliance matrix mapping Alpha AXP architectural requirements to implementation status. Each requirement from the Alph...",""],
["./3_15-ll_sc-interaction-with-th.html","Introduction &#62; Architecture Overview &#62; Chapter 3 - Pipeline Architecture &#62; 3.15 LL/SC Interaction with the Pipeline","The pipeline enforces LL/SC (Load-Locked / Store-Conditional) semantics in coordination with the ReservationManager:",""],
["./3_16-grain-system-chapter3.html","Introduction &#62; Architecture Overview &#62; Chapter 3 - Pipeline Architecture &#62; 3.16 Grain System ","The grain system provides the instruction abstraction layer that bridges raw 32-bit instruction words to executable behavior.",""],
["./4_1-purpose-of-this-chapter.html","Introduction &#62; Architecture Overview &#62; Chapter 4 - Functional Execution Domains (\"Boxes) &#62; 4.1 Purpose of This Chapter","This chapter defines the Functional Execution Domains, commonly referred to as \"Boxes\", used throughout the EMulatR Alpha AXP emulator. ...",""],
["./5_10-memory-barriers-(preview).html","Introduction &#62; Architecture Overview &#62; Chapter 5 - Memory System Architecture &#62; 5.10 Memory Barriers (preview)","Memory barriers enforce ordering by stalling the pipeline until required conditions are met. Barriers do not perform memory operations, do not exe...",""],
["./5_2-purpose-of-this-chapter.html","Introduction &#62; Architecture Overview &#62; Chapter 5 - Memory System Architecture &#62; 5.1 Purpose of This Chapter","This chapter defines the memory architecture of EMulatR. It explains how memory is modeled, accessed, translated, ordered, and shared across CPUs ...",""],
["./6_1-purpose-of-this-chapter.html","Introduction &#62; Architecture Overview &#62; Chapter 6 - Serialization and Stall Model &#62; 6.1 Purpose of This Chapter","This chapter defines how the EMulatR emulator enforces ordering, visibility, and completion in an otherwise weakly ordered execution model.",""],
["./7_1-purpose-of-this-chapter.html","Introduction &#62; Architecture Overview &#62; Chapter 7 - Exceptions, Faults, and Interrupts &#62; 7.1 Purpose of This Chapter","This chapter defines how the EMulatR emulator detects, prioritizes, delivers, and resolves exceptions, faults, and interrupts while maintaining pr...",""],
["./7_4-exception-detection-points.html","Introduction &#62; Architecture Overview &#62; Chapter 7 - Exceptions, Faults, and Interrupts &#62; 7.4 Exception Detection Points","7.4.1 Where Faults Are Detected  Faults are detected primarily in the Execute (EX) stage, during grain-&#62;execute(). Detection sources inclu...",""],
["./8_1-purpose-of-this-chapter.html","Introduction &#62; Architecture Overview &#62; Chapter 8 - PAL and Privileged Boundary &#62; 8.1 Purpose of This Chapter","This chapter defines the Privileged Architecture Library (PAL) boundary and explains how the EMulatR emulator enforces architectural privilege sep...",""],
["./8_12-pal-register-matrix.html","Introduction &#62; Architecture Overview &#62; Chapter 8 - PAL and Privileged Boundary &#62; 8.12 PAL Register Matrix","This reference matrix documents the register read (R) and write (W) patterns for each PAL call and privileged instruction. Registers are R0–R31 (i...",""],
["./8_13-summary.html","Introduction &#62; Architecture Overview &#62; Chapter 8 - PAL and Privileged Boundary &#62; 8.13 Summary","The EMulatR PAL implementation provides a precise, verifiable privileged boundary that mirrors Alpha AXP hardware behavior.",""],
["./9_1-purpose-of-this-chapter.html","Introduction &#62; Architecture Overview &#62; Chapter 9 - SMP Architecture &#62; 9.1 Purpose of This Chapter","This chapter defines how EMulatR implements symmetric multiprocessing (SMP) while preserving Alpha AXP architectural guarantees.",""],
["./9_10-barriers-in-smp-context.html","Introduction &#62; Architecture Overview &#62; Chapter 9 - SMP Architecture &#62; 9.10 PAL and SMP","PAL plays a central role in SMP correctness. It is the only execution context with the privilege level needed for cross-CPU coordination:",""],
["./9_11-pal-and-smp.html","Introduction &#62; Architecture Overview &#62; Chapter 9 - SMP Architecture &#62; 9.11 Exception and Interrupt Isolation","In SMP, exceptions and interrupts are strictly isolated per-CPU:",""],
["./9_12-exception-and-interrupt-i.html","Introduction &#62; Architecture Overview &#62; Chapter 9 - SMP Architecture &#62; 9.12 Debugging SMP Behavior","Deterministic SMP behavior depends on observability. Key debugging principles:",""],
["./9_14-summary.html","Introduction &#62; Architecture Overview &#62; Chapter 9 - SMP Architecture &#62; 9.13 Summary","The EMulatR SMP architecture provides correct, deterministic multiprocessor behavior that matches Alpha AXP specifications.",""],
["./acronyms--usage-appendix.html","Acronyms &#38; Usage","===============================================================================",""],
["./alpha-boot-sequence.html","Alpha Boot Sequence","╔══════════════════════════════════════════════════════════════════╗",""],
["./alpha-physical-address-space.html","Alpha Physical Address Space","================================================================================",""],
["./alpha-pipeline-.html","Alpha PipeLine ","The pipeline is responsible for executing the Instruction Grain life-cycle.  All processing adjacent to it is a side-effect to support the pr...",""],
["./alpha-va-format-contract.html","Introduction &#62; Architecture Overview &#62; Chapter 5 - Memory System Architecture &#62; 5.4.4 Alpha VA Field Boundary Reference","This section provides the normative bit-field boundary tables for all four Alpha AXP page size options. These are the decoding rules applied after...",""],
["./alpha.html","Alpha","Namespace: Alpha  Element Description Header SizeClassId (enum)  alpha_pte_core.h PageSizeCode (enum) // Portable page size encoding alp...",""],
["./alphacpu-alpha.html","AlphaCPU","Primary Responsibility. CPU is sole authority on architectural PC (Architectural Commit)  Rules.  Published Interfaces. Alpha PipeLine &#38;...",""],
["./alphacpu-core.html","Introduction &#62; Architecture Overview &#62; Chapter 12 – AlphaCPU Core","Introduction  The AlphaCPU Core represents the central execution engine of EMulatR. It is responsible for maintaining architectural state, co...",""],
["./alphacpudependency.html","AlphaCPU","Instruction Semantics CPU-REQ-001: For every LL instruction: Perform load from SafeMemory; Invoke ReservationManager::reserve(cpu, pa). CPU-REQ-00...",""],
["./alphamemorysystem-managers.html","AlphaMemorySystem","Page Table Support: The Page Table Support section in the updated AlphaMemorySystem.h file looks good. It includes the necessary functions for han...",""],
["./alphapipeline-implementation.html","Introduction &#62; Architecture Overview &#62; Chapter 13 – AlphaPipeline Implementation","Introduction  The AlphaPipeline component models the structured instruction flow of a single Alpha AXP processor within EMulatR. It represent...",""],
["./alphasystemmemoryfinakl.html","AlphaSystemMemoryFinakl","Agreed — this is exactly the right moment to **fix it and formally lock the contract down**.",""],
["./alpha_alu_inl.html","alpha_alu_inl","Namespace: alpha_alu  Returned Function  Description / Usage s64 sext32 Sign-extend a 32-bit value to 64-bit signed integer (Alpha 32-bi...",""],
["./alpha_fp_helpers_inl.html","alpha_fp_helpers_inl","Legacy:  Returned Function Name Inferred description void applyVariantRoundingMode Set IEEE floating-point rounding mode based on Alpha FP va...",""],
["./alpha_int_byteops_inl.html","alpha_int_byteops_inl","This header is a canonical Alpha byte-ops implementation:",""],
["./alpha_int_helpers_inl.html","alpha_int_helpers_inl","This header cleanly separates pure arithmetic semantics from:",""],
["./alpha_operate_opcode_helper.html","alpha_operate_opcode_helper","This helper is decode-time logic, not execution logic.",""],
["./alpha_spam_manager.html","Alpha_SPAM_Manager","PTEs are cached in the TLB entries via pteRaw in SPAMEntry.",""],
["./alpha_sse_fp_inl.html","alpha_SSE_fp_inl","Returned Function Name Inferred description quint64 add64 Add unsigned 64-bit integers using SSE2 when available and update FPCR on overflow qint6...",""],
["./alpha_sse_int_inl.html","alpha_SSE_int_inl","Returned Function InferredDescription qint64 addS64_int Performs signed 64-bit integer addition using SSE2 when available, detects signed overflow...",""],
["./appendix---trait-examples.html","Introduction &#62; Appendix","The following appendices provide quick-reference tables, canonical type definitions, and implementation reference material that support the archit...",""],
["./appendix-a---ev6-internal-proc.html","Introduction &#62; Appendix &#62; Appendix A – EV6 Internal Processor Register (IPR) Reference","This appendix lists all EV6 Internal Processor Registers (IPRs) as implemented in EMulatR. IPRs are accessed exclusively through HW_MFPR (opcode 0...",""],
["./appendix-b---core-types-refere.html","Introduction &#62; Appendix &#62; Appendix B – Core Types Reference","Canonical type definitions from coreLib/types_core.h. All emulator subsystems use these types for architectural values.",""],
["./appendix-c---glossary-and-acro.html","Introduction &#62; Appendix &#62; Appendix C – Glossary and Acronyms","ASN — Address Space Number. 8-bit identifier distinguishing TLB entries by process; avoids TLB flush on context switch when ASN changes.",""],
["./appendix-d---instruction-inven.html","Introduction &#62; Appendix &#62; Appendix D – Instruction Inventory (GrainMaster.tsv)","The GrainMaster.tsv file (grainfactoryLib/grains/GrainMaster.tsv) is the master opcode table containing 616 entries that define every instruction ...",""],
["./appendix-e---physical-address-.html","Introduction &#62; Appendix &#62; Appendix E – Physical Address Memory Map","Canonical PA routing table for EMulatR. All physical address classification is performed by GuestMemory, which is the single source of truth for P...",""],
["./appendix-f---repository-direct.html","Introduction &#62; Appendix &#62; Appendix F – Repository Directory Structure","Top-level organization of the EMulatR source repository at https://github.com/timothyPeer/EmulatRAppUni.git:",""],
["./appendix-g---decodedinstructio.html","Introduction &#62; Appendix &#62; Appendix G – DecodedInstruction Quick Reference","The DecodedInstruction structure (DecodedInstruction_Ultra.h) uses an ultra-optimized packed layout (24-byte hot path) and is the primary data car...",""],
["./appendix-h---endianness-rules.html","Introduction &#62; Appendix &#62; Appendix H – Endianness Rules","Alpha is always little-endian. There is no big-endian mode. This is an architectural constant across all Alpha generations (21064, 21164, 21264/EV...",""],
["./appendix-i---global-singletons.html","Introduction &#62; Appendix &#62; Appendix I – Global Singletons","EMulatR uses Meyer&#39;s Singleton pattern for global subsystem access. Each singleton is a function returning a static local instance, guaranteeing t...",""],
["./architectural-high-value.html","Architectural High-Value","Enter topic text here.",""],
["./architectural-overview---memor.html","Architectural Overview - Memory System","+----------------------------+                      &#124;    GlobalIRQController &#38;nbs...",""],
["./architecture-overview.html","Introduction &#62; Architecture Overview","1. Purpose of This Chapter  This chapter provides a top-level architectural description of the EMulatR system. Its purpose is to explain what...",""],
["./architecture.html","Architecture","Architecture Navigation: No topics above this level Architecture ",""],
["./arithextender_helpers.html","arithExtender_helpers","Returned Function Name Inferred Description void seedEmulatrRandom Initializes the legacy Qt random number generator (qsrand) for older Qt version...",""],
["./asa-emulatr_ini.html","ASA-EmulatR.ini","Enter topic text here.",""],
["./ast-delivery.html","AST Delivery","PAL_AST_USER handler:     1. Save context to process block     2. Vector to OS AST dispatcher     ↓ OS AST handler: ...",""],
["./automatic-generationgrains.html","Automatic Generation","Python Script:  py grain_validator.py --tsv z:\\EmulatrAppUni\\grainfactoryLib\\grains\\GrainMaster.tsv --generate     --output z:\\Emul...",""],
["./axp_attributes_core.html","Axp_Attributes_core","Returned / Defined Name Inferred Description macro AXP_COMPILER_MSVC Compile-time flag indicating MSVC compiler macro AXP_COMPILER_CLANG Compile-t...",""],
["./backup-gude-claude-todo.html","Backup Gude Claude TODO","# MEMORY ARCHITECTURE REFACTORING - IMPLEMENTATION GUIDE",""],
["./barriers.html","Barriers","Enter topic text here.",""],
["./bootstrap.html","Bootstrap","AlphaStation Emulator Console V1.0-0     EMulatR (c) 2025 Timothy Peer / eNVy Systems, Inc.             &#38;n...",""],
["./box-architecture.html","BOX Architecture","Silicon Box EmulatR Subsystem IBox IBox class + Pipeline fetch/decode stages + iGrain resolver Responsibilities:  Fetches PC Requests PC tran...",""],
["./box-orchestration.html","Box Orchestration","Top-Level CPU Diagram  +---------------------------+ &#124;         AlphaCPU          &#124; &#124;------------...",""],
["./branch-prediction-alphapipeline.html","Branch Prediction","Pipeline EX stage performs: execute instruction grain evaluate branch condition compute actual target call CBox::resolveBranch(...) if mispredict ...",""],
["./branch-prediction.html","Branch Prediction","Models Supported:  Pattern History Table   Rules:  Is part of the control flow and is implemented in the CBox (control box)   ...",""],
["./cache-alpha.html","Cache","Enter topic text here.",""],
["./cbox.html","CBox","Rules.  Owns Branch Prediction and  Branch Resolution Is truth source for prediction + correctness checking. Pipeline is truth source fo...",""],
["./chapter-10---devices-and-mmio.html","Introduction &#62; Architecture Overview &#62; Chapter 10 – Devices and Memory-Mapped I/O (MMIO)","10.1 Purpose of This Chapter  This chapter defines how EmulatR models devices and memory-mapped I/O (MMIO), and how device interactions integ...",""],
["./chapter-11---architectural-inv.html","Introduction &#62; Architecture Overview &#62; Chapter 11 - Architectural Invariants","11.1 Purpose of This Chapter  This chapter defines the architectural invariants of EmulatR.  An architectural invariant is a rule that: ...",""],
["./chapter-11-interaction-with-se.html","Introduction &#62; Architecture Overview &#62; Chapter 7 - Exceptions, Faults, and Interrupts &#62; 7.12 Interaction with Serialization and LL/SC","Exceptions interact with the serialization and reservation systems in several ways:",""],
["./chapter-14---execution-domains.html","Introduction &#62; Architecture Overview &#62; Chapter 14 – Execution Domains (&#8220;Boxes&#8221;)","The EMulatR processor model is organized into six discrete execution domains, each implemented as a self-contained C++ class known as a \"Box....",""],
["./chapter-15---memory-system-imp.html","Introduction &#62; Architecture Overview &#62; Chapter 15 – Memory System Implementation Details","This chapter describes how memory is actually implemented inside EMulatR, not merely how it behaves architecturally. Where earlier chapters define...",""],
["./chapter-16---device-model--dma.html","Introduction &#62; Architecture Overview &#62; Chapter 16 – Device Model &#38; DMA","This chapter describes the implementation of the EMulatR device subsystem: how devices are constructed, differentiated, routed through MMIO, threa...",""],
["./chapter-17---tlb_-pte_-and-add.html","Introduction &#62; Architecture Overview &#62; Chapter 17 – Address Translation, TLB, and PTE","This chapter describes the implementation of address translation in EMulatR: how virtual addresses are converted to physical addresses, how TLB ca...",""],
["./chapter-18---fault-dispatcher-.html","Introduction &#62; Architecture Overview &#62; Chapter 18 – Fault Dispatcher &#38; Precise Exceptions","This chapter describes the implementation of the EMulatR exception and fault delivery subsystem: how exceptional events are created, classified, q...",""],
["./chapter-19---debugging_-tracin.html","Introduction &#62; Architecture Overview &#62; Chapter 19 – Interrupt Architecture &#38; IPI","This chapter describes the implementation of the EMulatR interrupt and inter-processor interrupt (IPI) subsystem: how interrupts are generated, ro...",""],
["./chapter-1_.html","Introduction &#62; Architecture Overview &#62; Chapter 1 - System Overview","1.1 Purpose and Audience  EMulatR is a cycle-based, SMP-capable Alpha AXP processor emulator designed to faithfully reproduce the architectur...",""],
["./chapter-1_2---design-goals-and.html","Introduction &#62; Architecture Overview &#62; Chapter 1 - System Overview &#62; 1.2 Design Goals and Guiding Principles","EMulatR is designed around five primary goals, listed in strict priority order. Every design decision in the emulator is evaluated against these g...",""],
["./chapter-1_3---major-architectu.html","Introduction &#62; Architecture Overview &#62; Chapter 1 - System Overview &#62; 1.3 Target Architecture","EMulatR targets the following architectural profile:",""],
["./chapter-1_4---architectural-in.html","Introduction &#62; Architecture Overview &#62; Chapter 1 - System Overview &#62; 1.4 Major Architectural Layers","EMulatR is structured into six conceptual layers. Each layer has a clearly defined responsibility and communicates with adjacent layers through ex...",""],
["./chapter-2---execution-model.html","Introduction &#62; Architecture Overview &#62; Chapter 2 - Execution Model","2.1 Cycle-Based Execution  EMulatR operates on a cycle-based execution model where each iteration of the AlphaCPU run loop represents one har...",""],
["./chapter-20---boot-sequence_-pa.html","Introduction &#62; Architecture Overview &#62; Chapter 20 – Boot Sequence, PAL, and SRM Integration","This chapter describes the implementation of the EMulatR Privileged Architecture Library (PAL) emulation layer and the boot sequence that brings t...",""],
["./chapter-21---debugging_-tracin.html","Introduction &#62; Architecture Overview &#62; Chapter 21 – Debugging, Tracing, and Determinism","This chapter defines how EMulatR enables systematic debugging, high-fidelity tracing, and repeatable deterministic execution across single-CPU and...",""],
["./chapter-22---testing_-validati.html","Introduction &#62; Architecture Overview &#62; Chapter 22 – Testing, Validation, and Architectural Compliance","This chapter defines the verification strategy for EMulatR. It explains how correctness is tested, how regressions are prevented, and how architec...",""],
["./chapter-2_1-purpose-of-this-ch.html","Introduction &#62; Architecture Overview &#62; Chapter 2 - Execution Model &#62; 2.1 Purpose of this Chapter","This chapter defines the execution model of EMulatR. It explains how AlphaCPU instances advance instructions, how cycles are defined and processed...",""],
["./chapter-2_10-summary.html","Introduction &#62; Architecture Overview &#62; Chapter 2 - Execution Model &#62; 2.10 Summary","The EMulatR execution model is: Cycle-based and deterministic — one iteration equals one hardware cycle Pipeline-driven with explicit serializatio...",""],
["./chapter-2_2-cycle-base-executi.html","Introduction &#62; Architecture Overview &#62; Chapter 2 - Execution Model &#62; 2.2 Cycle-Base Execution Model","2.2.1 One Cycle per Iteration  EMulatR uses a cycle-based execution model: Each iteration of the AlphaCPU run loop represents one hardware cl...",""],
["./chapter-2_3-responsibilities-o.html","Introduction &#62; Architecture Overview &#62; Chapter 2 - Execution Model &#62; 2.3 Responsibilities of the AlphaCPU Run Loop","The AlphaCPU run loop is the clocked execution engine. Each iteration represents one hardware cycle. The run loop is the only place where executio...",""],
["./chapter-2_4---execution-phases.html","Introduction &#62; Architecture Overview &#62; Chapter 2 - Execution Model &#62; 2.4 Execution Phases per Cycle","Each cycle consists of the following conceptual phases. These phases are descriptive of the architectural contract; their implementation may overl...",""],
["./chapter-2_5-execution-progress.html","Introduction &#62; Architecture Overview &#62; Chapter 2 - Execution Model &#62; 2.5 Execution Progress and Stalls","2.5.1 Forward Progress Guarantee  Execution progresses unless explicitly blocked by an architectural condition. The run loop guarantees forwa...",""],
["./chapter-2_6-speculation-policy.html","Introduction &#62; Architecture Overview &#62; Chapter 2 - Execution Model &#62; 2.6 Speculation Policy","EMulatR enforces a conservative but correct speculation model:",""],
["./chapter-2_7-execution-and-comm.html","Introduction &#62; Architecture Overview &#62; Chapter 2 - Execution Model &#62; 2.7 Execution and Commit Semantics","2.7.1 Execute Stage Semantics  All instruction semantics occur in the Execute (EX) stage: Integer arithmetic and logic (EBox) Floating-point ...",""],
["./chapter-2_8-interaction-with-s.html","Introduction &#62; Architecture Overview &#62; Chapter 2 - Execution Model &#62; 2.8 Interaction with SMP Systems","In multiprocessor configurations, the execution model does not assume lockstep execution between CPUs. Each CPU advances independently.",""],
["./chapter-2_9-relationship-to-ot.html","Introduction &#62; Architecture Overview &#62; Chapter 2 - Execution Model &#62; 2.9 Relationship to Other Chapters","This chapter defines how execution progresses — the cycle contract, run-loop responsibilities, stall sources, and commit semantics. It deliberatel...",""],
["./chapter-3---pipeline-architect.html","Introduction &#62; Architecture Overview &#62; Chapter 3 - Pipeline Architecture","3.1 Purpose of This Chapter  This chapter defines the structure, responsibilities, and invariants of the AlphaPipeline in EMulatR.  It e...",""],
["./chapter-3-key-takeaways.html","Introduction &#62; Architecture Overview &#62; Chapter 3 - Pipeline Architecture &#62; 3.17 Relationship to Other Chapters","This chapter defines pipeline structure and rules. It defers the following to their respective chapters:",""],
["./chapter-3_10-pipeline-semantic.html","Introduction &#62; Architecture Overview &#62; Chapter 3 - Pipeline Architecture &#62; 3.10 PipelineSlot Contract","Each pipeline stage holds a PipelineSlot (defined in machineLib/PipeLineSlot.h), which represents one in-flight instruction. The slot encapsulates...",""],
["./chapter-3_11-backward-pipeline.html","Introduction &#62; Architecture Overview &#62; Chapter 3 - Pipeline Architecture &#62; 3.11 Backward Pipeline Advancement","The pipeline advances from WB backward to IF each cycle. Within the tick() method, stages execute in this order:",""],
["./chapter-3_12-stalls-and-serial.html","Introduction &#62; Architecture Overview &#62; Chapter 3 - Pipeline Architecture &#62; 3.12 Stalls and Serialization ","Stall Sources  A PipelineSlot may stall due to: Memory barriers (MB, WMB) — slot.needsMemoryBarrier set, waiting for completion Exception bar...",""],
["./chapter-3_13-flushing-and-spec.html","Introduction &#62; Architecture Overview &#62; Chapter 3 - Pipeline Architecture &#62; 3.13 Flushing and Speculation","Flush Causes  Pipeline slots may be flushed due to: Branch misprediction — actual outcome does not match prediction from IF Exception deliver...",""],
["./chapter-3_15-precise-exception.html","Introduction &#62; Architecture Overview &#62; Chapter 3 - Pipeline Architecture &#62; 3.14 Precise Exceptions ","The pipeline guarantees precise exceptions. This means:",""],
["./chapter-3_16-summary.html","Introduction &#62; Architecture Overview &#62; Chapter 3 - Pipeline Architecture &#62; 3.18 Summary","The AlphaPipeline in EMulatR is in-order, execute-centric, deterministic, precisely serialized, and SMP-safe by design.",""],
["./chapter-3_2-overview-of-the-pi.html","Introduction &#62; Architecture Overview &#62; Chapter 3 - Pipeline Architecture &#62; 3.2 Overview of the Pipeline Model","EMulatR implements a six-stage, in-order Alpha AXP pipeline optimized for clarity, correctness, and determinism. The pipeline is a single-issue, c...",""],
["./chapter-3_3-the-six-pipeline-s.html","Introduction &#62; Architecture Overview &#62; Chapter 3 - Pipeline Architecture &#62; 3.3 The Six Pipeline Stages","The pipeline consists of six fixed stages. Stages execute from oldest to youngest (WB → MEM → EX → IS → DE → IF) within each cycle.",""],
["./chapter-3_4-fetch-stage-(if).html","Introduction &#62; Architecture Overview &#62; Chapter 3 - Pipeline Architecture &#62; 3.4 Fetch Stage (IF)","Responsibilities  The Fetch stage is the pipeline entry point. It is responsible for: Consuming the pending FetchResult supplied by IBox (via...",""],
["./chapter-3_5-decode-stage-(id).html","Introduction &#62; Architecture Overview &#62; Chapter 3 - Pipeline Architecture &#62; 3.5 Decode Stage (ID)","Responsibilities  The Decode stage is intentionally minimal. The grain was already resolved during IBox fetch, so Decode performs validation ...",""],
["./chapter-3_6-issue-stage-(is).html","Introduction &#62; Architecture Overview &#62; Chapter 3 - Pipeline Architecture &#62; 3.6 Issue Stage (IS)","Responsibilities  The Issue stage performs hazard and readiness checks before an instruction enters the Execute stage: Source operand availab...",""],
["./chapter-3_7-execute-stage-(ex).html","Introduction &#62; Architecture Overview &#62; Chapter 3 - Pipeline Architecture &#62; 3.7 Execute Stage (EX)","Central Execution Principle  All architectural work happens in the Execute stage. This is the single most important pipeline invariant. The E...",""],
["./chapter-3_8-memory-stage-(mem).html","Introduction &#62; Architecture Overview &#62; Chapter 3 - Pipeline Architecture &#62; 3.8 Memory Stage (MEM)","Purpose  Despite its name, the MEM stage does not perform memory access. Memory access occurs in the EX stage via MBox. The MEM stage exists ...",""],
["./chapter-3_9-writeback-stage-(w.html","Introduction &#62; Architecture Overview &#62; Chapter 3 - Pipeline Architecture &#62; 3.9 Writeback Stage (WB)","Sole Commit Point  The Writeback stage is the sole architectural commit point. If an instruction reaches WB, it is guaranteed to be precise. ...",""],
["./chapter-4---functionexecution-.html","Introduction &#62; Architecture Overview &#62; Chapter 4 - Functional Execution Domains (\"Boxes)","4.1 Purpose of This Chapter  This chapter defines the Functional Execution Domains, commonly referred to as &#8220;Boxes&#8221;, used throughout the Alph...",""],
["./chapter-4_10-cross-box-interac.html","Introduction &#62; Architecture Overview &#62; Chapter 4 - Functional Execution Domains (\"Boxes) &#62; 4.10 Cross-Box Interaction Rules","To prevent architectural drift, the emulator enforces strict interaction rules. These rules are non-negotiable architectural invariants. Violating...",""],
["./chapter-4_11-summary.html","Introduction &#62; Architecture Overview &#62; Chapter 4 - Functional Execution Domains (\"Boxes) &#62; 4.11 Summary","Functional Execution Domains (\"Boxes\") provide a clean, scalable execution architecture that mirrors Alpha AXP design intent without rep...",""],
["./chapter-4_2-box-based-executio.html","Introduction &#62; Architecture Overview &#62; Chapter 4 - Functional Execution Domains (\"Boxes) &#62; 4.2 Box-Based Execution Model","4.2.1 Conceptual Model  In EMulatR, Boxes are not pipeline stages and not execution units in the scheduling sense. They are functional domain...",""],
["./chapter-4_3-relationship-betwe.html","Introduction &#62; Architecture Overview &#62; Chapter 4 - Functional Execution Domains (\"Boxes) &#62; 4.3 Execution Flow: Grains, Pipeline, and Boxes","4.3.1 Execution Flow Summary  Execution always follows this pattern: Instruction is decoded into a Grain by IBox (via GrainResolver) Grain en...",""],
["./chapter-4_4-ibox---instruction.html","Introduction &#62; Architecture Overview &#62; Chapter 4 - Functional Execution Domains (\"Boxes) &#62; 4.4 IBox - Instruction Box","The IBox is the front-end intelligence of the processor. It is responsible for instruction fetch and decode, and nothing else. Once a grain is pro...",""],
["./chapter-4_5-ebox---execution-b.html","Introduction &#62; Architecture Overview &#62; Chapter 4 - Functional Execution Domains (\"Boxes) &#62; 4.5 EBox - Execution Box (Integer Core)","The EBox implements integer and control-flow execution semantics. It performs computation, not coordination.",""],
["./chapter-4_6-fbox---floating-po.html","Introduction &#62; Architecture Overview &#62; Chapter 4 - Functional Execution Domains (\"Boxes) &#62; 4.6 FBox - Floating-Point Box","The FBox implements all floating-point execution semantics. It is the largest Box by code volume, reflecting the complexity of Alpha&#39;s multi-forma...",""],
["./chapter-4_7---mbox---memory-bo.html","Introduction &#62; Architecture Overview &#62; Chapter 4 - Functional Execution Domains (\"Boxes) &#62; 4.7 MBox - Memory Box","MBox implements memory access semantics, not memory ownership. GuestMemory owns the physical address space; MBox provides the execution-side inter...",""],
["./chapter-4_8---cbox---cache-_-c.html","Introduction &#62; Architecture Overview &#62; Chapter 4 - Functional Execution Domains (\"Boxes) &#62; 4.8 CBox - Cache / Coherency / Coordination Box","CBox governs global ordering and visibility. It is responsible for serialization and global coordination. CBox controls when forward progress may ...",""],
["./chapter-4_9-palbox---privilege.html","Introduction &#62; Architecture Overview &#62; Chapter 4 - Functional Execution Domains (\"Boxes) &#62; 4.9 PalBox - Privileged Architecture Library Box","PalBox implements the privileged boundary. PAL code is effectively firmware running inside the CPU — it executes within the normal pipeline but wi...",""],
["./chapter-5---memory-system-arch.html","Introduction &#62; Architecture Overview &#62; Chapter 5 - Memory System Architecture","5.1 Purpose of This Chapter  This chapter defines the memory architecture of the AlphaCPU emulator. It explains how memory is modeled, access...",""],
["./chapter-5_11-load-locked-_-sto.html","Introduction &#62; Architecture Overview &#62; Chapter 5 - Memory System Architecture &#62; 5.11 Load-Locked / Store-Conditional (LL/SC)","5.11.1 Reservation Model  LL/SC uses reservations, not mutexes. This is an optimistic concurrency mechanism: the load-locked instruction esta...",""],
["./chapter-5_12-memory-faults.html","Introduction &#62; Architecture Overview &#62; Chapter 5 - Memory System Architecture &#62; 5.12 Memory Faults","The memory system may generate the following fault types:",""],
["./chapter-5_13-interaction-with-.html","Introduction &#62; Architecture Overview &#62; Chapter 5 - Memory System Architecture &#62; 5.13 Interaction with Pipeline","The memory system interacts with the pipeline through well-defined contracts:",""],
["./chapter-5_14-smp-consideration.html","Introduction &#62; Architecture Overview &#62; Chapter 5 - Memory System Architecture &#62; 5.14 SMP Considerations","In EMulatR SMP systems: All CPUs share GuestMemory — one global instance, one backing store, one PA routing table Each CPU has independent write b...",""],
["./chapter-5_15-summary.html","Introduction &#62; Architecture Overview &#62; Chapter 5 - Memory System Architecture &#62; 5.15 Summary","The EMulatR memory architecture mirrors Alpha AXP behavior while remaining debuggable, testable, and extensible.",""],
["./chapter-5_2-design-philosophy.html","Introduction &#62; Architecture Overview &#62; Chapter 5 - Memory System Architecture &#62; 5.2 Design Philosophy","The Alpha AXP architecture is weakly ordered. The emulator preserves this property intentionally.",""],
["./chapter-5_3-memory-layers-over.html","Introduction &#62; Architecture Overview &#62; Chapter 5 - Memory System Architecture &#62; 5.3 Memory Layers Overview","The memory system is structured into distinct layers, each with a clear responsibility. No layer performs hidden work on behalf of another.",""],
["./chapter-5_4-virtual-addressing.html","Introduction &#62; Architecture Overview &#62; Chapter 5 - Memory System Architecture &#62; 5.4 Virtual Addressing and Translation","5.4.1 Virtual Address Space  All instructions operate on virtual addresses. The emulator models per-CPU ITB (Instruction TLB) and DTB (Data T...",""],
["./chapter-5_5-guestmemory---shar.html","Introduction &#62; Architecture Overview &#62; Chapter 5 - Memory System Architecture &#62; 5.5 GuestMemory - Shared Physical Memory","5.5.1 Definition  GuestMemory represents the entire physical address space visible to all CPUs. It is the conceptual memory system — the sing...",""],
["./chapter-5_6-safememory---phsyi.html","Introduction &#62; Architecture Overview &#62; Chapter 5 - Memory System Architecture &#62; 5.6 SafeMemory - Phsyical RAM Backend","5.6.1 Role  SafeMemory implements actual physical RAM storage. It is the \"dumb backend\" — intentionally simple, with no architectur...",""],
["./chapter-5_7-mmio-regions.html","Introduction &#62; Architecture Overview &#62; Chapter 5 - Memory System Architecture &#62; 5.7 MMIO Regions","5.7.1 Definition  MMIO regions map physical address ranges to devices, not RAM. The default MMIO region spans PA 0x10_0000_0000 – 0x20_0000_0...",""],
["./chapter-5_8-loads-and-stores.html","Introduction &#62; Architecture Overview &#62; Chapter 5 - Memory System Architecture &#62; 5.8 Loads and Stores","5.8.1 Load Semantics  Loads execute synchronously in the EX stage. MBox performs address calculation, alignment checking, VA→PA translation v...",""],
["./chapter-5_9-write-buffers.html","Introduction &#62; Architecture Overview &#62; Chapter 5 - Memory System Architecture &#62; 5.9 Write Buffers","5.9.1 Purpose  Write buffers exist to hide memory latency, improve pipeline throughput, and allow weak ordering. Each CPU has its own logical...",""],
["./chapter-6---serialization-and-.html","Introduction &#62; Architecture Overview &#62; Chapter 6 - Serialization and Stall Model","6.1 Purpose of This Chapter  This chapter defines how the AlphaCPU emulator enforces ordering, visibility, and completion in an otherwise wea...",""],
["./chapter-6_10---trapb---trap-ba.html","Introduction &#62; Architecture Overview &#62; Chapter 6 - Serialization and Stall Model &#62; 6.10 TRAPB - Trap Barrier","6.10.1 Semantics  TRAPB ensures precise arithmetic trap behavior. It guarantees that all arithmetic traps from prior instructions are resolve...",""],
["./chapter-6_11-call_pal-as-a-ser.html","Introduction &#62; Architecture Overview &#62; Chapter 6 - Serialization and Stall Model &#62; 6.11 CALL_PAL as a Serialization Point","6.11.1 PAL Transition Semantics  CALL_PAL transitions execution into privileged PAL mode. This transition must be serialized to prevent specu...",""],
["./chapter-6_12-interaction-with-.html","Introduction &#62; Architecture Overview &#62; Chapter 6 - Serialization and Stall Model &#62; 6.12 Interaction with LL/SC","Serialization interacts tightly with LL/SC reservations. Barriers and serialization events that clear reservations include:",""],
["./chapter-6_13-serialization-in-.html","Introduction &#62; Architecture Overview &#62; Chapter 6 - Serialization and Stall Model &#62; 6.13 Serialization in SMP Systems ","In EMulatR SMP configurations, serialization has cross-CPU implications:",""],
["./chapter-6_15-summary.html","Introduction &#62; Architecture Overview &#62; Chapter 6 - Serialization and Stall Model &#62; 6.14 Summary","The EMulatR serialization model preserves Alpha AXP&#39;s explicit ordering semantics while providing clear, debuggable barrier mechanics.",""],
["./chapter-6_2-weak-ordering-as-t.html","Introduction &#62; Architecture Overview &#62; Chapter 6 - Serialization and Stall Model &#62; 6.2 Weak Ordering as the Default","6.2.1 No Implicit Ordering  By default, the Alpha AXP memory model is weakly ordered. The emulator intentionally preserves this behavior: Loa...",""],
["./chapter-6_3-what-serialization.html","Introduction &#62; Architecture Overview &#62; Chapter 6 - Serialization and Stall Model &#62; 6.3 What Serialization Means","Serialization enforces global completion points in execution. A serialized point guarantees:",""],
["./chapter-6_4-classes-of-seriali.html","Introduction &#62; Architecture Overview &#62; Chapter 6 - Serialization and Stall Model &#62; 6.4 Classes of Serialization Instructions","Alpha defines several serialization primitives, each with a specific scope and distinct release conditions:",""],
["./chapter-6_5-pipeline-level-beh.html","Introduction &#62; Architecture Overview &#62; Chapter 6 - Serialization and Stall Model &#62; 6.5 Pipeline-Level Behavior","6.5.1 How Barriers Stall the Pipeline  When a barrier instruction reaches the Execute (EX) stage, its grain calls the appropriate CBox method...",""],
["./chapter-6_6-barrier-release-mo.html","Introduction &#62; Architecture Overview &#62; Chapter 6 - Serialization and Stall Model &#62; 6.6 Barrier Release Model","A stalled barrier is released only when its release conditions are satisfied. Barrier release is evaluated once per cycle by the pipeline.",""],
["./chapter-6_7-mb---full-memory-b.html","Introduction &#62; Architecture Overview &#62; Chapter 6 - Serialization and Stall Model &#62; 6.7 MB - Full Memory Barrier","6.7.1 Semantics  MB enforces global ordering of all memory operations. It guarantees that all prior loads complete, all prior stores are glob...",""],
["./chapter-6_8-wmb---write-memory.html","Introduction &#62; Architecture Overview &#62; Chapter 6 - Serialization and Stall Model &#62; 6.8 WMB - Write Memory Barrier","6.8.1 Semantics  WMB enforces ordering of stores only. It guarantees that all prior stores are globally visible and write buffers are drained...",""],
["./chapter-6_9-excb---exception-b.html","Introduction &#62; Architecture Overview &#62; Chapter 6 - Serialization and Stall Model &#62; 6.9 EXCB - Exception Barrier","6.9.1 Semantics  EXCB ensures precise exception state. It guarantees that all prior instructions are fully retired, all exception state regis...",""],
["./chapter-7---interrupt-and-ipi-.html","Introduction &#62; Architecture Overview &#62; Chapter 7 - Exceptions, Faults, and Interrupts","7.1 Purpose of This Chapter  This chapter defines how the AlphaCPU emulator detects, prioritizes, delivers, and resolves exceptions, faults, ...",""],
["./chapter-7_10-traps-and-trapb.html","Introduction &#62; Architecture Overview &#62; Chapter 7 - Exceptions, Faults, and Interrupts &#62; 7.11 Traps and TRAPB","Arithmetic traps are detected during execution but delivered after instruction retirement. This deferred delivery model means that without TRAPB, ...",""],
["./chapter-7_13-summary.html","Introduction &#62; Architecture Overview &#62; Chapter 7 - Exceptions, Faults, and Interrupts &#62; 7.13 Summary","The EMulatR exception system provides precise, deterministic exception handling that matches Alpha AXP architectural requirements.",""],
["./chapter-7_2-terminology-and-cl.html","Introduction &#62; Architecture Overview &#62; Chapter 7 - Exceptions, Faults, and Interrupts &#62; 7.2 Terminology and Classification","Alpha distinguishes multiple classes of exceptional events. The emulator models these distinctions explicitly through the PendingEventKind enumera...",""],
["./chapter-7_3-exception-detectio.html","Introduction &#62; Architecture Overview &#62; Chapter 7 - Exceptions, Faults, and Interrupts &#62; 7.3 ExceptionClass Classification","Beyond the high-level PendingEventKind, every event carries a fine-grained ExceptionClass_EV6 classification that determines the specific PAL vect...",""],
["./chapter-7_4-faultdispatcher.html","Introduction &#62; Architecture Overview &#62; Chapter 7 - Exceptions, Faults, and Interrupts &#62; 7.5 FaultDispatcher","7.5.1 Role  The FaultDispatcher is the central authority for managing exceptional events. There is one FaultDispatcher per CPU, accessed via ...",""],
["./chapter-7_5-priority-ordering.html","Introduction &#62; Architecture Overview &#62; Chapter 7 - Exceptions, Faults, and Interrupts &#62; 7.6 PendingEvent Structure","PendingEvent (PendingEvent_Refined.h, 420 lines) is the unified event structure for all exceptions, interrupts, and machine checks. It flows from ...",""],
["./chapter-7_6-precise-exception-.html","Introduction &#62; Architecture Overview &#62; Chapter 7 - Exceptions, Faults, and Interrupts &#62; 7.7 Priority Ordering","Alpha enforces strict priority ordering for exceptional events. Only one event may be delivered at a time. The FaultDispatcher resolves conflicts ...",""],
["./chapter-7_7-exception-delivery.html","Introduction &#62; Architecture Overview &#62; Chapter 7 - Exceptions, Faults, and Interrupts &#62; 7.8 Precise Exception Model","7.8.1 Guarantees  When an exception is delivered, the following guarantees hold: All prior instructions have completed — every instruction ol...",""],
["./chapter-7_8-pal-mode-entry.html","Introduction &#62; Architecture Overview &#62; Chapter 7 - Exceptions, Faults, and Interrupts &#62; 7.9 Exception Delivery and PAL Mode Entry","7.9.1 Delivery Conditions  An exception may be delivered when: no higher-priority event is pending, no barrier is blocking delivery, the pipe...",""],
["./chapter-7_9-interrupt-handling.html","Introduction &#62; Architecture Overview &#62; Chapter 7 - Exceptions, Faults, and Interrupts &#62; 7.10 Interrupt Handling","7.10.1 Interrupt Masking  Interrupt delivery depends on the current processor state. An interrupt is deliverable only when its IPL exceeds th...",""],
["./chapter-8---pal-and-privleged-.html","Introduction &#62; Architecture Overview &#62; Chapter 8 - PAL and Privileged Boundary","8.1 Purpose of This Chapter  This chapter defines the Privileged Architecture Library (PAL) boundary and explains how the AlphaCPU emulator e...",""],
["./chapter-8_10-enforcing-the-pri.html","Introduction &#62; Architecture Overview &#62; Chapter 8 - PAL and Privileged Boundary &#62; 8.10 Enforcing the Privileged Boundary","The privileged boundary in EMulatR is absolute. Execution state is either inside PAL mode or outside PAL mode — there is no intermediate state, no...",""],
["./chapter-8_11-pal-and-ll_sc.html","Introduction &#62; Architecture Overview &#62; Chapter 8 - PAL and Privileged Boundary &#62; 8.11 PAL and LL/SC Reservations","LL/SC operations must never span a privileged boundary. A reservation created in non-PAL execution cannot survive entry into PAL mode, exit from P...",""],
["./chapter-8_2-what-pal-is-(and-i.html","Introduction &#62; Architecture Overview &#62; Chapter 8 - PAL and Privileged Boundary &#62; 8.2 What PAL is (and is Not)","8.2.1 What PAL Is  PAL is a hardware-defined privileged execution mode. It is the sole authority for exception dispatch, interrupt dispatch, ...",""],
["./chapter-8_3-privilege-levels-i.html","Introduction &#62; Architecture Overview &#62; Chapter 8 - PAL and Privileged Boundary &#62; 8.3 Privilege Levels","Alpha defines multiple execution modes, modeled explicitly via the Current Mode (CM) field of the Processor Status (PS) register:",""],
["./chapter-8_4-call_pal---enterin.html","Introduction &#62; Architecture Overview &#62; Chapter 8 - PAL and Privileged Boundary &#62; 8.4 CALL_PAL - Entering the Privileged Boundary","8.4.1 CALL_PAL Instruction  CALL_PAL is the only architecturally valid entry point into PAL mode (aside from exception/interrupt vectors). It...",""],
["./chapter-8_5-pal-execution-mode.html","Introduction &#62; Architecture Overview &#62; Chapter 8 - PAL and Privileged Boundary &#62; 8.5 PAL Vector Dispatch","PAL entry vectors are computed differently for exceptions/interrupts (direct vectors) and CALL_PAL instructions (calculated offsets).",""],
["./chapter-8_6-pal-and-exceptions.html","Introduction &#62; Architecture Overview &#62; Chapter 8 - PAL and Privileged Boundary &#62; 8.6 PAL Execution Model","8.6.1 Execution Context  PAL code executes using the same instruction set and the same pipeline as normal code. It uses general-purpose regis...",""],
["./chapter-8_7-pal-and-interrupts.html","Introduction &#62; Architecture Overview &#62; Chapter 8 - PAL and Privileged Boundary &#62; 8.7 PAL and Exceptions/Interrupts","8.7.1 Exception Entry  All architecturally visible exceptions ultimately enter PAL. The delivery sequence: fault detected in EX → FaultDispat...",""],
["./chapter-8_8-pal-and-memory-ord.html","Introduction &#62; Architecture Overview &#62; Chapter 8 - PAL and Privileged Boundary &#62; 8.8 PAL and Memory Ordering","PAL code is implicitly serialized. Entry implies a full barrier (equivalent to MB + EXCB), exit implies a barrier. This ensures that exception han...",""],
["./chapter-8_9-hw_rei---exiting-p.html","Introduction &#62; Architecture Overview &#62; Chapter 8 - PAL and Privileged Boundary &#62; 8.9 HW_REI - Exiting PAL Mode","8.9.1 Purpose  HW_REI (Hardware Return from Exception/Interrupt) is the only architecturally legal exit from PAL mode. It restores processor ...",""],
["./chapter-9_2-smp-design-philoso.html","Introduction &#62; Architecture Overview &#62; Chapter 9 - SMP Architecture &#62; 9.2 SMP Design Philosophy","EMulatR follows five core SMP principles:  True symmetry — all CPUs are peers. There is no \"master\" CPU. Any CPU can boot, handle i...",""],
["./chapter-9_3-cpu-instantiation-.html","Introduction &#62; Architecture Overview &#62; Chapter 9 - SMP Architecture &#62; 9.3 CPU Instantiation and Identity","9.3.1 ExecutionCoordinator  CPUs are created and managed by the ExecutionCoordinator (ExecutionCoordinator.h, 416 lines). This is the central...",""],
["./chapter-9_4-per-cpu-vs-shared-.html","Introduction &#62; Architecture Overview &#62; Chapter 9 - SMP Architecture &#62; 9.4 Per-CPU vs Shared State","9.4.1 Per-CPU State  The following state is strictly per-CPU. No other CPU may directly mutate this state: Pipeline slots (AlphaPipeline stag...",""],
["./chapter-9_5-memory-visibility-.html","Introduction &#62; Architecture Overview &#62; Chapter 9 - SMP Architecture &#62; 9.5 Memory Visibility in SMP","9.5.1 Default Behavior  By default, stores may be buffered per-CPU (in WriteBufferManager), loads may observe stale values, and CPUs may see ...",""],
["./chapter-9_6-write-buffers-in-s.html","Introduction &#62; Architecture Overview &#62; Chapter 9 - SMP Architecture &#62; 9.6 Inter-Processor Interrupts (IPIs)","9.6.1 Purpose  IPIs are the primary SMP coordination mechanism. They are used for TLB shootdowns, cache invalidation coordination, memory bar...",""],
["./chapter-9_7-reservation-invali.html","Introduction &#62; Architecture Overview &#62; Chapter 9 - SMP Architecture &#62; 9.7 Memory Barrier Coordination","9.7.1 MemoryBarrierCoordinator  MemoryBarrierCoordinator (MemoryBarrierCoordinator.h, 278 lines) is a singleton that manages global memory ba...",""],
["./chapter-9_8-inter-processor-in.html","Introduction &#62; Architecture Overview &#62; Chapter 9 - SMP Architecture &#62; 9.8 TLB Shootdown","9.8.1 Why Shootdowns Are Required  When a CPU modifies page tables, other CPUs may have stale TLB entries mapping the old translations. Witho...",""],
["./chapter-9_9-tlb-shootdown.html","Introduction &#62; Architecture Overview &#62; Chapter 9 - SMP Architecture &#62; 9.9 Reservation Invalidation in SMP","LL/SC reservation correctness in SMP depends on the ReservationManager&#39;s global scanning behavior. When any CPU commits a store in WB stage, CBox ...",""],
["./chapter-style-guide-and-cross-.html","Chapter Style Guide and cross ref. Analysis.md","# EMulatR Documentation — Style Guide &#38;amp; Cross-Reference Analysis",""],
["./chapter9-smparchitecture.html","Introduction &#62; Architecture Overview &#62; Chapter 9 - SMP Architecture","9.1 Purpose of This Chapter  This chapter defines how EmulatR implements symmetric multiprocessing (SMP) while preserving Alpha AXP architect...",""],
["./check_circular_py-appendix.html","check_circular.py","Usage:      python check_circular_includes.py /path/to/project     python check_circular_includes.py /path/to/project --v...",""],
["./commands.html","Commands","# Edit ASAEmulatr.ini (add new disk, modify network settings)",""],
["./compiler-options.html","Compiler Options","AXP_DEBUG_ENABLED  AXP_WARN_ENABLED  AXP_TRACE_ENABLED  AXP_CRITICAL_ENABLED",""],
["./config.html","Config","Element Description",""],
["./controllers.html","Controllers","Element Description",""],
["./conventions.html","Conventions","SEXT SEXT(x) X is sign-extended to the required size. RIGHT_SHIFT(x,y) Logical right shift of first operand by the second operand. Y is an unsigne...",""],
["./core-processor-implementation.html","Core Processor Implementation","Enter topic text here.",""],
["./corelib.html","CoreLib","Function Description Usage  addQ Signed quadword addition with overflow tracking Integer execution, EBox  advancePC Advance PC by fixed ...",""],
["./cow-support-alphaspammanager.html","COW Support","Copy-on-Write (COW) is a memory management technique used to efficiently handle duplicate copies of memory pages. When a process forks, instead of...",""],
["./cpu.html","Cpu","Summary Table Pointer/RefPurposeOwnership RegisterBank*Integer registersAlphaCPU (per-vCPU) FpRegisterBank*FP registersAlphaCPU (per-vCPU) VectorR...",""],
["./cpucorelib.html","cpuCoreLib","Enter topic text here.",""],
["./cpustateiprinterface-taskable2.html","CPUStateIPRInterface taskables","Here’s the matching **System Side-Effect Checklist** for `CPUStateIPRInterface`, in the same style as the one we just did for `EV6_Hooks`.",""],
["./cpustateiprinterface-taskables.html","CPUStateIPRInterface-Taskables","CPUStateIPRInterface-Taskables Navigation: No topics above this level CPUStateIPRInterface-Taskables ",""],
["./cserve-environment-variable-im.html","CSERVE Environment Variable Implementation","ASAEmulatR CSERVE Environment Variable Implementation",""],
["./cserve-selector-table-based-on.html","CSERVE selector table based on SRM behavior","Enter topic text here.",""],
["./currentcputls.html","CurrentCpuTls","Returned Function Name Inferred Description void set(quint16 id) Sets the current CPU identifier in thread-local storage for the executing host th...",""],
["./debugging-sessoins.html","Debugging Sessoins","// PC and instruction pc                              // Current progra...",""],
["./debugging_-tracing_-and-valida.html","Debugging, Tracing, and Validation","Logging system  Trace hooks  Determinism guarantees  Invariant validation  Test strategy",""],
["./decodedinstruction.html","DecodedInstruction","// ============================================================================",""],
["./define_helpers.html","define_helpers","Returned Function / Macro Name Inferred Description void MEM_BARRIER Full memory fence ensuring sequential consistency across all threads. void ME...",""],
["./dependency-requirements.html","Dependency Requirements","Coverage Map    IRQController  ReservationManager  SafeMemory  MMIOManager  AlphaCPU  DeviceManager  Syste...",""],
["./device-subsystem.html","Device Subsystem","MMIOManager  DeviceManager  IRQ routing  DMA modeling  Specific device implementations",""],
["./devicemanagerdependency.html","DeviceManager","DMA Coherence DEV-REQ-001: Any DMA write must call SafeMemory → ReservationManager. DEV-REQ-002: Devices must NOT bypass SafeMemory unless they ex...",""],
["./directory-structure.html","Directory Structure","**DIRECTORY STRUCTURE:** ``` bin/ ├── debug/ │   ├── emulator.exe          ← Executable │   ├── config/ │ &#38;nbsp...",""],
["./discussions.html","Discussions","Enter topic text here.",""],
["./dual-issue-hazard-scoreboard.html","Dual Issue Hazard","Case Dual Issue:  Slot(2): A Slot(3): B  Case: A and B both write the same register (WAW across pair)  A: ADDQ R1, R2, R3 B: SUBQ R...",""],
["./dumpbin.html","DumpBin","Z:\\EmulatR\\x64\\Debug&#62;dumpbin /exports Z:\\EmulatR\\x64\\Debug\\CoreLib.lib",""],
["./ebox.html","EBox","Integer Instruction Grains Processing.  Responsible for all integer operations (grain Op/Func), and local Int Register Bank.  Grain Exec...",""],
["./emulatormanger-app.html","EmulatorManger App","Critical Initialization Order:   1. globalSettings().loadFromConfig(json); 2. globalIPRBank().init(numCpus); 3. globalHWPCBBank().init(numCpu...",""],
["./emulatr-initialization-.html","EmulatR Initialization ","# EmulatR Initialization Architecture  **Version:** 1.0   **Date:** December 2025   **Pattern:** QScopedPointer + Meyer&#39;s Singleton...",""],
["./emulatr-logging.html","EmulatR Logging","# ASA Emulator Logging System  **Version:** 2.0   **Date:** December 2025   **Architecture:** Queue-based async logging with multip...",""],
["./endianness-rules.html","Endianness Rules","Alpha is ALWAYS little-endian. There is no big-endian mode. Any big-endian data must be explicitly byte-swapped by software.",""],
["./ev4.html","EV4","Element Description",""],
["./ev5.html","EV5","Element Description",""],
["./ev6.html","EV6","Constr Mnuemonic BOX Decimal ScoreBoard Bit Access MT/MF Issued from Pipe   #define ITB_TAG0; ITB_TAG I 0 6 WO 0L   #define ITB_PTE1; IT...",""],
["./ev6ptecache.html","Ev6PteCache","How EV6 uses two DTB banks (&#8220;Pipe 0&#8221; and &#8220;Pipe 1&#8221;)",""],
["./ev6_hooks_taskables.html","EV6_Hooks_Taskables","Absolutely — here is a **fully structured, facility-level system-side-effect checklist** for **EV6_Hooks**, matching the exact format you approved...",""],
["./exception--faults.html","Exception &#38; Faults","instructions implement a FP exception latch layer.",""],
["./exception-handling-fbox.html","Exception handling","Exceptions generated by the Fbox are recorded in two places:",""],
["./exceptionfactory_inl.html","ExceptionFactory_inl","Function Description Usage PendingEvent makeITBMissEvent @brief Create ITB miss event  * @param cpuId CPU that raised exception  * @para...",""],
["./exceptionlib.html","ExceptionLib","ExceptionLib Navigation: No topics above this level ExceptionLib ",""],
["./exceptionmapping_inl.html","ExceptionMapping_inl","SINGLE SOURCE OF TRUTH for ExceptionClass -&#62; PalVectorId resolution.",""],
["./exceptionpreparation_inl.html","ExceptionPreparation_inl","Returns Function Description / Usage void preparePendingEventForDelivery Prepare pending event for delivery to PAL This is the SINGLE preparation ...",""],
["./exceptions.html","Exceptions Vector Map","Header:  crtLib::PAL_Vector_Controller.h     PalVectorid Offset Description Side effects RESET 0X0000   MCHK 0X0080 Machine ch...",""],
["./exceptionstateupdate_inl.html","ExceptionStateUpdate_inl","Returns Function Description / Usage void updateExceptionSummary Update EXC_SUM register based on exception type EXC_SUM encodes exception-specifi...",""],
["./exc_sum_helpers.html","EXC_SUM_helpers","Returns Function Inferred Usage bool excSumHasSWC Test EXC_SUM for Software Completion Possible (SWC) arithmetic-trap bit bool excSumHasINV Test E...",""],
["./executeexcb-barriers.html","executeEXCB","// ============================================================================",""],
["./executewmb-barriers.html","executeMB_WMB","// ============================================================================",""],
["./export-symbols-appendix.html","Export Symbols","===============================================================================",""],
["./fbox.html","FBox","Integer Instruction Grains Processing.  Responsible for all Floating-Point operations (grain Op/Func), and local FP Register Bank.  Grai...",""],
["./flow-chart-runloop.html","Flow-Chart-RunLoop","================================================================================",""],
["./fpcr-fbox-registers.html","FPCR ","Name Offset Implementation",""],
["./function-flow-branchpredition.html","Function Flow ","Predictive Fetch (IBox)  IBox.fetchNext():     pc = ctx.getPC()     predictedTaken = cbox.predictBranch_IBox(pc, disp) &#38;n...",""],
["./generate_all_grains_py-appendix.html","generate_all_grains.py","Script Command Line: py generate_all_grains.py Z:\\EmulatRAppUni\\grainFactoryLib\\GrainMaster.tsv Z:\\EmulatRAppUni",""],
["./generate_cmakelists_py-appendix.html","generate_cmakelists.py","Command Line: py generate_cmakelists.py Z:\\EmulatRAppUni\\",""],
["./ghwpcbbank_globalstatics.html","globalHWPCBManager)","inline HwpcbManager&#38; globalHwpcbManager() {     static HwpcbManager instance;     return instance; }    Host the...",""],
["./giprbank-(iprbank)_qglobalstatics.html","globalIprRegistry)","inline IprDescriptorRegistry&#38; globalIprRegistry();",""],
["./girqcontroller_qglobalstatics.html","globalIRQController)","Interrupt Controller (IPL arbitrator and delivery). ",""],
["./globalev6ptecache.html","globalEv6PteCache","Implementation:  Put the SPAMManager singleton into Layer 0 (silicon). ✔ Initialize it once at emulator boot through a static initialize() me...",""],
["./globalipr_hot_cold.html","globalIPR_hot_cold","Returned Type Function Name Inferred Description IPRStorage_Hot&#38; Reference globalIPRHot Returns a reference to the per-CPU hot IPR storage use...",""],
["./globalreservationmanager.html","globalReservationManager","inline ReservationManager&#38; globalReservationManager()",""],
["./global_emulatorsettings.html","Global_EmulatorSettings","1. Load config (once): Global_EmulatorSettings().loadFromIni(\"emulator.ini\");  2. Access anywhere: int mem = Global_EmulatorSetting...",""],
["./global_hwpcbbank_interface.html","Global_HWPCBBank_Interface","Returned Function Name Inferred Description HWPCBBank HWPCBBank(CPUIdType cpuCnt) Constructs a per-CPU HWPCB bank with multiple context slots per ...",""],
["./grain-routing---pal.html","Grain Routing - PAL","Key architectural rule (reinforced) ----------------------------------- - PAL grains should NOT force a return to User mode on exit. - PAL-mode is...",""],
["./grainmaster_tsv-appendix.html","Introduction &#62; Appendix &#62; Appendix D – Instruction Inventory (GrainMaster.tsv) &#62; GrainMaster.tsv","OpcodeFunctionMnemonicDescriptionTypeBox 0x000x0000CALL_PALCALL_PALPALcodePalBox 0x000x0000HALTHALTPALcodePalBox 0x000x0001RESTARTRESTARTPALcodePa...",""],
["./grains_.html","Grains","Lock-free with versioning! This is production-grade:",""],
["./guestmemory-srm-integration.html","GuestMemory SRM Integration","# GuestMemory SRM Integration - Complete Guide  ## Summary  You asked how to add **SRM as a routing target** in your existing GuestMemor...",""],
["./helper-functions.html","Helper Functions","Helper Location AccessMasks (RE: WR: EX) - hasPermission - canUserRead/Write/Exec - canKernelRead/Write genlib::define_static_const.h quint8 - Bit...",""],
["./hwpcb-.html","Hardware Privileged Context Block (HWPCB)","HWPCB (Hardware Privileged Context Block) - Field List",""],
["./hwpcb_taskables.html","HWPCB_Taskables","Absolutely — let me give you a clear, correct answer **without needing a file search**, because your question is conceptual and the code context i...",""],
["./i-cache-cache.html","I-Cache","Primary Responsibility.  Rules. Only I-cache invalidation events should clear predictor state.   Handles.",""],
["./ibox.html","IBox","IBox performs decode + issue, NOT execution  Dispatches instruction grain units to the associated BOX; does not &#8220;schedule&#8221; globally.  Br...",""],
["./implementation-alpha_spam_manager.html","Implementation","# TLB Integration To-Do List  CPUStateIPRInterface.h - [x] Add per-CPU pointers to ITB and DTB managers (`itbManager` and `dtbManager`) - [x]...",""],
["./implementation.html","Implementation","Got it, thanks for the correction – I’ll ignore the &#8220;coreLib&#8221; idea for SCSI and lay out a clean header structure and placement for everything SCSI...",""],
["./integration-steps.html","Integration Steps","Phase 0 – Freeze the new &#8220;truths&#8221;  Before touching call-sites, treat these as the canonical interfaces:  Pipeline &#38; slots – AlphaPip...",""],
["./interrupt---methodology--conve.html","Interrupt - Methodology &#38; Convention","IPR-ORDER-OF-OPERATIONS.TXT  (ASCII)  ## Goal  Define a concrete, stepwise \"state transition script\" for an EV6 (21264) i...",""],
["./interrupts-_-ipl-and-ast.html","Interrupts / IPL and AST","Enter topic text here.",""],
["./introduction.html","Introduction","Alpha AXP System Architecture Emulator  EMulatR is a high-fidelity architectural emulator of the DEC Alpha AXP processor family. It is design...",""],
["./ipi---inter-processor-interrup.html","IPI - Inter Processor Interrupt Handling","CPU 0 executes MTPR IPIR (target=CPU 1)     ↓ 1. Queue IPI message in CPU 1&#39;s IPIQueue 2. Request interrupt via IRQ controller at IPI_IP...",""],
["./ipr-cache-optimization---quick.html","IPR Cache Optimization - Quick Reference","Architecture Overview  ┌─────────────────────────────────────────────────────────────┐ │  PerCpuIPRState (per CPU, cache-line isolated) ...",""],
["./ipr-hive.html","IPR Hive","Internal Processor Register - Relevance Classification.",""],
["./ipr-storage.html","IPR Storage","IPR Storage Navigation: No topics above this level IPR Storage ",""],
["./ipr.html","IPR","Element Description",""],
["./iprstorage.html","IPRStorage","ReservationManager Trap / Exception / AST / Mode change ReservationManager IPR writes that alter process context  Examples: MTPR PTBR MTPR AS...",""],
["./iprstorage_ibox.html","IprStorage_IBox","Returned Function Name Inferred Description quint16 ICtlRegister::vptb_sext() Returns the sign-extension bits for the virtual page table base (VPT...",""],
["./ipr_getactivesp_inl.html","Ipr_getActiveSP_inl","Returned Function Name Inferred Description quint64 getActiveSP Returns the currently active stack pointer (SP) for the calling CPU based on the a...",""],
["./ipr_ic_flush_inl.html","IPR_IC_FLUSH_inl","Returned Function Name Inferred Description void writeIPR_ICTL Handles writes to the I_CTL IPR: masks read-only fields, preserves architectural bi...",""],
["./irqcontroller-controllers.html","IRQController","# IRQController Integration Guide  **Version:** 1.0   **Date:** December 2025   **Author:** Timothy Peer / eNVy Systems, Inc. &#38;nbsp...",""],
["./irqcontrollerdependencies.html","IRQController","IRQ Routing Requirements IRQ-REQ-001: Provide per-vector routing policy (FIXED_CPU, ROUND_ROBIN, LOWEST_IPL, BROADCAST). IRQ-REQ-002: Store per-ve...",""],
["./keep.html","Keep","Enter topic text here.",""],
["./lifecycle-grain.html","Lifecycle ","A characterization aligned with EV6/ASA semantics and the current EmulatR design.",""],
["./load---silos-.html","Load - Silos ","The Abox contains a memory reference pipeline that can accept a new load or store instruction every cycle until a Dcache fill is required. Since t...",""],
["./logging.html","Logging","┌────────────────────────── LogReader Application ─────────────────────────┐",""],
["./makearithmeticfaultinfo_inl.html","makeArithmeticFaultInfo_inl","Returned Function Name Inferred Description MemoryFaultInfo makeArithmeticFaultInfo Constructs and returns a fully populated MemoryFaultInfo struc...",""],
["./managers.html","Managers","Element Description",""],
["./mbox.html","MBox","Below is a **clean, grain-scoped specification** for **MBox responsibilities**, deliberately restricted to **what instruction grains executed in t...",""],
["./memory--synchronization-intern.html","Memory &#38; Synchronization Internals","SafeMemory internals  GuestMemory routing  ReservationManager  Cache &#38; coherency modeling",""],
["./memory-mapvisual.html","Memory MapVisual","# CANONICAL PA ROUTING TABLE (Option A) # ASA Emulator - Single Source of Truth for Physical Address Mapping # Date: 2025-01-27  ## DESIGN PR...",""],
["./minimal-pal-checklist.html","Minimal Pal checklist","Excellent instinct — this is exactly the *right* pivot point.",""],
["./mmio.html","MMIO","Element Description",""],
["./mmiomanagerdependency.html","MMIOManager","MMIO Writes MMIO-REQ-001: Device register writes do not break reservations. MMIO-REQ-002: Device DMA writes into RAM must call ReservationManager ...",""],
["./mplatedefault-modified2026-02-.html","Introduction &#62; Architecture Overview &#62; Chapter 16 – Device Model &#38; DMA &#62; 16.10 Device Registration and Template System","16.10.1 DeviceCatalog  DeviceCatalog (mmio_DeviceCatalog.h, ~130 lines) is the template database for all device types. It stores DeviceTempla...",""],
["./next-steps-to-srm-.html","Next Steps to SRM &#62;&#62;&#62;","You’re exactly right: at this point, what’s missing is **not more architecture prose**, but a **concrete, deterministic operational sequence** tha...",""],
["./next-steps.html","Next Steps","You’re feeling exactly the *right* thing right now �� — and this is actually a **very good sign**.",""],
["./oniplchanged_inl.html","onIPLChanged_inl","Returned Function Name Inferred Description void onIPLChanged Notifies the global IRQ controller that a CPU’s Interrupt Priority Level (IPL) has c...",""],
["./osf.html","OSF","Element Description",""],
["./pagetable(pte)subsystem.html","SPAM - (Set Prediction and Access Memory) Subsystem","Overview  Update:   Because the SPAM/TLB subsystem acts like a 4-D associative array: CPU Realm SizeClass BucketIndex  -------- The...",""],
["./pal-exception-vectoring.html","PAL Exception Vectoring","// ============================================================================",""],
["./pal-module.html","PAL Module","COW is triggered by a write-fault → PAL → kernel trap handler",""],
["./pal-vector-table-(gpalvectorta.html","globalPalVectorTable))","PAL vector layout is static architecture data:  Vector index → handler function / grain / metadata.  All CPUs share the same PAL table; ...",""],
["./pal.html","PAL","PAL executes in MBox  PALcode does things such as:  Change privileged registers (IPRs)  Manipulate the HWPCB (context block)  ...",""],
["./pctx_helpers.html","PCTX_helpers","Function / Helper Name Inferred Description decodePCTX_ASN Extracts the Address Space Number (ASN) field from a raw PCTX value decodePCTX_ASTER Ex...",""],
["./permissions--va-translation.html","Permissions &#38; VA Translation","CATEGORY: Memory Policy STABILITY: Architectural (High) CONSUMERS: MMU, TLB, ACV, PAL  Reference: permissions_helper_inl",""],
["./permissions_helper_inl.html","permissions_helper_inl","Function Name Inferred Description pageShift Returns the bit shift corresponding to an Alpha page size code (used to compute page alignment and in...",""],
["./platform.html","Platform","Element Description",""],
["./processor-status-(ps)-helpers.html","Processor Status (PS) Helpers","Processor Status (PS) Helpers  Architectural Inference Summary  Layer: Core / Architectural State Stability: Architectural (High) Scope:...",""],
["./ps_helpers_inl.html","PS_helpers_inl","Function Returns Description extractIPLFromPS quint8 Extracts the Interrupt Priority Level (IPL) field from PS insertIPLIntoPS quint64 Inserts a n...",""],
["./pte.html","PTE","# SMP-Coherent PTE Interface - Integration Guide  ## Overview  This interface provides **per-CPU SPAM caches** with **SMP coherence** fo...",""],
["./pte_core.html","pte_core","Purpose: Low-level, header-only utilities used by the Alpha AXP MMU, TLB, and page table subsystems. Designed to be constexpr-friendly, pipeline-a...",""],
["./pupose-of-this-chapterchapter2.html","Introduction &#62; Architecture Overview &#62; Chapter 3 - Pipeline Architecture &#62; 3.1 Pupose of this Chapter","This chapter defines the structure, responsibilities, and invariants of the AlphaPipeline in EMulatR. It explains how instructions flow through th...",""],
["./purpose-and-audiencechapter1.html","Introduction &#62; Architecture Overview &#62; Chapter 1 - System Overview &#62; 1.1 Purpose and Audience","This chapter provides a top-level architectural description of the EMulatR Alpha AXP emulator. It defines the major subsystems, their responsibili...",""],
["./python-scripts.html","Python Scripts","Enter topic text here.",""],
["./qglobalstatics_appendix.html","Meyer&#39;s Singleton","Global Statics Description globalHWPCBManager  globalIprRegistry  globalPalVectorTable  globalIRQController  globalReservation...",""],
["./qtrandomcompat.html","QtRandomCompat","Determinism Note:  Uses host-provided randomness (Qt RNG or qrand). Results are not replay-safe unless externally seeded or overridden. Any s...",""],
["./r31-profiling.html","R31 Profiling","// ============================================================================",""],
["./r31-usage.html","R31 Usage","R31_USAGE_AND_WRITEBACK_SPEC.txt - (ASCII, UTF-8 noBOM)",""],
["./raw-hazard---load-followed-alu.html","RAW Hazard - Load Followed ALU","Load followed by dependent ALU  Scenario:  A: LDQ R1, 0(R2) B: ADDQ R3, R1, R4 (B needs R1 written by A)  Goal: B must not read R1 ...",""],
["./registers-ebox.html","Registers","Name  Offsets Implementation CC   CC_CTL   VA_FORM   VA_CTL   VA",""],
["./registers-fbox.html","Registers","Registers Navigation: No topics above this level Registers ",""],
["./registers-ibox.html","Registers","Name  Offsets Implementation EXC_SUM // EXC_SUM Register Layout (EV6): // Bits [63:48] - SEXT(SET_IOV)  Sign extension of SET_IOV bit //...",""],
["./registers-mbox.html","Registers","Name Offset Implementation DTB_TAG0   DTB_TAG1   DTB_PTE0   DTB_PTE1   DTB_ALTMODE   DTB_IAP   DTB_IA   MM_STAT...",""],
["./registers.html","Registers","CBox operations participate in the architectural order of operations as serialized, atomic control commits; the MSB-first 6-bit shifting is purely...",""],
["./reservationmanager-appendix.html","ReservationManager","Internal Operations (performed by ReservationManager)",""],
["./reservationmanager.html","ReservationManager","Keyword Description Consumed By ReservationManager Central LL/SC reservation controller AlphaCPU, SafeMemory, PAL handlers Reservation Per-CPU res...",""],
["./reservationmanagerdependency.html","ReservationManager","Structural Requirements RM-REQ-001: Provide per-CPU reservation tracking for LL/SC instructions. RM-REQ-002:  Track the reserved physical add...",""],
["./resolution-interface.html","Branch Resolution","Called From:  Alpha PipeLine  Consumed by:  BranchResolutionResult resolveBranch(     quint64 pc,     bool predicted...",""],
["./run-loop-nested-stack.html","Run Loop Nested Stack","=============================================================================",""],
["./run-loop.html","Run Loop","Fault &#38; PAL Responsibility  FaultDispatcher   └── detects conditions   └── builds PendingEvent   └── exposes PendingEvent ...",""],
["./safememory---ram.html","SafeMemory - RAM","1. Scope and Responsibilities  **SafeMemory’s role**  * Provide a **safe, bounded, byte-addressable backing store** for guest *physical*...",""],
["./safememorydependency.html","SafeMemory","Coherence with ReservationManager SM-REQ-001: On any physical write to RAM, SafeMemory must call resConflictWrite(). SM-REQ-002: Device-backed mem...",""],
["./scoreboard-hazards.html","ScoreBoard Hazards","The scoreboard’s purpose is to detect instruction hazards:",""],
["./scsi.html","SCSI","Element Description                   deviceLib/     ISCSIDevice.h     SCSIDisk.h...",""],
["./shard-scaffolding-ownership.html","Shard Scaffolding Ownership","Class Ownership and Invalidation Coordination in SMP",""],
["./sharding-mechanism---pte---spa.html","Sharding Mechanism - PTE - SPAMShardManager","What is Sharding? ----------------- Sharding is the process of partitioning a large set of cache (TLB/PTE) entries into smaller, semi-independent ...",""],
["./spam---policies.html","Cache Replacement and Invalidation Policies","Overview -------- The cache replacement and invalidation policies are critical components of the PTE subsystem&#39;s cache management strategy. These ...",""],
["./spam-shard-support.html","SPAM Shard Support","You’re very welcome �� And nice, this is exactly the right point to carve in the layering and stop letting templates leak all over the place.",""],
["./specation-pipeline.html","Specation ","===============================================================================",""],
["./srm-load.html","SRM load","╔══════════════════════════════════════════════════════════════════╗",""],
["./stall-conditions.html","Stall Conditions","Q3: \"Two cases for stalling: Fault handling and pipeline stall (PalMode)\"",""],
["./systems-integration.html","Systems Integration","Integrate via EmulatR  SYS-REQ-001: EmulatorManager MUST construct and own: ReservationManager, IRQController, SafeMemory, MMIOManager SYS-RE...",""],
["./taskables.html","Taskables","Enter topic text here.",""],
["./tier.html","Tier","Element Description",""],
["./todo-palvectoring.html","TODO-PalVectoring","SRM_BOOTSTRAP_READINESS_AUDIT.txt ASCII / UTF-8 (no BOM)  ================================================================================ Qu...",""],
["./tracehelpers.html","TraceHelpers","FunctionName InferredDescription logTrace(QString) Emit a TRACE-level diagnostic message using QString without allocation ambiguity logTrace(std::...",""],
["./trait---ctor-usage-examples.html","Trait - CTOR Usage Examples","Passing SPAMShardManager With Traits to Dependent Class Constructors",""],
["./trait-examples.html","Alpha PTE Traits Usage Guide","Overview -------- The Alpha PTE subsystem uses *traits* to adapt the canonical AlphaPTE format to the specific page table layouts and access patte...",""],
["./translation-buffer.html","Translation Buffer","L0 (silicon / SPAMShardManager) should never know how to walk page tables.",""],
["./types_core.html","types_core","Alpha EV6 Core Types — Canonical Type Table Type Name Data Type Description ASNType quint16 Address Space Number (EV6 uses 8-bit ASNs; stored wide...",""],
["./uat.html","UAT","Element Description",""],
["./unit-test-scaffold.html","Unit Test Scaffold","Data Types Test Box SubProject IEEE T_floating MBox",""],
["./usage-and-integrationlogging.html","Usage and Integration","# EMulatR Logging System - Complete Implementation",""],
["./vms.html","VMS","Element Description",""],
["./waw-check-scoreboarding.html","WAW Hazard - Two writers to the same register","Two writers to the same register  Scenario:  A: ADDQ R1, R2, R3 B: SUBQ R4, R5, R1 (B also writes R1)  You don’t want B to issue wh...",""]];
