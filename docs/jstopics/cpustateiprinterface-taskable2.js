hmLoadTopic({
hmKeywords:"",
hmTitle:"CPUStateIPRInterface taskables",
hmDescription:"Here’s the matching **System Side-Effect Checklist** for `CPUStateIPRInterface`, in the same style as the one we just did for `EV6_Hooks`.",
hmPrevLink:"",
hmNextLink:"",
hmParentLink:"appendix---trait-examples.html",
hmBreadCrumbs:"",
hmTitlePath:"Introduction > Appendix > Appendix I – Global Singletons",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">CPUStateIPRInterface taskables<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">Here’s the matching **System Side-Effect Checklist** for `CPUStateIPRInterface`, in the same style as the one we just did for `EV6_Hooks`.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You can paste this straight into your docs and then refine it as we flesh the class out.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## System Side-Effect Checklist (SSEC)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> Facility: `CPUStateIPRInterface`<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"># Purpose<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">`CPUStateIPRInterface` is the **per-CPU façade** that:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Provides structured access to `IPRBank` and `HWPCBBank` for a given `cpuId`.<\/p>\n\r<p class=\"p_Normal\">* Tracks **current mode**, **PAL mode**, and **interrupt \/ AST eligibility**.<\/p>\n\r<p class=\"p_Normal\">* Mediates **IPR read\/write side effects** for EV6 (via `EV6_Hooks`).<\/p>\n\r<p class=\"p_Normal\">* Coordinates with:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `IRQController` (IPL, IER, AST eligibility)<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `ReservationManager` (clearing reservations on traps\/mode changes)<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `HWPCBBank` (context save\/restore)<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `Ev6PteCache` (via access permission checks)<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `GlobalSettings` (optional config, e.g. FEN \/ access rules)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">It doesn’t own global state; it’s a **per-CPU view** over `IPRStorage_core` + `HWPCB_core`.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## A. Internal Operations (performed by `CPUStateIPRInterface`)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">These are operations the interface itself is responsible for, per CPU:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">| Step | Operation &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Description &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Must Trigger &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| ---- | ---------------------------------------------------- | ------------------------------------------------------ | ------------------------------------------------- |<\/p>\n\r<p class=\"p_Normal\">| A1 &nbsp; | `state()` \/ `state() const` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Returns reference to `IPRStorage` for `m_cpuId` &nbsp; &nbsp; &nbsp; &nbsp;| Underpins all IPR read\/write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| A2 &nbsp; | `cpuId()` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Returns logical CPU index &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Used by all downstream modules &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| A3 &nbsp; | `isInPalMode()` \/ `enterPalMode()` \/ `exitPalMode()` | Tracks PAL mode state for this CPU &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Influences access checks, traps, PS semantics &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| A4 &nbsp; | `currentMode()` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Returns current CM (K\/E\/S\/U) from IPR storage &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Used by access checks &amp; hooks &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| A5 &nbsp; | `savetoPCB()` \/ `restoreFromPCB()` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Calls `HWPCBBank::context_save\/restore` for this CPU &nbsp; | Context switch behavior &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| A6 &nbsp; | `checkAccess(va, intent, permMask)` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Performs VA+intent+mode permission check (via helper) &nbsp;| AccessResult: Allowed \/ Fault_xxx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| A7 &nbsp; | `logIPRWrite(name, oldValue, newValue)` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Debug\/logging for IPR writes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Optional tracing &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| A8 &nbsp; | `logIPRRead(name, value)` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Debug\/logging for IPR reads &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Optional tracing &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| A9 &nbsp; | `fenEnabled()` (present or to be added) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Queries FEN \/ FP enable state &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Used for FP access checks &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| A10 &nbsp;| AST fields (pending\/enabled masks, etc.) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Tracks per-CPU AST state (masks for ASTRR\/ASTER\/ASTEN) | Used by AST helpers below &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| A11 &nbsp;| `onModeChange(...)` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Reacts to CM changes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Updates internal mode + triggers downstream hooks |<\/p>\n\r<p class=\"p_Normal\">| A12 &nbsp;| `interruptEligibilityDirty()` flag (if present) &nbsp; &nbsp; &nbsp;| Tracks whether IRQ eligibility must be recomputed &nbsp; &nbsp; &nbsp;| Used by AlphaCPU\/IRQ paths &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You already have partial versions of some (e.g. `state()`, PAL mode bits, PCB save\/restore, `checkAccess` wrapper); the rest we stub.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## B. External Events Affecting `CPUStateIPRInterface`<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">These are events from other subsystems that **drive** this interface:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">| Step | External Source &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Event &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Expected Response in `CPUStateIPRInterface` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| ---- | ---------------------------------------------------- | --------------------------------------------- | -------------------------------------------------------------------------------------------------------- |<\/p>\n\r<p class=\"p_Normal\">| B1 &nbsp; | `EV6_Hooks::onCM_Write` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| CM (Current Mode) write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Call `onModeChange(oldCM, newCM)` and update internal CM &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| B2 &nbsp; | `EV6_Hooks::onPCTX_ASTERWrite` \/ `onPCTX_ASTRRWrite` | AST enable \/ request writes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Update AST masks (`ASTER`, `ASTEN`, `ASTRR`) and recompute AST pending &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| B3 &nbsp; | `EV6_Hooks::onEXC_ADDR_Write` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Exception address change &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Update EXC_ADDR in IPR, call `updateExceptionState()` and `notifyExceptionAddressChanged()` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| B4 &nbsp; | `EV6_Hooks::onEXC_SUM_Write` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Exception summary update &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Call `evaluateExceptionSummary()`, and possibly `triggerMachineCheck()` \/ `generateExceptionInterrupt()` |<\/p>\n\r<p class=\"p_Normal\">| B5 &nbsp; | `EV6_Hooks::onSIRRWrite` \/ `onIER_Write` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Software interrupt \/ interrupt enable changes | Mark interrupt eligibility dirty (`notifyModeChangeAffectsInterruptEligibility()` \/ similar) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| B6 &nbsp; | PAL executor \/ AlphaCPU &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Trap \/ exception entry\/exit &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Clear reservations, update PS, CM, EXC_ADDR\/EXC_SUM via IPR writes that go through this interface &nbsp; &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| B7 &nbsp; | `GlobalSettings` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Changes in security or debug flags &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| May modify behavior of `checkAccess()` or logging &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## C. Downstream Effects (side effects caused by `CPUStateIPRInterface`)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">These are **calls out to other subsystems** that CSII is expected to perform when certain events happen.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&gt; Many of these are the functions we said should exist as stubs; this table tells you where they go.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> C1. Mode &amp; PAL related<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">| Step | Called Subsystem &nbsp; &nbsp; &nbsp;| Condition &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Must Call &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| ---- | --------------------- | -------------------------------------------- | --------------------------------------------------------------------------------------------------- |<\/p>\n\r<p class=\"p_Normal\">| C1.1 | `IRQController` &nbsp; &nbsp; &nbsp; | IPL \/ mode changed, affects IRQ eligibility &nbsp;| e.g. `recalculateInterruptPriorities(cpuId, ierMask)` (triggered from `onModeChange` or IER writes) |<\/p>\n\r<p class=\"p_Normal\">| C1.2 | `ReservationManager` &nbsp;| Mode change, trap, REI, certain EXC_SUM bits | `ReservationManager::instance().clearReservation(cpuId)` from inside CSII helper &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| C1.3 | `AlphaCPU` (indirect) | Mode change affects instruction fetch &nbsp; &nbsp; &nbsp; &nbsp;| Possibly triggers `flushSpeculativeState()` to discard spec state &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> C2. AST related<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">| Step | Called Subsystem | Condition &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Must Call &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| ---- | ---------------- | -------------------------------- | --------------------------------------------- |<\/p>\n\r<p class=\"p_Normal\">| C2.1 | `IRQController` &nbsp;| AST pending &amp; eligible &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Request “soft interrupt” or use AST vector &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| C2.2 | `HWPCBBank` &nbsp; &nbsp; &nbsp;| AST state must be saved\/restored | Wrap AST fields in HWPCB context_save\/restore |<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> C3. Exception \/ trap related<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">| Step | Called Subsystem &nbsp; &nbsp; &nbsp;| Condition &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Must Call &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| ---- | --------------------- | ------------------------------------------------- | ----------------------------------------------------------------- |<\/p>\n\r<p class=\"p_Normal\">| C3.1 | `IPRBank` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | EXC_ADDR\/EXC_SUM written &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Update underlying IPR storage &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| C3.2 | `IRQController` \/ PAL | Severe EXC_SUM (e.g. machine check) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | `triggerMachineCheck()` → which in turn arranges SCB vector, etc. |<\/p>\n\r<p class=\"p_Normal\">| C3.3 | `AlphaCPU` \/ PAL &nbsp; &nbsp; &nbsp;| Certain EXC_SUM bits require exception interrupts | `generateExceptionInterrupt()` to request an interrupt &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> C4. Memory \/ access check related<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">| Step | Called Subsystem &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Condition &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Must Call &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| ---- | -------------------------- | --------------------------- | ------------------------------------------------------------------- |<\/p>\n\r<p class=\"p_Normal\">| C4.1 | `Ev6PteCache` \/ SafeMemory | CheckAccess result is Fault | Use return `AccessResult` to drive page-fault\/trap path in AlphaCPU |<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## D. Methods to Add \/ Stub in `CPUStateIPRInterface`<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">These are the functions **EV6_Hooks expects to exist** and that you can safely stub now (no-ops or minimal logic) and refine later. This is the “kill 200 errors” checklist.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You can define them as `inline` members in `CPUStateIPRInterface`:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> D1. Mode &amp; speculative state<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```cpp<\/p>\n\r<p class=\"p_Normal\">inline void onModeChange(quint8 \/*oldCM*\/, quint8 \/*newCM*\/) noexcept {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ TODO: update any cached mode-derived state here.<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">inline void manageShadowBanks(quint8 \/*newCM*\/) noexcept {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ TODO: swap or update shadow register banks for new mode.<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">inline void flushSpeculativeState() noexcept {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ TODO: flush branch predictor \/ speculative state if you model it.<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">inline void notifyModeChangeAffectsInterruptEligibility() noexcept {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ TODO: mark interrupt eligibility dirty; AlphaCPU\/IRQ should re-check.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ e.g. m_interruptEligibilityDirty.store(true, std::memory_order_release);<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">(If you don’t have `oldCM` yet, you can extend the signature when you’re ready.)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> D2. AST helpers<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```cpp<\/p>\n\r<p class=\"p_Normal\">inline void requestAST(quint8 level) noexcept {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ TODO: update per-CPU AST request mask; tie to ASTRR\/HWPCB.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;level &amp;= 0x3;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ m_astPendingMask |= (1u &lt;&lt; level); \/\/ if you have such a field<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">inline bool checkPendingAST() const noexcept {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ TODO: compute ASTSR = ASTEN &amp; ASTRR with IPL gating.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ For now, return false to avoid spurious delivery.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;return false;<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> D3. Exception state \/ EXC_ADDR \/ EXC_SUM<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```cpp<\/p>\n\r<p class=\"p_Normal\">inline void updateExceptionState(quint64 \/*excAddr*\/) noexcept {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ TODO: track last exception address if you want debugging correlation.<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">inline void notifyExceptionAddressChanged(quint64 \/*oldValue*\/, quint64 \/*newValue*\/) noexcept {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ TODO: optional logging hook.<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">inline void evaluateExceptionSummary(quint64 \/*excSum*\/) noexcept {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ TODO: decode EXC_SUM bits, classify exception types.<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">inline bool isHardwareErrorPresent(quint64 \/*excSum*\/) const noexcept {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ TODO: inspect EXC_SUM for machine-check-worthy bits.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;return false;<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">inline void triggerMachineCheck(quint64 \/*excSum*\/) noexcept {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ TODO: schedule a machine check interrupt\/trap.<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">inline bool shouldGenerateExceptionInterrupt(quint64 \/*excSum*\/) const noexcept {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ TODO: determine if EXC_SUM implies an interrupt, beyond trap already taken.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;return false;<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">inline void generateExceptionInterrupt(quint64 \/*excSum*\/) noexcept {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ TODO: arrange for an interrupt at the appropriate SCB vector.<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">inline void attemptErrorRecovery(quint64 \/*oldValue*\/, quint64 \/*newValue*\/) noexcept {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ TODO: attempt micro-architectural state recovery, if modeled.<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">inline void logExceptionSummaryChange(quint64 \/*oldValue*\/, quint64 \/*newValue*\/) noexcept {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ TODO: add structured logging\/tracing.<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> D4. VA \/ MM_STAT helpers (IPR-level)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```cpp<\/p>\n\r<p class=\"p_Normal\">inline void updateVA(quint64 \/*va*\/) noexcept {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ TODO: track current VA used for ITB\/DTB miss PAL handlers.<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">inline void updateMMStat(quint64 \/*mmStat*\/) noexcept {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ TODO: keep a decoded view of MM_STAT if needed (IME\/DME\/ACV\/TNV).<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You don’t have to *finish* their behavior now — just add them so EV6_Hooks and your IPR descriptor table have a complete, well-defined interface to call into. Then your “hooks vs. implementation” gap becomes a **finite todo list**, not a compiler error storm.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If you’d like next, I can:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Take your current `Global_IPRInterface.h` and generate a **patched version** with all of these stubs added in-place, ready to drop into coreLib; or<\/p>\n\r<p class=\"p_Normal\">* Do the same style SSEC for `IRQController` so you can keep building your side-effect matrix.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r"
})
