hmLoadTopic({
hmKeywords:"",
hmTitle:"18.4 FaultDispatcher Implementation",
hmDescription:"18.4.1 Per-CPU Authority  There is one FaultDispatcher per CPU, accessed via globalFaultDispatcher(cpuId). The FaultDispatcher is the central authority for managing exceptional...",
hmPrevLink:"18_3-exceptionfactory.html",
hmNextLink:"18_5-exception-to-pal-vector-m.html",
hmParentLink:"chapter-18---fault-dispatcher-.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-18---fault-dispatcher-.html\">Chapter 18 – Fault Dispatcher &amp; Precise Exceptions<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 18 – Fault Dispatcher & Precise Exceptions > 18.4 FaultDispatcher Implementation",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">18.4 FaultDispatcher Implementation<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">18.4.1 Per-CPU Authority<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">There is one <span class=\"f_CodeExample\">FaultDispatcher<\/span> per CPU, accessed via <span class=\"f_CodeExample\">globalFaultDispatcher(cpuId)<\/span>. The FaultDispatcher is the central authority for managing exceptional events on its CPU. It decouples detection from delivery: faults are queued when detected (in EX stage) and delivered when the pipeline reaches a safe state (in WB stage). No other component may deliver exceptions or modify event state.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">18.4.2 Pending Flags (Hot Path)<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The FaultDispatcher\'s <span class=\"f_CodeExample\">eventPending()<\/span> method is the hottest path in the emulator — it is called every cycle by the CPU run loop. The implementation uses a simple bitfield check with no atomics (the FaultDispatcher is per-CPU and only accessed by its owning CPU thread):<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">bool&nbsp;eventPending()&nbsp;const&nbsp;noexcept&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;return&nbsp;m_pendingFlags&nbsp;!=&nbsp;0;&nbsp;\/\/&nbsp;~1&nbsp;cycle,&nbsp;no&nbsp;atomic<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">}<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The pending flags are a bitmask tracking event categories:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">FLAG_NONE&nbsp;=&nbsp;0x00<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">FLAG_EXCEPTION&nbsp;=&nbsp;0x01&nbsp;\/\/&nbsp;Generic&nbsp;exception<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">FLAG_ARITHMETIC_TRAP&nbsp;=&nbsp;0x02&nbsp;\/\/&nbsp;Arithmetic&nbsp;trap&nbsp;(for&nbsp;TRAPB)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">FLAG_DTB_MISS&nbsp;=&nbsp;0x04&nbsp;\/\/&nbsp;Data&nbsp;TLB&nbsp;miss<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">FLAG_ITB_MISS&nbsp;=&nbsp;0x08&nbsp;\/\/&nbsp;Instruction&nbsp;TLB&nbsp;miss<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">FLAG_INTERRUPT&nbsp;=&nbsp;0x10&nbsp;\/\/&nbsp;Interrupt&nbsp;pending<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">FLAG_MACHINE_CHECK&nbsp;=&nbsp;0x20&nbsp;\/\/&nbsp;Machine&nbsp;check&nbsp;(highest)<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Specialized query methods test individual flags: <span class=\"f_CodeExample\">hasPendingArithmeticTraps()<\/span> (FLAG_ARITHMETIC_TRAP, used by TRAPB), <span class=\"f_CodeExample\">hasPendingTLBFaults()<\/span> (DTB\/ITB), <span class=\"f_CodeExample\">hasPendingInterrupt()<\/span>, <span class=\"f_CodeExample\">hasPendingMachineCheck()<\/span>. These provide zero-cost queries for barrier release decisions without examining the full PendingEvent structure.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">18.4.3 Event Queueing and Clearing<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">setPendingEvent(event)<\/span> stores the PendingEvent and sets the appropriate flag bits. If a higher-priority event is already pending, the lower-priority event is held until the higher-priority event clears. <span class=\"f_CodeExample\">clearPendingEvents()<\/span> resets both the PendingEvent structure and the flag bitmask to zero. <span class=\"f_CodeExample\">clearArithmeticTrap()<\/span> selectively clears only the arithmetic trap flag and, if the pending event is of <span class=\"f_CodeExample\">Arithmetic<\/span> class, clears the event as well — this allows TRAPB to drain arithmetic traps while leaving other events pending.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">18.4.4 Delivery Preparation<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">When the pipeline is ready to deliver an event (faulting instruction at WB stage, or interrupt sampling point), the FaultDispatcher performs delivery preparation:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;1.&nbsp;Map&nbsp;ExceptionClass&nbsp;→&nbsp;PalVectorId<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">ev.palVectorId&nbsp;=&nbsp;ExceptionMapping_inl::mapClassToPalVector(ev);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;2.&nbsp;Validate&nbsp;mapping<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">if&nbsp;(ev.palVectorId&nbsp;==&nbsp;PalVectorId::INVALID)&nbsp;→&nbsp;internal&nbsp;error<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;3.&nbsp;Look&nbsp;up&nbsp;PAL&nbsp;vector&nbsp;entry<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">const&nbsp;PalVectorEntry*&nbsp;entry&nbsp;=&nbsp;globalPALVectorTable().lookup(ev.palVectorId);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;4.&nbsp;Enter&nbsp;PAL&nbsp;mode&nbsp;with&nbsp;resolved&nbsp;vector<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">enterPalMode(reason,&nbsp;entry-&gt;entryPC,&nbsp;ev.faultPC);<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The vector resolution is a two-step lookup: <span class=\"f_CodeExample\">ExceptionMapping_inl::mapClassToPalVector()<\/span> maps the <span class=\"f_CodeExample\">ExceptionClass_EV6<\/span> to a <span class=\"f_CodeExample\">PalVectorId_EV6<\/span>, and <span class=\"f_CodeExample\">PalVectorTable::lookup()<\/span> returns the <span class=\"f_CodeExample\">PalVectorEntry<\/span> containing the entry PC, target IPL, and entry conditions. This two-step design allows the classification and vector table to evolve independently.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: faultLib\/FaultDispatcher.h (~449 lines); exceptionLib\/ExceptionMapping_inl.h – mapClassToPalVector(); palLib_EV6\/PalVectorId_refined.h – PalVectorId enumeration; palLib_EV6\/PalVectorTable_final.h – PAL vector table.<\/span><\/p>\n\r"
})
