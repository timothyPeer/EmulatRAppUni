hmLoadTopic({
hmKeywords:"",
hmTitle:"16.3 Endianness and Device Registers",
hmDescription:"16.3.1 Alpha Is Always Little-Endian  All Alpha processors (21064, 21164, 21264\/EV6) are natively little-endian. There is no big-endian mode switch. Memory is stored with the...",
hmPrevLink:"16_2-mmio-routing-implementati.html",
hmNextLink:"16_4-asynchronous-device-threa.html",
hmParentLink:"chapter-16---device-model--dma.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-16---device-model--dma.html\">Chapter 16 – Device Model &amp; DMA<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 16 – Device Model & DMA > 16.3 Endianness and Device Registers",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">16.3 Endianness and Device Registers<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">16.3.1 Alpha Is Always Little-Endian<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">All Alpha processors (21064, 21164, 21264\/EV6) are natively little-endian. There is no big-endian mode switch. Memory is stored with the least significant byte at the lowest address. Instructions, data loads, and data stores all assume little-endian layout. Software that needs to manipulate big-endian data must perform explicit byte swapping using Alpha byte manipulation instructions (<span class=\"f_CodeExample\">INSWL<\/span>, <span class=\"f_CodeExample\">EXTQH<\/span>, <span class=\"f_CodeExample\">MSKBL<\/span>, etc.).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">In EMulatR, the memory system (GuestMemory, SafeMemory) stores and retrieves values in little-endian format. The <span class=\"f_CodeExample\">qFromLittleEndian()<\/span> \/ <span class=\"f_CodeExample\">qToLittleEndian()<\/span> Qt helpers are used at the boundary between the emulator\'s native host byte order and the guest\'s little-endian expectation.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">16.3.2 Device Register Endianness<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">While the Alpha CPU is always little-endian, peripheral devices may present registers in either byte order. Real Alpha systems (AlphaServer, AlphaStation) handle this through I\/O bridge and chipset configuration — the CPU always operates little-endian, but the I\/O bridge can be configured for per-device endianness translation.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">In EMulatR, endianness handling is the responsibility of the device emulator, not the CPU or memory system. The <span class=\"f_CodeExample\">MMIOWindow<\/span> structure carries a <span class=\"f_CodeExample\">regEndian<\/span> attribute (Little or Big) set during device registration. The contract is:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>The CPU always presents values in little-endian (host) order to MMIOManager<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>MMIOManager passes the value unchanged to the device handler<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>The device handler performs byte swapping if its registers are big-endian<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>On read, the device handler returns the value in little-endian order to the CPU<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This mirrors real hardware behavior: the I\/O bridge (emulated by MMIOManager dispatch) delivers bytes in the format the CPU expects; the device controller handles its own internal byte order.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">16.3.3 Common Endianness Patterns by Device Type<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Device Type<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Register Endianness<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Notes<\/strong><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">SCSI HBA (KZPBA \/ QLogic)<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Little-endian<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">PCI-native, matches Alpha byte order<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">IDE Controller<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Little-endian<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">ISA\/PCI-native<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Network Interface (NIC)<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Big-endian (data path)<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Network byte order (big-endian) for packet data; control registers typically little-endian<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">UART \/ Console<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Little-endian<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Byte-oriented, endianness is moot for 8-bit registers<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Fibre Channel HBA<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Big-endian (FC frames)<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">FC frame headers are big-endian per FC-FS specification; control registers may vary<\/p>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Network adapters deserve particular attention: the NIC control registers (command, status, interrupt mask) are typically little-endian PCI registers, but the DMA data path carries Ethernet frames in network byte order (big-endian). The device emulator must handle both byte orders within the same device, swapping packet data buffers during DMA but not register values. Guest OS network drivers (e.g., the <span class=\"f_CodeExample\">de<\/span> driver under Tru64 or Linux\/Alpha) expect this split behavior and use Alpha byte manipulation instructions to convert packet headers.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Invariant:<\/strong> The CPU and memory system never perform implicit byte swapping. Endianness conversion is always the device emulator\'s responsibility. MMIOManager is byte-order-transparent.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: coreLib\/mmio_core.h – MMIOWindow.regEndian attribute; Appendix: Endianness Rules (comprehensive implementation guide).<\/span><\/p>\n\r"
})
