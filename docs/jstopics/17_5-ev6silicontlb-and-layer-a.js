hmLoadTopic({
hmKeywords:"",
hmTitle:"17.5 Ev6SiliconTLB and Layer Architecture",
hmDescription:"17.5.1 Three-Layer Design  The translation subsystem enforces strict layering to maintain separation of concerns:  Layer 0 — Silicon (SPAMShardManager): Provides raw TLB storag",
hmPrevLink:"17_4-spam-tlb-cache-architectu.html",
hmNextLink:"17_6-replacement-policies.html",
hmParentLink:"chapter-17---tlb_-pte_-and-add.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-17---tlb_-pte_-and-add.html\">Chapter 17 – Address Translation, TLB, and PTE<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 17 – Address Translation, TLB, and PTE > 17.5 Ev6SiliconTLB and Layer Architecture",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">17.5 Ev6SiliconTLB and Layer Architecture<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">17.5.1 Three-Layer Design<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The translation subsystem enforces strict layering to maintain separation of concerns:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Layer 0 — Silicon (<\/span><span class=\"f_CodeExample\">SPAMShardManager<\/span>): Provides raw TLB storage and lookup. Knows nothing about page tables, miss handling, or page table walks. Operates purely on tags, ASNs, and PTE entries. This layer is accessed only through Layer 1.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Layer 1 — TLB Interface (<\/span><span class=\"f_CodeExample\">Ev6SiliconTLB<\/span>, <span class=\"f_CodeExample\">Ev6TLBInterface<\/span>): Wraps Layer 0 with a clean lookup\/insert\/invalidate API. No traits, no page-table knowledge. This is the layer that MBox, PAL, and IBox call for translation operations. The <span class=\"f_CodeExample\">Ev6SiliconTLB<\/span> is instantiated as a singleton via <span class=\"f_CodeExample\">Ev6SiliconTLB_Singleton::initialize(cpuCount, cfg)<\/span> during emulator boot.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Layer 2 — PAL \/ MMU \/ Miss Handling:<\/span> On TLB miss, this layer performs the three-level page table walk via <span class=\"f_CodeExample\">walkPageTable_EV6()<\/span>, reading PTEs from GuestMemory at each level. On success, it calls Layer 1 insert to refill the TLB. On failure, it raises the appropriate translation fault (TNV, FOE, FOW, FOR) through the FaultDispatcher.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Layer&nbsp;2:&nbsp;PAL&nbsp;\/&nbsp;MMU&nbsp;\/&nbsp;Miss&nbsp;Handler<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│&nbsp;walkPageTable_EV6()&nbsp;raise&nbsp;TNV\/FOE\/FOW\/FOR<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│&nbsp;GuestMemory&nbsp;PTE&nbsp;reads&nbsp;FaultDispatcher<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;▼<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Layer&nbsp;1:&nbsp;Ev6TLBInterface&nbsp;\/&nbsp;Ev6SiliconTLB<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│&nbsp;lookup()&nbsp;insert()&nbsp;invalidate()<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;▼<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Layer&nbsp;0:&nbsp;SPAMShardManager&nbsp;\/&nbsp;SPAMBucket<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│&nbsp;Per-CPU&nbsp;shards,&nbsp;hash&nbsp;buckets,&nbsp;replacement&nbsp;policies<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;▼<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;PTE&nbsp;entry&nbsp;storage&nbsp;(AlphaPTE&nbsp;via&nbsp;PTETraits)<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">17.5.2 Ev6SiliconTLB Singleton<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">Ev6SiliconTLB_Singleton<\/span> (<span class=\"f_CodeExample\">pteLib\/Ev6SiliconTLB_Singleton.h<\/span>) provides process-wide access to the TLB subsystem. Initialization occurs once at emulator boot:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Ev6VMConfig&nbsp;cfg{};<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">cfg.basePageSize&nbsp;=&nbsp;systemConfig.vm.pageSize;&nbsp;\/\/&nbsp;8K,&nbsp;16K,&nbsp;32K,&nbsp;64K<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">cfg.enableSuperpage64K&nbsp;=&nbsp;systemConfig.vm.enable64K;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Ev6SiliconTLB_Singleton::initialize(cpuCount,&nbsp;cfg);<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">After initialization, the SPAM shard manager is accessed via <span class=\"f_CodeExample\">Ev6SiliconTLB_Singleton::instance().spam()<\/span>. The <span class=\"f_CodeExample\">Ev6SiliconConfig<\/span> class centralizes page size configuration (<span class=\"f_CodeExample\">basePageSize<\/span>, superpage options) and is fed from the system configuration loader.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">17.5.3 EV6 Dual DTB Architecture<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The EV6 implementation uses two Data Translation Buffer banks (DTB0 and DTB1), reflecting the real EV6 hardware\'s dual-pipe TLB design. The <span class=\"f_CodeExample\">DualDTBManagerInterface<\/span> (<span class=\"f_CodeExample\">pteLib\/DualDTBManagerInterface.h<\/span>) defines DTB0\/DTB1-specific operations: separate lookup, insertion, invalidation, and occupancy queries for each bank. The <span class=\"f_CodeExample\">ev6_DtbPteTempRegister<\/span> helpers manipulate the EV6 DTB PTE Temporary Register used during DTB miss handling.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This dual-bank design allows the EV6 to walk PTEs in parallel with execution — one pipe can service a DTB miss while the other continues executing non-memory instructions.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: pteLib\/Ev6SiliconTLB_Singleton.h – TLB singleton; pteLib\/DualDTBManagerInterface.h – Dual DTB interface; <a href=\"14_4-mbox---memory-box.html\" class=\"topiclink\">14.4 MBox – Memory Box<\/a> (translation initiation).<\/span><\/p>\n\r"
})
