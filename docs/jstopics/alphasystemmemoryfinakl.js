hmLoadTopic({
hmKeywords:"",
hmTitle:"AlphaSystemMemoryFinakl",
hmDescription:"Agreed — this is exactly the right moment to **fix it and formally lock the contract down**.",
hmPrevLink:"",
hmNextLink:"",
hmParentLink:"appendix---trait-examples.html",
hmBreadCrumbs:"",
hmTitlePath:"Introduction > Appendix > Appendix I – Global Singletons",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">AlphaSystemMemoryFinakl<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">Agreed — this is exactly the right moment to **fix it and formally lock the contract down**.<\/p>\n\r<p class=\"p_Normal\">Below is a **clean corrective plan + documentation section** written in the same architectural tone you’ve been using today. This is intended to be *drop-in documentation* for your coreLib \/ memory subsystem.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"># Alpha Memory Subsystem — Corrected Layering &amp; Contract<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## Purpose of This Document<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This section defines the **authoritative responsibility boundaries** for the Alpha emulator memory subsystem and corrects an architectural violation where RAM\/MMIO checks leaked into the wrong layer.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This document is normative: **future code must conform to these rules**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## High-Level Memory Stack (Authoritative)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">AlphaCPU \/ DMA \/ Devices<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;│<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;▼<\/p>\n\r<p class=\"p_Normal\">AlphaSystemMemory<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;│<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;▼<\/p>\n\r<p class=\"p_Normal\">GuestMemory &nbsp; &nbsp; &nbsp; &nbsp;← Physical Address SpaOk. e Authority<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;│<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;├── SafeMemory &nbsp; (RAM backing store)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;└── MMIOManager &nbsp;(Devices)<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## Layer Responsibilities (Corrected &amp; Final)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> 1. `SafeMemory` — Raw Physical RAM Backing Store<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Role**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Owns contiguous RAM backing storage<\/p>\n\r<p class=\"p_Normal\">* Performs byte\/word\/quad loads and stores<\/p>\n\r<p class=\"p_Normal\">* Enforces:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* bounds<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* alignment<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* atomicity<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* endianness<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Explicitly MUST NOT**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Determine whether an address is RAM or MMIO<\/p>\n\r<p class=\"p_Normal\">* Know about:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* GuestMemory<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* AlphaSystemMemory<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* CPU privilege<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* platform address maps<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Invariant**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&gt; Every access reaching SafeMemory is **already known to be valid RAM**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> 2. `GuestMemory` — Physical Address Space Authority<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Role**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Single source of truth for **physical address routing**<\/p>\n\r<p class=\"p_Normal\">* Owns the platform memory map:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* RAM ranges<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* MMIO apertures<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* device BARs<\/p>\n\r<p class=\"p_Normal\">* Dispatches accesses to:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `SafeMemory` (RAM)<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `MMIOManager` (MMIO)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Responsibilities**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Decide **RAM vs MMIO**<\/p>\n\r<p class=\"p_Normal\">* Validate RAM access ranges<\/p>\n\r<p class=\"p_Normal\">* Reject illegal physical addresses<\/p>\n\r<p class=\"p_Normal\">* Remain platform-configurable (SRM, VMS, Tru64, Linux, custom)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Invariant**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&gt; No code above or below `GuestMemory` may independently decide RAM vs MMIO.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> 3. `AlphaSystemMemory` — CPU-Facing Memory Semantics<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Role**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Implements architectural semantics for memory access:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* MMU translation<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* ITB\/DTB lookup<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* privilege checks<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* alignment faults<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* access size rules<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* fault synthesis<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Delegation Rule**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* After producing a **final physical address**, all access **must pass through `GuestMemory`**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Explicitly MUST NOT**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Query RAM\/MMIO mappings<\/p>\n\r<p class=\"p_Normal\">* Call `SafeMemory` directly<\/p>\n\r<p class=\"p_Normal\">* Duplicate platform address map logic<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Invariant**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&gt; `AlphaSystemMemory` produces *meaning*, not *routing*.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## The Bug (What Was Wrong)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> Observed Violation<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">`AlphaSystemMemory` (or a lower helper) performed checks such as:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* “Is this RAM?”<\/p>\n\r<p class=\"p_Normal\">* “Is this GuestMemory?”<\/p>\n\r<p class=\"p_Normal\">* “Does this fall into SafeMemory?”<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This resulted in:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* duplicated policy<\/p>\n\r<p class=\"p_Normal\">* inconsistent routing<\/p>\n\r<p class=\"p_Normal\">* broken abstraction layering<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## The Fix (Required Changes)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> Rule 1 — Single Routing Decision<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Only `GuestMemory` may decide:**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```text<\/p>\n\r<p class=\"p_Normal\">Physical Address → RAM or MMIO<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> Rule 2 — SafeMemory Assumes Valid RAM<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">All functions in `SafeMemory` assume:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* address is RAM<\/p>\n\r<p class=\"p_Normal\">* address is already validated<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**No platform logic allowed.**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> Rule 3 — AlphaSystemMemory Delegates Routing<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"># Correct Pattern<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```cpp<\/p>\n\r<p class=\"p_Normal\">\/\/ AlphaSystemMemory<\/p>\n\r<p class=\"p_Normal\">PhysicalAddress pa = translateVA(...);<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">\/\/ GuestMemory decides<\/p>\n\r<p class=\"p_Normal\">guestMemory-&gt;access(pa, size, type, buffer);<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"># Forbidden Pattern<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```cpp<\/p>\n\r<p class=\"p_Normal\">\/\/ ❌ DO NOT DO THIS<\/p>\n\r<p class=\"p_Normal\">if (isRAM(pa)) {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;safeMemory-&gt;read(pa, ...);<\/p>\n\r<p class=\"p_Normal\">} else {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;mmio-&gt;write(pa, ...);<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## Corrected Call Flow (Canonical)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> Load \/ Store Path<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">AlphaCPU<\/p>\n\r<p class=\"p_Normal\"> &nbsp;↓<\/p>\n\r<p class=\"p_Normal\">AlphaSystemMemory<\/p>\n\r<p class=\"p_Normal\"> &nbsp;- MMU translate<\/p>\n\r<p class=\"p_Normal\"> &nbsp;- permission check<\/p>\n\r<p class=\"p_Normal\"> &nbsp;- alignment check<\/p>\n\r<p class=\"p_Normal\"> &nbsp;↓<\/p>\n\r<p class=\"p_Normal\">GuestMemory<\/p>\n\r<p class=\"p_Normal\"> &nbsp;- RAM vs MMIO routing<\/p>\n\r<p class=\"p_Normal\"> &nbsp;↓<\/p>\n\r<p class=\"p_Normal\">SafeMemory OR MMIOManager<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## Architectural Invariants (Must Hold)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1. **Exactly one RAM\/MMIO decision**<\/p>\n\r<p class=\"p_Normal\">2. **SafeMemory never rejects MMIO**<\/p>\n\r<p class=\"p_Normal\">3. **AlphaSystemMemory never knows platform layout**<\/p>\n\r<p class=\"p_Normal\">4. **GuestMemory is the physical authority**<\/p>\n\r<p class=\"p_Normal\">5. **No circular knowledge between layers**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## Why This Matters (Non-Negotiable)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This correction ensures:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* EV4\/EV5\/EV6 platform flexibility<\/p>\n\r<p class=\"p_Normal\">* Correct DMA semantics<\/p>\n\r<p class=\"p_Normal\">* Correct SMP reservation invalidation<\/p>\n\r<p class=\"p_Normal\">* Clean PALcode behavior<\/p>\n\r<p class=\"p_Normal\">* Future PCI \/ IOMMU correctness<\/p>\n\r<p class=\"p_Normal\">* Zero ambiguity in fault attribution<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is how **real Alpha firmware and hardware partition responsibilities**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## Action Items (Concrete)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1. **Remove all RAM\/MMIO checks from `AlphaSystemMemory`**<\/p>\n\r<p class=\"p_Normal\">2. **Ensure all physical accesses go through `GuestMemory`**<\/p>\n\r<p class=\"p_Normal\">3. **Audit `SafeMemory` for policy leaks (there should be none)**<\/p>\n\r<p class=\"p_Normal\">4. **Add this document to coreLib \/ architecture docs**<\/p>\n\r<p class=\"p_Normal\">5. **Add a comment banner in `GuestMemory` stating:**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &gt; “Single source of truth for physical address routing”<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## Final Assessment<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You were absolutely correct in your intuition.<\/p>\n\r<p class=\"p_Normal\">What you identified is a **classic HAL layering bug**, and fixing it now prevents months of subtle SMP and MMIO failures later.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This architecture is now:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* clean<\/p>\n\r<p class=\"p_Normal\">* scalable<\/p>\n\r<p class=\"p_Normal\">* faithful to Alpha hardware<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If you want next, I can:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* produce a **code diff sketch** for AlphaSystemMemory<\/p>\n\r<p class=\"p_Normal\">* or write a **GuestMemory contract comment block**<\/p>\n\r<p class=\"p_Normal\">* or audit one specific access path (CPU load, DMA write, MMIO read)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Just say the word.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r"
})
