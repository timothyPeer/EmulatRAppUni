hmLoadTopic({
hmKeywords:"",
hmTitle:"16.9 DMA Implementation",
hmDescription:"16.9.1 DMA Data Flow  DMA (Direct Memory Access) allows devices to read from and write to GuestMemory directly, without CPU intervention for each byte transferred. In EMulatR,...",
hmPrevLink:"16_8-irq-integration-architect.html",
hmNextLink:"mplatedefault-modified2026-02-.html",
hmParentLink:"chapter-16---device-model--dma.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-16---device-model--dma.html\">Chapter 16 – Device Model &amp; DMA<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 16 – Device Model & DMA > 16.9 DMA Implementation",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">16.9 DMA Implementation<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">16.9.1 DMA Data Flow<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">DMA (Direct Memory Access) allows devices to read from and write to GuestMemory directly, without CPU intervention for each byte transferred. In EMulatR, DMA operations are performed by device I\/O threads and route through <span class=\"f_CodeExample\">GuestMemory<\/span> using the <span class=\"f_CodeExample\">AccessKind::DMARead<\/span> and <span class=\"f_CodeExample\">AccessKind::DMAWrite<\/span> designators, which enables GuestMemory to apply DMA-specific access policies.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The typical DMA write path (device → GuestMemory): the device I\/O thread fills a local data buffer from host-side I\/O (e.g., disk read), calls <span class=\"f_CodeExample\">DMACoherencyManager<\/span> to prepare the transfer (RX path: DeviceToRAM), writes data into GuestMemory via <span class=\"f_CodeExample\">writeBlock()<\/span> with <span class=\"f_CodeExample\">AccessKind::DMAWrite<\/span>, and signals coherency completion. The typical DMA read path (GuestMemory → device) follows the TX path: <span class=\"f_CodeExample\">DMACoherencyManager<\/span> flushes CPU caches for the region (RAMToDevice), reads data from GuestMemory, and delivers it to the host-side I\/O path.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">16.9.2 DMA Coherency Manager<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">DMACoherencyManager<\/span> (<span class=\"f_CodeExample\">mmio_DMACoherencyManager.h<\/span>, ~579 lines) ensures that DMA transfers observe correct memory ordering with respect to CPU operations. It manages three coherency concerns:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">TX path (RAMToDevice):<\/strong> Before a device reads from GuestMemory (e.g., to fetch DMA descriptors or transmit buffer data), <span class=\"f_CodeExample\">DMACoherencyManager<\/span> ensures that all prior CPU writes to the affected memory region are visible. In a real Alpha system, this would involve cache flush operations; in EMulatR, it involves draining the affected CPU\'s write buffer entries that overlap the DMA region.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">RX path (DeviceToRAM):<\/strong> After a device writes to GuestMemory (e.g., depositing received network packets or disk read data), <span class=\"f_CodeExample\">DMACoherencyManager<\/span> ensures that subsequent CPU reads from the affected region see the device-written data, not stale cached values. This involves invalidating any overlapping write buffer entries and, in SMP configurations, coordinating across multiple CPUs.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">LL\/SC reservation invalidation:<\/strong> DMA writes to memory regions that overlap with an active LL\/SC reservation must break the reservation. <span class=\"f_CodeExample\">DMACoherencyManager<\/span> calls <span class=\"f_CodeExample\">ReservationManager::breakReservationsOnCacheLine()<\/span> for each 64-byte cache line touched by a DMA write. This prevents a STx_C from succeeding after a device has modified the memory it was protecting.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">16.9.3 DMA Address Constraints<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">DMA addresses are physical addresses within the GuestMemory space. <span class=\"f_CodeExample\">DMABufferDescriptor<\/span> tracks each allocated DMA buffer with its physical address, size, owning device UID, and address mask. The address mask distinguishes 32-bit DMA devices (which can only address the lower 4 GB of physical memory) from 64-bit DMA devices (which can address the full physical address space). The <span class=\"f_CodeExample\">dmaMask<\/span> field in <span class=\"f_CodeExample\">DeviceTemplate<\/span> specifies the device\'s DMA addressing capability.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Invariant:<\/strong> All DMA transfers route through GuestMemory with explicit AccessKind designation. No device may access SafeMemory directly. DMA completion does not imply memory ordering unless enforced by a subsequent interrupt and barrier.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: mmioLib\/mmio_DMACoherencyManager.h (~579 lines) – Coherency manager; <a href=\"15_8-ll_sc-reservation-trackin.html\" class=\"topiclink\">15.8 LL\/SC Reservation Tracking<\/a>; <a href=\"15_12-diagnostics-and-dma-cohe.html\" class=\"topiclink\">15.12 Diagnostics and DMA Coherency<\/a>.<\/span><\/p>\n\r"
})
