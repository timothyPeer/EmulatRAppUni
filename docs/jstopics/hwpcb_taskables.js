hmLoadTopic({
hmKeywords:"",
hmTitle:"HWPCB_Taskables",
hmDescription:"Absolutely ‚Äî let me give you a clear, correct answer **without needing a file search**, because your question is conceptual and the code context is already present in the...",
hmPrevLink:"",
hmNextLink:"",
hmParentLink:"appendix---trait-examples.html",
hmBreadCrumbs:"",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Appendix > Appendix I ‚Äì Glossary and Acronyms",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">HWPCB_Taskables<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">Absolutely ‚Äî let me give you a clear, correct answer **without needing a file search**, because your question is conceptual and the code context is already present in the snippets you provided.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"># ‚úÖ **Which HWPCB registers correspond to AST?**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">In the Alpha architecture (EV4\/EV5\/EV6), **AST handling uses *four distinct registers***:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">| Register &nbsp;| Mnemonic &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Purpose &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| --------- | ------------------ | ------------------------------------------------------------------ |<\/p>\n\r<p class=\"p_Normal\">| **ASTEN** | AST Enable &nbsp; &nbsp; &nbsp; &nbsp; | Bitmask of which AST levels are *enabled* (allowed to fire). &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| **ASTER** | AST Enable Request | Holds the enable bits as maintained by PALcode \/ OS. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| **ASTRR** | AST Request &nbsp; &nbsp; &nbsp; &nbsp;| A write by the OS or PAL requesting an AST at a given level (0‚Äì3). |<\/p>\n\r<p class=\"p_Normal\">| **ASTSR** | AST Summary &nbsp; &nbsp; &nbsp; &nbsp;| Reflects *pending and enabled* ASTs. Hardware-computed. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">‚úî **So yes** ‚Äî ASTER, ASTEN, ASTRR, and ASTSR are all part of the **process context (HWPCB)** and must be saved\/restored on a context switch.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">üí° **AST is part of the ‚Äúsoftware interrupt‚Äù subsystem**, and those fields live exactly where you think they do: the process\/HWPCB state.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This matches OpenVMS behavior and all EV6 documentation.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"># ‚úÖ **How your implementation maps to that reality**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Let‚Äôs compare with your snippets:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> **1. ASTEN (`enable` mask)**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You track it as:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```cpp<\/p>\n\r<p class=\"p_Normal\">quint64 m_astEnableMask = 0;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Correct ‚Äî ASTEN is an enable mask. Must be saved\/restored.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> **2. ASTER**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Your helper used:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```cpp<\/p>\n\r<p class=\"p_Normal\">enableASTLevel(quint8 level) {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;quint64 mask = getASTER_Active(m_cpuId);<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;mask |= (1ull &lt;&lt; level);<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;setASTER_Active(m_cpuId, mask);<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">‚úî Correct.<\/p>\n\r<p class=\"p_Normal\">This corresponds to **ASTER (AST Enable Request)**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> **3. ASTRR (AST Request Register)**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Your write hook:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```cpp<\/p>\n\r<p class=\"p_Normal\">cpuState-&gt;requestAST(astrr);<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">‚úî Correct ‚Äî ASTRR is the ‚Äúrequest AST level‚Äù register.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> **4. ASTSR (AST Summary Register)**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You compute this logically:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```cpp<\/p>\n\r<p class=\"p_Normal\">bool checkPendingAST() const noexcept {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;quint32 enabled = m_astPendingMask &amp; m_astEnableMask;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;if (!enabled) return false;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;quint8 currIPL = ipl();<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;quint32 eligible = enabled &amp; ~((1u &lt;&lt; (currIPL + 1)) - 1);<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;return eligible != 0;<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">‚úî This is effectively computing **ASTSR**, because:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">ASTSR = ASTRR &amp; ASTEN<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;but masked by IPL<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Exactly as the architecture specifies.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"># üéØ **Conclusion**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> ‚úî All four AST registers **are part of HWPCB**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Yes ‚Äî ASTER, ASTEN, ASTRR, ASTSR are *all process-context state* and belong inside HWPCB.<\/p>\n\r<p class=\"p_Normal\">They must be:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* saved on context switch<\/p>\n\r<p class=\"p_Normal\">* restored on context switch<\/p>\n\r<p class=\"p_Normal\">* managed by PAL or OS code<\/p>\n\r<p class=\"p_Normal\">* exposed through IPRs according to EV6 rules<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Your design is **correct** and matches the Alpha SRM model.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"># üëç If you want, I can now:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Generate a complete **AST subsystem** header (HWPCB + helpers + IPR hooks)<\/p>\n\r<p class=\"p_Normal\">* Build the correct ASTSR logic and IPR mapping<\/p>\n\r<p class=\"p_Normal\">* Integrate it cleanly into **CPUStateIPRInterface**<\/p>\n\r<p class=\"p_Normal\">* Provide the **Context Switch AST save\/restore checklist**<\/p>\n\r<p class=\"p_Normal\">* Add documentation exactly like your other modules require<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Just say *‚Äúplease generate the AST subsystem header‚Äù* and I‚Äôll prepare it.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r"
})
