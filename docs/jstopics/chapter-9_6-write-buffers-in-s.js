hmLoadTopic({
hmKeywords:"",
hmTitle:"9.6 Inter-Processor Interrupts (IPIs)",
hmDescription:"9.6.1 Purpose  IPIs are the primary SMP coordination mechanism. They are used for TLB shootdowns, cache invalidation coordination, memory barrier completion signaling, CPU...",
hmPrevLink:"chapter-9_5-memory-visibility-.html",
hmNextLink:"chapter-9_7-reservation-invali.html",
hmParentLink:"chapter9-smparchitecture.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter9-smparchitecture.html\">Chapter 9 - SMP Architecture<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 9 - SMP Architecture > 9.6 Inter-Processor Interrupts (IPIs)",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">9.6 Inter-Processor Interrupts (IPIs)<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">9.6.1 Purpose<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">IPIs are the primary SMP coordination mechanism. They are used for TLB shootdowns, cache invalidation coordination, memory barrier completion signaling, CPU halt\/wake, context switch requests, and cross-CPU synchronization.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">9.6.2 IPICommand Enumeration<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">IPI commands are defined by IPICommand (IPI_core.h, 245 lines). The full command set is organized by function:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">enum&nbsp;class&nbsp;IPICommand&nbsp;:&nbsp;quint8&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;INVALID&nbsp;=&nbsp;0x00,<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;TLB&nbsp;Invalidation&nbsp;(0x01–0x07)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;TLB_INVALIDATE_ALL&nbsp;=&nbsp;0x01,&nbsp;\/\/&nbsp;TBIA:&nbsp;all&nbsp;TLBs,&nbsp;all&nbsp;ASNs<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;TLB_INVALIDATE_ASN&nbsp;=&nbsp;0x02,&nbsp;\/\/&nbsp;TBIAP:&nbsp;by&nbsp;ASN&nbsp;(ITB+DTB)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;TLB_INVALIDATE_VA_BOTH&nbsp;=&nbsp;0x03,&nbsp;\/\/&nbsp;TBIS:&nbsp;single&nbsp;VA&nbsp;(ITB+DTB)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;TLB_INVALIDATE_VA_ITB&nbsp;=&nbsp;0x04,&nbsp;\/\/&nbsp;TBISI:&nbsp;single&nbsp;VA&nbsp;(ITB&nbsp;only)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;TLB_INVALIDATE_VA_DTB&nbsp;=&nbsp;0x05,&nbsp;\/\/&nbsp;TBISD:&nbsp;single&nbsp;VA&nbsp;(DTB&nbsp;only)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;TLB_INVALIDATE_GLOBAL&nbsp;=&nbsp;0x06,&nbsp;\/\/&nbsp;Reserved:&nbsp;global&nbsp;entries<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;TLB_INVALIDATE_RANGE&nbsp;=&nbsp;0x07,&nbsp;\/\/&nbsp;Reserved:&nbsp;VA&nbsp;range<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;Cache&nbsp;Coherency&nbsp;(0x10–0x13)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;CACHE_INVALIDATE_LINE&nbsp;=&nbsp;0x10,&nbsp;\/\/&nbsp;Invalidate&nbsp;cache&nbsp;line&nbsp;at&nbsp;PA<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;CACHE_FLUSH_LINE&nbsp;=&nbsp;0x11,&nbsp;\/\/&nbsp;Write-back&nbsp;+&nbsp;invalidate<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;CACHE_EVICT_LINE&nbsp;=&nbsp;0x12,&nbsp;\/\/&nbsp;ECB&nbsp;instruction<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;CACHE_INVALIDATE_ALL&nbsp;=&nbsp;0x13,&nbsp;\/\/&nbsp;Invalidate&nbsp;all&nbsp;caches<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;Memory&nbsp;Barriers&nbsp;(0x20–0x22)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;MEMORY_BARRIER_FULL&nbsp;=&nbsp;0x20,&nbsp;\/\/&nbsp;MB:&nbsp;full&nbsp;memory&nbsp;barrier<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;MEMORY_BARRIER_WRITE&nbsp;=&nbsp;0x21,&nbsp;\/\/&nbsp;WMB:&nbsp;write&nbsp;memory&nbsp;barrier<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;MEMORY_BARRIER_READ&nbsp;=&nbsp;0x22,&nbsp;\/\/&nbsp;Reserved:&nbsp;read&nbsp;barrier<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;Synchronization&nbsp;(0x30–0x31)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;SYNC_REQUEST&nbsp;=&nbsp;0x30,&nbsp;\/\/&nbsp;Request&nbsp;sync&nbsp;point<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;SYNC_ACKNOWLEDGE&nbsp;=&nbsp;0x31,&nbsp;\/\/&nbsp;Acknowledge&nbsp;sync<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;System&nbsp;Control&nbsp;(0x40–0x42)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;HALT_CPU&nbsp;=&nbsp;0x40,&nbsp;\/\/&nbsp;Halt&nbsp;target&nbsp;CPU<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;WAKE_CPU&nbsp;=&nbsp;0x41,&nbsp;\/\/&nbsp;Wake&nbsp;from&nbsp;halt<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;CONTEXT_SWITCH&nbsp;=&nbsp;0x42,&nbsp;\/\/&nbsp;Remote&nbsp;context&nbsp;switch<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;Custom&nbsp;(0xF0–0xFF)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;CUSTOM_BASE&nbsp;=&nbsp;0xF0,&nbsp;\/\/&nbsp;Custom&nbsp;command&nbsp;base<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;CUSTOM&nbsp;=&nbsp;0xFF&nbsp;\/\/&nbsp;Generic&nbsp;custom&nbsp;IPI<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">};<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">IPI data is encoded as a quint64: command byte in bits [63:56], parameter in bits [55:0]. Helper functions encodeIPIData(), encodeIPIWithVA(), encodeIPIWithASN(), decodeIPICommand(), decodeIPIVA(), and decodeIPIASN() handle encoding and decoding.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">9.6.3 IPIManager<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">IPIManager (IPIManager.h, 192 lines) provides lock-free IPI message routing. Each CPU has an atomic IPI data slot (std::atomic&lt;quint64&gt;). Latest-IPI-wins semantics (Alpha behavior — posting overwrites any pending IPI).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Key API: postIPI(cpuId, ipiData) stores atomically with memory_order_release; fetchIPI(cpuId) atomically exchanges to zero with memory_order_acq_rel (read and clear); peekIPI(cpuId) reads without clearing; hasIPIPending(cpuId) checks for non-zero data.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">9.6.4 Delivery Model<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">IPIs are generated by one CPU (via MTPR_IPIR or WRIPIR PAL instructions), routed via IPIManager (lock-free atomic slots), delivered to the target CPU as interrupts (sampled by checkInterrupts()), and handled in PAL mode on the target CPU. IPIs follow the same delivery rules as other interrupts — masked by IPL, delivered at instruction boundaries.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: coreLib\/IPI_core.h; emulatrLib\/IPIManager.h.<\/span><\/p>\n\r"
})
