hmLoadTopic({
hmKeywords:"",
hmTitle:"19.4 Interrupt Sampling and Delivery",
hmDescription:"Interrupts are sampled during the pre-cycle phase of the AlphaCPU run loop, before pipeline advancement. The delivery sequence for the CPU thread each cycle:",
hmPrevLink:"19_3-interrupt-routing.html",
hmNextLink:"19_5-ipi-architecture.html",
hmParentLink:"chapter-19---debugging_-tracin.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-19---debugging_-tracin.html\">Chapter 19 – Interrupt Architecture &amp; IPI<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 19 – Interrupt Architecture & IPI > 19.4 Interrupt Sampling and Delivery",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">19.4 Interrupt Sampling and Delivery<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">Interrupts are sampled during the pre-cycle phase of the <span class=\"f_CodeExample\">AlphaCPU<\/span> run loop, before pipeline advancement. The delivery sequence for the CPU thread each cycle:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">AlphaCPU::checkInterrupts()<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;├──&nbsp;1.&nbsp;Read&nbsp;current&nbsp;IPL&nbsp;from&nbsp;PS<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;├──&nbsp;2.&nbsp;Test&nbsp;IRQPendingState::hasDeliverable(currentIPL)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│&nbsp;(single&nbsp;atomic&nbsp;load&nbsp;+&nbsp;compare,&nbsp;~5&nbsp;cycles)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│&nbsp;Nothing&nbsp;pending&nbsp;→&nbsp;return&nbsp;immediately<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;├──&nbsp;3.&nbsp;claimNext()&nbsp;→&nbsp;ClaimedInterrupt{source,&nbsp;IPL,&nbsp;vector}<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│&nbsp;Atomically&nbsp;claim&nbsp;highest-priority&nbsp;interrupt<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;├──&nbsp;4.&nbsp;Clear&nbsp;SISR&nbsp;bit&nbsp;(if&nbsp;software&nbsp;interrupt)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;├──&nbsp;5.&nbsp;Break&nbsp;LL\/SC&nbsp;reservation<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│&nbsp;ReservationManager::breakReservation(cpuId)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;├──&nbsp;6.&nbsp;PalService::deliverInterrupt(claimed)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│&nbsp;Save&nbsp;PC&nbsp;and&nbsp;PS<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│&nbsp;Select&nbsp;interrupt&nbsp;PAL&nbsp;vector<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│&nbsp;enterPalMode(INTERRUPT,&nbsp;vector,&nbsp;currentPC)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;└──&nbsp;7.&nbsp;Flush&nbsp;pipeline<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Interrupts are never injected mid-instruction. The check occurs at instruction boundaries, after the previous instruction has fully retired. When an interrupt is delivered, the pipeline is flushed and control transfers to the PAL interrupt handler. The handler identifies the interrupt source, services it, and returns via <span class=\"f_CodeExample\">HW_REI<\/span>.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Invariant:<\/span> Synchronous faults always take priority over interrupts. If a fault is pending in the FaultDispatcher, interrupt delivery is blocked until the fault is resolved. The delivery order is: synchronous fault → machine check → deliverable interrupt → resume execution.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: cpuCoreLib\/AlphaCPU.h – checkInterrupts(); <a href=\"18_6-pipeline-fault-detection-.html\" class=\"topiclink\">18.6 Pipeline Fault Detection and Delivery Flow<\/a>; palLib_EV6\/Pal_Service.h – deliverInterrupt().<\/span><\/p>\n\r"
})
