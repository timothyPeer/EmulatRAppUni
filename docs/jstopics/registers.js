hmLoadTopic({
hmKeywords:"",
hmTitle:"Registers",
hmDescription:"CBox operations participate in the architectural order of operations as serialized, atomic control commits; the MSB-first 6-bit shifting is purely microarchitectural and must...",
hmPrevLink:"",
hmNextLink:"",
hmParentLink:"appendix---trait-examples.html",
hmBreadCrumbs:"",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Appendix > Appendix I â€“ Glossary and Acronyms",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">Registers<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">CBox operations participate in the architectural order of operations as serialized, atomic control commits; the MSB-first 6-bit shifting is purely microarchitectural and must be collapsed into a single grain-level state transition that enforces the same ordering guarantees as PAL entry, interrupts,<\/p>\n\r<p class=\"p_Normal\">and HW_REI.<\/p>\n\r<p class=\"p_Comment\"><span class=\"f_Comment\">&nbsp;<\/span><\/p>\n\r<p class=\"p_Comment\"><span class=\"f_Comment\">&quot;Order is guaranteed by program-order retirement and explicit serialization points; any asynchronous backends MUST be drained\/fenced at those points.&quot;<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>The EmulatR implements deterministic retirement order of the PC+n \/ serialized grain loop.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>The CBox ordering implementation is not only &quot;program order&quot;; it also requires a serialization point that fences visibility of certain effects relative to:<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.6250rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: \'Courier New\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">o<\/span>interrupts \/ PAL entry,<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.6250rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: \'Courier New\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">o<\/span>instruction fetch coherency (I-stream),<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.6250rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: \'Courier New\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">o<\/span>and any microarchitectural concurrency you simulate (async mem, device DMA, etc.).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Heading3\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">A.<\/span><span class=\"f_Heading3\">Grain as the architectural &quot;retirement event&quot;<\/span><\/p>\n\r<p class=\"p_Normal\">An instruction grain represents a single Alpha instruction at the point it is architecturally retired. The AlphaPipeline executes grains in program order and commits each grain\'s architected side effects before advancing the PC to the next instruction (PC+4 or redirected PC).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_Heading3\">B. CBox grains are serialization grains<\/span> <\/p>\n\r<p class=\"p_Normal\">CBox-related grains (e.g., hw_mtpr_I_CTL, hw_mtpr_IC_FLUSH, hw_mfpr_I_CTL) are modeled as &quot;serialized control transactions&quot;. The grain does not model EV6 microarchitectural mechanisms (e.g., internal shift-register loading of 6-bit chunks into C_DATA). Instead, the grain models the architectural contract:<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>The operation is atomic with respect to architectural observation.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>All prior instructions are complete before the CBox state change becomes visible.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>No subsequent instruction observes a partial CBox update.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">C. What &quot;complete&quot; means for CBox retirement<\/span><\/h3>\n\r<p class=\"p_Normal\">At retirement of a CBox grain, the EmulatR guarantees:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">1.<\/span>The requested CBox control effect is logically committed (or treated as a no-op with preserved ordering, where appropriate).<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">2.<\/span>The pipeline is serialized such that interrupts cannot be taken &quot;mid-CBox&quot;.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">3.<\/span>Any required instruction-stream ordering point is established (e.g., an IC_FLUSH acts as an I-stream barrier even if the emulator does not model a physically stale I-cache).<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">&nbsp;<\/span><\/h3>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">D. Where the ordering comes from<\/span><\/h3>\n\r<p class=\"p_Normal\">The ordering semantics are achieved by:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>The AlphaPipeline\'s in-order retirement (grain pumping), AND<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>An explicit &quot;serialize pipeline&quot; step performed by CBox grains to ensure that side effects are completed and visible before PC advances.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>The AlphaPipeline &nbsp;enforces &quot;retire one grain at a time and complete all its side effects before PC advances&quot;; the AlphaPipleline provides the essential architectural ordering property that CBox needs.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">Order of Operation Rule for CBox Grains. <\/span><\/h3>\n\r<p class=\"p_Normal\">Include these as short &quot;MUST&quot; statements in your documentation:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Rule 1: Grain retirement is the architectural commit boundary.<\/p>\n\r<p class=\"p_Normal\">Rule 2: CBox grains perform a serialization step before commit.<\/p>\n\r<p class=\"p_Normal\">Rule 3: Interrupt delivery checks occur only at grain boundaries or at explicit pipeline safe points; serialization grains block mid-grain interrupt entry.<\/p>\n\r<p class=\"p_Normal\">Rule 4: MB\/WMB and CBox serialization drain\/fence any emulator-internal async queues that can reorder visibility (SafeMemory, MMIO, device I\/O).<\/p>\n\r<p class=\"p_Normal\">Rule 5: IC_FLUSH may be modeled as a no-op only if it still provides the ordering point required for I-stream correctness (e.g., invalidating translated code cache entries for the affected region if you have a JIT\/cache).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Grain Order of Operation (PC+n) and AlphaPipeLine with MB\/WMB fencing handle the following C_Box bit shifting:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">CBox Bit Shifting Operations: <\/p>\n\r<p class=\"p_Normal\">Split into three shift register chains. <\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">1.<\/span>The hardware allocates 367 bits for the \/write_ONCE chain, of which the 21264 uses 303 bits. &nbsp;During hardware reset (after BiST), 367 bits are always shifted into the WRITE_ONCE chain from the SROM, MSB first, so that anu unused bits are shifted out the end of the WRITE_ONCE chain. <\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">2.<\/span>A 36-bit WRITE_MANY chain that is loaded using MTPR instructions to the CBox data register.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">a.<\/span>Six bits of information are shifted into the WRITE_MANY chain during each write transaction to the CBox data register.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">3.<\/span>A 60-bit CBox ERROR_REG chain that is read by using MFFR instructions from the Cbox data register in combination with MTPR instruction to the CBox shift register. Each write transaction to the CBox shift register destructively shifts six bits of information out of the Cbox error register. <\/p>\n\r<p class=\"p_Normal\">d<\/p>\n\r<p class=\"p_Normal\">Internal PAL instructions referenced: HW_MTPR and HW_MFPR<span style=\"background-color: #ff0000;\">&nbsp;(what is the dispatch mechanism?<\/span>)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Name<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Offset<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Implementation<\/strong><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">C_DATA<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">[5:0] RW<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">HW_MTPR instruction this register causes six bits of data to be placed in a serial shift register. &nbsp;When the HW_MTPR instruction is retired, the data is shifted into the CBox. &nbsp;After the shift register has been accessed, performing a HW_MFPR instruction this register will return six bits of data. <\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">C_SHFT<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">[0] W<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Writing a 1 to this register bit causes six bits of Cbox IPR dta to shift into the Cbox data registerws. Software can then use a HW_MFPR read operation to the CBox data register to read the data. <\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">WRITE_ONCE <\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><br \/>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Chain order from LSB to MSB - document this. <\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">WRITE_MANY<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><br \/>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Chain order of multi-bit vectors [MSB:LSB] - the LSB is the first bit in the CBox chain<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><br \/>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><br \/>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><br \/>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r"
})
