hmLoadTopic({
hmKeywords:"Advancement,Barrier,Barrier_EXC,Barrier_MB,Barrier_TRAP,Barrier_WRITE,CBox,Check,Commit,Cycle,Delivery,Drain,drainWriteBuffers,Evaluation,Exception,executeEXCB,executeMB,ExecuteStage,executeTRAPB,executeWMB,Fetch,Flag,Freeze,Frontend,Grain,GuestMemory,Interrupt,memoryBarrierCompleted,MEMStage,needsMemoryBarrier,needsWriteBufferDrain,Pipeline,Release,Sampling,SerializationType,Slot,Speculation,Stage,Stall,WBStage,WriteBuffer,writeBufferDrained",
hmTitle:"6.5 Pipeline-Level Behavior",
hmDescription:"6.5.1 How Barriers Stall the Pipeline  When a barrier instruction reaches the Execute (EX) stage, its grain calls the appropriate CBox method (executeMB, executeWMB,...",
hmPrevLink:"chapter-6_4-classes-of-seriali.html",
hmNextLink:"chapter-6_6-barrier-release-mo.html",
hmParentLink:"chapter-6---serialization-and-.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-6---serialization-and-.html\">Chapter 6 - Serialization and Stall Model<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 6 - Serialization and Stall Model > 6.5 Pipeline-Level Behavior",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">6.5 Pipeline-Level Behavior<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">6.5.1 How Barriers Stall the Pipeline<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">When a barrier instruction reaches the Execute (EX) stage, its grain calls the appropriate CBox method (executeMB, executeWMB, executeTRAPB, or executeEXCB). The barrier then:<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">1.<\/span>Sets slot.stalled = true<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">2.<\/span>Records slot.serializeType (Barrier_MB, Barrier_TRAP, Barrier_WRITE, or Barrier_EXC)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">3.<\/span>Sets slot.needsMemoryBarrier and\/or slot.needsWriteBufferDrain flags<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">4.<\/span>Prevents frontend fetch — no new instructions enter the pipeline<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">5.<\/span>Prevents advancement of younger instructions — stages before the barrier freeze<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">6.<\/span>Allows older instructions to continue draining through MEM and WB<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The stall is checked in stage_MEM(), which evaluates the barrier flags each cycle:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;stage_MEM()&nbsp;stall&nbsp;check<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">if&nbsp;(slot.needsMemoryBarrier&nbsp;&amp;&amp;&nbsp;!slot.memoryBarrierCompleted)&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;slot.stalled&nbsp;=&nbsp;true;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;return;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">}<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">if&nbsp;(slot.needsWriteBufferDrain&nbsp;&amp;&amp;&nbsp;!slot.writeBufferDrained)&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;slot.stalled&nbsp;=&nbsp;true;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;return;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">}<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">6.5.2 What Continues During a Stall<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">While a barrier is stalled, the pipeline is not frozen — only the barrier slot and younger stages are held. Older stages continue to execute:<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Earlier pipeline slots (MEM, WB) continue to advance and retire<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Write buffers may drain — CBox::drainWriteBuffers() commits buffered writes to GuestMemory<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Exceptions may be delivered from older instructions in WB<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Interrupts may be sampled (but not taken unless safe)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">No new speculative instructions are fetched until the barrier releases.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-3_12-stalls-and-serial.html\" class=\"topiclink\">3.12 Stalls and Serialization<\/a>; <a href=\"chapter-3_8-memory-stage-(mem).html\" class=\"topiclink\">3.8 Memory Stage (MEM)<\/a>.<\/span><\/p>\n\r"
})
