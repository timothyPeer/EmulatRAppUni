hmLoadTopic({
hmKeywords:"",
hmTitle:"2.7 Execution and Commit Semantics",
hmDescription:"2.7.1 Execute Stage Semantics  All instruction semantics occur in the Execute (EX) stage: Integer arithmetic and logic (EBox) Floating-point operations (FBox) Memory access —",
hmPrevLink:"chapter-2_6-speculation-policy.html",
hmNextLink:"chapter-2_8-interaction-with-s.html",
hmParentLink:"chapter-2---execution-model.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-2---execution-model.html\">Chapter 2 - Execution Model<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 2 - Execution Model > 2.7 Execution and Commit Semantics",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">2.7 Execution and Commit Semantics<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">2.7.1 Execute Stage Semantics<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">All instruction semantics occur in the Execute (EX) stage:<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Integer arithmetic and logic (EBox)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Floating-point operations (FBox)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Memory access — loads and stores, address translation (MBox)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Barrier setup and serialization requests (CBox)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Privileged operations (PalBox)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Branch condition evaluation (EBox)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Other pipeline stages perform bookkeeping only. The Fetch stage obtains instructions via IBox, the Decode stage validates grain association, and the Issue stage checks for hazards. None of these stages produce architecturally visible side effects.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">In the implementation, stage_EX() within AlphaPipeline dispatches to the grain\'s execute() method, which in turn invokes the appropriate Box. Faults detected during EX (alignment, TLB miss, access violation) are recorded in the slot\'s fault state for delivery at WB.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">2.7.2 Writeback as Commit Point<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The Writeback (WB) stage is the sole architectural commit point:<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Registers are updated (note: register writes are physically performed in stage_MEM for forwarding, but become architecturally visible at WB)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Memory stores become architecturally committed<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>PC updates are finalized<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Instructions are considered retired<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Branch predictor is updated with actual outcomes<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Faults that reached retirement are dispatched<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Any instruction that has not reached WB may be discarded without architectural side effects. This is the fundamental guarantee that enables precise exceptions, speculation recovery, and pipeline flushing.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">Implementation Note: Register Write Timing<\/span><\/h3>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The pipeline processes stages from oldest to youngest (WB → MEM → EX → IS → DE → IF). Register writes physically occur in stage_MEM() so that stage_EX() in the same cycle can read the updated value — this is the forwarding path. Because stage_MEM() executes before stage_EX() in the same tick, a value written by an older instruction at MEM is immediately available to a younger instruction at EX.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;Execution&nbsp;order&nbsp;within&nbsp;tick():<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;1.&nbsp;stage_WB()&nbsp;-&nbsp;Retire,&nbsp;commit&nbsp;stores,&nbsp;dispatch&nbsp;faults<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;2.&nbsp;stage_MEM()&nbsp;-&nbsp;Register&nbsp;writeback&nbsp;(forwarding&nbsp;path)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;3.&nbsp;stage_EX()&nbsp;-&nbsp;Read&nbsp;registers,&nbsp;execute&nbsp;instruction&nbsp;semantics<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;4.&nbsp;stage_IS()&nbsp;-&nbsp;Hazard&nbsp;check<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;5.&nbsp;stage_DE()&nbsp;-&nbsp;Decode&nbsp;(mostly&nbsp;NOOP&nbsp;—&nbsp;IBox&nbsp;already&nbsp;decoded)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;6.&nbsp;stage_IF()&nbsp;-&nbsp;Instruction&nbsp;fetch<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-3---pipeline-architect.html\" class=\"topiclink\">Chapter 3 - Pipeline Architecture (full stage contract)<\/a>; <a href=\"chapter-3_9-writeback-stage-(w.html\" class=\"topiclink\">3.9 Writeback Stage (WB)<\/a>; <a href=\"chapter-3_11-backward-pipeline.html\" class=\"topiclink\">3.11 Backward Pipeline Advancement<\/a>.<\/span><\/p>\n\r"
})
