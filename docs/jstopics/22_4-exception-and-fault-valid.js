hmLoadTopic({
hmKeywords:"",
hmTitle:"22.4 Exception and Fault Validation",
hmDescription:"Exception correctness is validated by triggering known fault conditions and verifying the complete delivery chain:",
hmPrevLink:"22_3-determinism-as-a-validati.html",
hmNextLink:"22_5-memory-ordering-and-ll_sc.html",
hmParentLink:"chapter-22---testing_-validati.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-22---testing_-validati.html\">Chapter 22 – Testing, Validation, and Architectural Compliance<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 22 – Testing, Validation, and Architectural Compliance > 22.4 Exception and Fault Validation",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">22.4 Exception and Fault Validation<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">Exception correctness is validated by triggering known fault conditions and verifying the complete delivery chain:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Correct exception class:<\/strong> Each fault condition must produce the expected <span class=\"f_CodeExample\">ExceptionClass_EV6<\/span> value. An unaligned access must produce <span class=\"f_CodeExample\">Unalign<\/span>, not <span class=\"f_CodeExample\">Dfault<\/span>. A privileged instruction in user mode must produce <span class=\"f_CodeExample\">OpcDec<\/span>.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Precise delivery point:<\/strong> The faulting instruction is identified exactly (EXC_ADDR = faulting PC). No younger instruction commits. All prior instructions have completed. Architectural state is consistent at the delivery point.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Correct PAL vector selection:<\/strong> <span class=\"f_CodeExample\">ExceptionMapping_inl::mapClassToPalVector()<\/span> maps to the expected <span class=\"f_CodeExample\">PalVectorId_EV6<\/span>. The PalVectorTable lookup produces the correct PAL entry PC.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Correct state on PAL entry:<\/strong> EXC_ADDR contains the faulting PC. EXC_SUM is populated for arithmetic exceptions. PS reflects the pre-exception state. IPL = 7, CM = KERNEL, shadow registers active.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Key invariants tested:<\/strong> No younger instruction commits (flushYoungerSlots verified), no partial memory effects survive (faulting store never reaches SafeMemory, faulting load never writes result register), LL\/SC reservations are cleared on delivery, and HW_REI restores state exactly (full register-context vector copy verified).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-18---fault-dispatcher-.html\" class=\"topiclink\">Chapter 18 – Fault Dispatcher &amp; Precise Exceptions<\/a> (delivery mechanics under validation).<\/span><\/p>\n\r"
})
