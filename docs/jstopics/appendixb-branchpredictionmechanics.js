hmLoadTopic({
hmKeywords:"Accuracy,AXP_HOT,Backward,BEQ,BGT,BHT,Bimodal,BR,Branch,BranchPredictor,BranchPredictor.h,BranchStrategy,BSR,BTB,CBox,CBoxLib,Conditional,ContextSwitch,COROUTINE,Counter,DisplacementBased,Entry,flushPredictionState,Forward,getPredictedTarget,GlobalHistory,Gshare,Hash,HistoryTable,HitRate,ICCSR,Indirect,JMP,JSR,Loop,Misprediction,NeverTaken,Penalty,Prediction,predictTaken,queryPrediction,RAS,recordBranchResolution,recordPrediction,RET,ReturnAddressStack,Saturating,SetAssociative,Statistics,Strategy,StronglyNotTaken,StronglyTaken,Tournament,Training,Unconditional,updatePrediction,WeaklyNotTaken,WeaklyTaken",
hmTitle:"Appendix J – Branch Prediction Mechanics",
hmDescription:"This appendix describes the branch prediction subsystem implemented by CBox and BranchPredictor. Chapter 13.11 describes how the pipeline consumes, resolves, and trains...",
hmPrevLink:"appendix-h---endianness-rules.html",
hmNextLink:"appendixc-physicaladdressmemorymap.html",
hmParentLink:"appendix---trait-examples.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"appendix---trait-examples.html\">Appendix<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Appendix > Appendix B - Branch Prediction Mechanics",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">Appendix J – Branch Prediction Mechanics<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">This appendix describes the branch prediction subsystem implemented by CBox and BranchPredictor. Chapter 13.11 describes how the pipeline consumes, resolves, and trains predictions; this appendix documents the predictor structures, strategies, interface, and expected performance.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">J.1 Architecture<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">CBox (CBoxLib\/) owns a BranchPredictor instance (BranchPredictor.h). CBox provides the pipeline-facing interface; BranchPredictor contains the prediction structures and algorithms. CBox follows the same construction pattern as PalBox — it receives CPUIdType, HWPCBBank*, and IPRStorage_HotExt* from ExecutionCoordinator and does not own these resources.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The predictor operates independently per CPU. In SMP configurations, each CPU has its own CBox and BranchPredictor with no shared state. Context switches flush predictor state via <span class=\"f_CodeExample\">flushPredictionState()<\/span>.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">J.2 Prediction Structures<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Branch History Table (BHT)<\/strong><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">512 entries, 2-way set associative. Each entry contains a 2-bit saturating counter that tracks the recent behavior of the branch at that address. The counter encodes four states:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Value<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">State<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Prediction<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Transition on Taken<\/strong><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">00<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Strongly not-taken<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Not-taken<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">→ 01 (weakly not-taken)<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">01<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Weakly not-taken<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Not-taken<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">→ 10 (weakly taken)<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">10<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Weakly taken<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Taken<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">→ 11 (strongly taken)<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">11<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Strongly taken<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Taken<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">→ 11 (saturates)<\/p>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">On a not-taken outcome, the counter decrements (saturates at 00). Prediction is &quot;taken&quot; when counter &gt;= 2 (bit 1 set). The 2-bit design tolerates one anomalous outcome without changing the prediction — a loop that iterates 100 times and exits once will be correctly predicted 99% of the time.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">BHT indexing: the entry is selected by hashing the branch PC. The 2-way set associativity allows two branches that hash to the same index to coexist without aliasing. Power-of-2 sizing enables efficient masking (index = hash &amp; 0x1FF).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Branch Target Buffer (BTB)<\/strong><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1024 entries. Each entry stores a PC → target address mapping. When the BHT predicts &quot;taken,&quot; the BTB provides the target address. BTB entries are updated when a branch resolves as taken — the actual target is written into the BTB. For not-taken branches, no BTB update occurs (the sequential PC+4 is used).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Global History Register<\/strong><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">16-bit shift register recording the taken\/not-taken outcome of the last 16 branches. Each branch outcome shifts in from the right: <span class=\"f_CodeExample\">m_globalHistory = (m_globalHistory &lt;&lt; 1) | taken<\/span>. The global history register is maintained for future use by advanced prediction strategies (gshare, tournament). The current HistoryTable strategy does not use global history for index computation.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">J.3 Prediction Strategies<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The active prediction strategy is controlled by the ICCSR (Implementation-Specific Control and Status Register) branch prediction mode bits. CBox provides <span class=\"f_CodeExample\">setStrategy(BranchStrategy)<\/span> to change the active strategy at runtime (typically during ICCSR writes). Three strategies are implemented:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">NeverTaken<\/strong> (ICCSR mode 0) — always predicts not-taken. Every branch fetches sequentially from PC+4. Useful as a baseline for measuring predictor benefit. Hit rate: ~30–40% for typical workloads (most loops are backward branches that are usually taken).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">DisplacementBased<\/strong> (ICCSR mode 1) — predicts taken if the branch displacement is negative (backward branch), not-taken if positive (forward branch). This is a static heuristic: backward branches are typically loop-closing branches that are taken on all but the final iteration. No BHT state is used. Hit rate: ~65–75% for typical workloads.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">HistoryTable<\/strong> (ICCSR mode 2, default) — uses the BHT 2-bit saturating counter to predict taken\/not-taken, and the BTB for target address. This is a dynamic strategy that learns from runtime behavior. Hit rate: ~85–95% for typical workloads, varying by branch type (see Section J.5).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">J.4 CBox Public Interface<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">All prediction hot-path methods are marked <span class=\"f_CodeExample\">AXP_HOT AXP_ALWAYS_INLINE<\/span> to eliminate call overhead. CBox avoids virtual function calls on all critical paths.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">queryPrediction(pc, outPredictedTarget) → bool<\/span><\/p>\n\r<p class=\"p_Normal\">Called by IBox during fetch. Checks BHT for taken\/not-taken, looks up BTB for the target if taken. Returns true if a taken prediction with valid target is available. Marked <span class=\"f_CodeExample\">AXP_HOT<\/span>.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">predictTaken(pc, displacement) → bool<\/span><\/p>\n\r<p class=\"p_Normal\">Lower-level interface. Returns the taken\/not-taken prediction for the given PC using the active strategy. Delegates directly to <span class=\"f_CodeExample\">BranchPredictor::predict()<\/span>. Marked <span class=\"f_CodeExample\">AXP_HOT AXP_ALWAYS_INLINE<\/span>.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">getPredictedTarget(pc) → quint64<\/span><\/p>\n\r<p class=\"p_Normal\">Returns the BTB-cached target address for the given PC. Marked <span class=\"f_CodeExample\">AXP_HOT<\/span>.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">recordPrediction(pc, predictedTarget)<\/span><\/p>\n\r<p class=\"p_Normal\">Called by IBox after making a speculative prediction. Updates BTB with the predicted target, increments prediction statistics, updates global history. Marked <span class=\"f_CodeExample\">AXP_HOT AXP_FLATTEN<\/span>.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">recordBranchResolution(pc, actualTarget, wasTaken, wasPredicted, predictedCorrectly)<\/span><\/p>\n\r<p class=\"p_Normal\">Called by the pipeline in stage_WB() at retirement. Trains the BHT (increments or decrements the saturating counter), updates BTB with actual target if taken, updates prediction accuracy statistics, and updates global history with the actual outcome. This is the sole training entry point — all predictor learning happens here.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">flushPredictionState()<\/span><\/p>\n\r<p class=\"p_Normal\">Clears all prediction state: invalidates all BHT entries, invalidates all BTB entries, clears global history register, resets all counters to weakly not-taken (01). Called on context switch and pipeline flush from PAL mode. After flush, the predictor cold-starts — all branches will initially be predicted not-taken until training rebuilds the tables.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">setStrategy(BranchStrategy)<\/span><\/p>\n\r<p class=\"p_Normal\">Changes the active prediction strategy. Called when ICCSR branch prediction mode bits are written. Takes effect immediately for the next prediction.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">getStatistics() \/ resetStatistics()<\/span><\/p>\n\r<p class=\"p_Normal\">Returns or resets cumulative prediction statistics: totalPredictions, correctPredictions, incorrectPredictions, and computed accuracy().<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">J.5 Expected Hit Rates by Branch Type<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The following hit rates are expected for the HistoryTable strategy under typical workloads. These are design targets derived from published EV6 branch prediction literature and empirical measurement of the 2-bit saturating counter scheme.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Branch Type<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Instructions<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Expected Hit Rate<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Notes<\/strong><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Unconditional direct<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">BR, BSR<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">100%<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Target known at decode, no prediction needed<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Backward conditional (loops)<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">BNE, BGT, etc.<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">95%+<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Strongly biased taken; 2-bit counter saturates quickly<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Forward conditional<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">BEQ, BLE, etc.<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">80–90%<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">More variable; error handling branches bias not-taken<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Function call (direct)<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">BSR<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">100%<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Unconditional, target at decode<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Function return<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">RET<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">~60% (BTB only)<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Indirect target varies by call site; RAS would improve to ~98%<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Indirect jump<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">JMP, JSR, COROUTINE<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">~50–70%<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Target varies; BTB caches last target only<\/p>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Aggregate:<\/strong> Across a typical workload mix (integer-heavy, moderate branching), the HistoryTable strategy is expected to achieve 85–93% overall accuracy. The primary sources of misprediction are indirect jumps (switch statements, virtual calls) and loop exit branches (the single misprediction when a loop terminates).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Misprediction cost:<\/strong> Each misprediction invalidates up to 3 pipeline stages (IF, DE, IS), wasting the cycles spent fetching and decoding the wrongly-predicted instruction stream. With a 6-stage pipeline, the maximum penalty is 3 cycles per misprediction.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">J.6 Prediction Flow<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The complete prediction lifecycle across the pipeline:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">IBox&nbsp;fetch:&nbsp;detect&nbsp;branch&nbsp;in&nbsp;decoded&nbsp;instruction<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;↓<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">IBox&nbsp;→&nbsp;CBox::queryPrediction(branchPC,&nbsp;outTarget)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;↓&nbsp;BHT&nbsp;lookup&nbsp;→&nbsp;taken\/not-taken<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;↓&nbsp;BTB&nbsp;lookup&nbsp;→&nbsp;predicted&nbsp;target&nbsp;(if&nbsp;taken)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;↓<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">IBox&nbsp;→&nbsp;CBox::recordPrediction(branchPC,&nbsp;predictedTarget)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;↓&nbsp;Updates&nbsp;statistics,&nbsp;global&nbsp;history<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;↓<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">IBox&nbsp;populates&nbsp;FetchResult:&nbsp;predTaken,&nbsp;predTarget<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;↓<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">stage_IF:&nbsp;transfers&nbsp;prediction&nbsp;into&nbsp;PipelineSlot<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;↓<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">stage_EX:&nbsp;grain&nbsp;resolves&nbsp;actual&nbsp;branch&nbsp;outcome<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;↓&nbsp;Sets&nbsp;slot.branchTaken,&nbsp;slot.branchTarget<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;↓&nbsp;Compares&nbsp;actual&nbsp;vs&nbsp;predicted<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;↓&nbsp;If&nbsp;mismatch&nbsp;→&nbsp;slot.flushPipeline&nbsp;=&nbsp;true<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;↓<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">stage_WB:&nbsp;retirement<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;↓<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Pipeline&nbsp;→&nbsp;CBox::recordBranchResolution(pc,&nbsp;target,&nbsp;taken,&nbsp;...)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;↓&nbsp;BHT&nbsp;counter&nbsp;increment\/decrement&nbsp;(training)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;↓&nbsp;BTB&nbsp;update&nbsp;(if&nbsp;taken)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;↓&nbsp;Statistics&nbsp;update<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;↓&nbsp;Global&nbsp;history&nbsp;update<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">J.7 Implementation Details<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Cache friendliness:<\/strong> BHT and BTB are contiguous arrays (not linked structures). Power-of-2 sizing enables efficient index masking. The 2-way set-associative BHT uses simple linear probing within each set.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Hot path optimization:<\/strong> <span class=\"f_CodeExample\">predictTaken()<\/span> and <span class=\"f_CodeExample\">getPredictedTarget()<\/span> are marked <span class=\"f_CodeExample\">AXP_HOT AXP_ALWAYS_INLINE<\/span>. <span class=\"f_CodeExample\">recordPrediction()<\/span> is marked <span class=\"f_CodeExample\">AXP_HOT AXP_FLATTEN<\/span>. The hash function is <span class=\"f_CodeExample\">AXP_ALWAYS_INLINE<\/span>. All critical paths avoid virtual function calls.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Debug support:<\/strong> <span class=\"f_CodeExample\">DEBUG_BRANCH_PREDICTION<\/span> compile-time flag enables detailed per-branch logging. Statistics tracking is always enabled with minimal overhead. Statistics can be queried via <span class=\"f_CodeExample\">getStatistics()<\/span> and reset via <span class=\"f_CodeExample\">resetStatistics()<\/span>.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Context switch behavior:<\/strong> <span class=\"f_CodeExample\">flushPredictionState()<\/span> is called on context switch. All BHT and BTB entries are invalidated. Counters reset to weakly not-taken (01). The predictor cold-starts for the new process. This prevents stale predictions from the previous process from causing systematic mispredictions in the new process.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">J.8 EV6 Comparison and Future Enhancements<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The current implementation is a simplified model of the EV6 branch prediction subsystem. The following table compares the emulator\'s predictor against the documented EV6 hardware:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Feature<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">EV6 Hardware<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">ASA-EMulatR<\/strong><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">BHT entries<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">4096<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">512 (2-way)<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">BTB entries<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">2048<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">1024<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Local history predictor<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">4096-entry, 10-bit history<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Not implemented<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Global history bits<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">12<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">16 (maintained, not yet used for indexing)<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Return Address Stack<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">8-entry<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Not implemented<\/p>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Planned enhancements:<\/strong><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Return Address Stack (RAS)<\/strong> — an 8-entry stack dedicated to JSR\/RET prediction. JSR pushes PC+4 onto the stack; RET pops the predicted return address. This would improve RET prediction from ~60% to ~98%, as function return targets follow a strict LIFO pattern.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Gshare predictor<\/strong> — XOR the PC with global history to index the BHT. This captures correlations between branches (e.g., if branch A was taken, branch B is likely not-taken). Relatively simple to implement using the existing global history register.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Tournament predictor<\/strong> — run multiple prediction schemes in parallel with a meta-predictor that selects the most accurate scheme for each branch. The EV6 hardware uses a tournament between local and global predictors; this is the most architecturally accurate enhancement.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Indirect branch predictor<\/strong> — a specialized predictor for computed jumps (switch statements, virtual method dispatch) that tracks multiple targets per PC rather than the single BTB entry used today.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">These enhancements are not required for architectural correctness — misprediction affects performance modeling only, never program behavior. The emulator guarantees correct execution regardless of prediction accuracy.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"13_11-branch-handling.html\" class=\"topiclink\">13.11 Branch Handling<\/a> &nbsp;(pipeline integration); <a href=\"chapter-14---execution-domains.html\" class=\"topiclink\">Chapter 14 – Execution Domains (“Boxes”)<\/a> &nbsp;(CBox role); CBoxLib\/BranchPredictor.h (source); Alpha 21264\/EV6 Hardware Reference Manual, Section 2.5 (branch prediction).<\/span><\/p>\n\r"
})
