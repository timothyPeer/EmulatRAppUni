hmLoadTopic({
hmKeywords:"",
hmTitle:"G.2 – Instruction Inventory (GrainMaster.tsv))))",
hmDescription:"The GrainMaster.tsv file (grainfactoryLib\/grains\/GrainMaster.tsv) is the master opcode table containing 616 entries that define every instruction the emulator supports. Each...",
hmPrevLink:"g_1-decodedinstructionquickreference.html",
hmNextLink:"g_3-grainmaster_tsv.html",
hmParentLink:"appendixg-instructiongrainmechanics.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"appendix---trait-examples.html\">Appendix<\/a> &gt; <a href=\"appendixg-instructiongrainmechanics.html\">Appendix G - Instruction Grain Mechanics<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Appendix > Appendix G - Instruction Grain Mechanics > G.2 – Instruction Inventory (GrainMaster.tsv)",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">G.2 – Instruction Inventory (GrainMaster.tsv))))<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">The <span class=\"f_CodeExample\">GrainMaster.tsv<\/span> file (<span class=\"f_CodeExample\">grainfactoryLib\/grains\/GrainMaster.tsv<\/span>) is the master opcode table containing 616 entries that define every instruction the emulator supports. Each row specifies opcode, function code, mnemonic, description, instruction type, and target box. The Python tooling (<span class=\"f_CodeExample\">generate_all_grains.py<\/span>) reads this TSV and generates C++ registration code that populates the <span class=\"f_CodeExample\">InstructionGrainRegistry<\/span> at startup.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Instruction distribution by box:<\/strong><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Box<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Category<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Scope<\/strong><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">EBox<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Integer ALU, shift, compare, conditional move, multimedia<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Largest instruction count — integer operate instructions<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">FBox<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">IEEE and VAX floating-point arithmetic, conversions, FPCR<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">All FP operations with trap mode variants<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">MBox<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Load, store, prefetch, LDx_L\/STx_C, unaligned access<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">All memory data path instructions<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">CBox<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">MB, WMB, EXCB, TRAPB, ECB, WH64, FETCH\/FETCH_M<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Barrier, cache hint, and serialization instructions<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">IBox<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Branch, jump, BSR, RET, COROUTINE<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Control flow instructions decoded at fetch<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">PalBox<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">~80 PAL functions: CALL_PAL, MFPR_*\/MTPR_*, HALT, SWPCTX, CHMx, queue ops, etc.<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">All privileged and unprivileged PAL calls<\/p>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Generation pipeline:<\/strong> <span class=\"f_CodeExample\">GrainMaster.tsv<\/span> → <span class=\"f_CodeExample\">generate_all_grains.py<\/span> → C++ grain registration code → <span class=\"f_CodeExample\">InstructionGrainRegistry::instance().grainCount()<\/span> reports total registered grains at startup. The grain resolver (<span class=\"f_CodeExample\">GrainResolver<\/span>) uses the registry for instruction decode: opcode + function code → grain pointer → <span class=\"f_CodeExample\">execute()<\/span>.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: grainfactoryLib\/grains\/GrainMaster.tsv; grainfactoryLib\/generate_all_grains.py; <a href=\"chapter-14---execution-domains.html\" class=\"topiclink\">Chapter 14 – Execution Domains (“Boxes”)<\/a> .<\/span><\/p>\n\r"
})
