hmLoadTopic({
hmKeywords:"",
hmTitle:"10.6 MMIO Access Semantics",
hmDescription:"10.6.1 Strong Ordering Rules  MMIO accesses are strongly ordered: no reordering, no buffering, no speculation, no combining, no deferral. Every MMIO read or write completes...",
hmPrevLink:"10_4-mmio-address-space.html",
hmNextLink:"10_6-device-registers.html",
hmParentLink:"chapter-10---devices-and-mmio.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-10---devices-and-mmio.html\">Chapter 10 – Devices and Memory-Mapped I\/O (MMIO)<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 10 – Devices and Memory-Mapped I\/O (MMIO) > 10.6 MMIO Access Semantics",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">10.6 MMIO Access Semantics<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">10.6.1 Strong Ordering Rules<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">MMIO accesses are strongly ordered: no reordering, no buffering, no speculation, no combining, no deferral. Every MMIO read or write completes synchronously, is visible immediately, and observes program order. This prevents device protocol violations.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">MMIO writes bypass the write buffer entirely — they are committed directly through GuestMemory → MMIOManager → device handler, not deferred via WriteBufferManager.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">10.6.2 Pipeline Behavior<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">MMIO access occurs during the EX stage via MBox. The instruction executes synchronously, the pipeline may stall for the duration, the result is returned immediately, and no write buffer is used. MMIO instructions retire only after the access completes.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">10.6.3 MMIOStatus Return Codes<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Device handlers return MMIOStatus to indicate success or failure:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">enum&nbsp;class&nbsp;MMIOStatus&nbsp;:&nbsp;quint8&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;OK&nbsp;=&nbsp;0x0,&nbsp;\/\/&nbsp;Success<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;ALIGNMENT_FAULT,&nbsp;\/\/&nbsp;Unaligned&nbsp;access<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;BUS_ERROR,&nbsp;\/\/&nbsp;Fatal&nbsp;bus&nbsp;error&nbsp;(machine&nbsp;check)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;DEVICE_ERROR,&nbsp;\/\/&nbsp;Device-level&nbsp;error<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;INVALID_ADDRESS,&nbsp;\/\/&nbsp;No&nbsp;device&nbsp;at&nbsp;address<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;PERMISSION_DENIED,&nbsp;\/\/&nbsp;Read-only\/write-only&nbsp;violation<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;READ_ONLY,&nbsp;\/\/&nbsp;Write&nbsp;to&nbsp;read-only&nbsp;register<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;SIZE_VIOLATION,&nbsp;\/\/&nbsp;Wrong&nbsp;access&nbsp;size<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;TIMEOUT,&nbsp;\/\/&nbsp;Device&nbsp;did&nbsp;not&nbsp;respond<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;UNIMPL,&nbsp;\/\/&nbsp;Register&nbsp;not&nbsp;implemented<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;WIDTH_FAULT,&nbsp;\/\/&nbsp;Unsupported&nbsp;width<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;WRITE_ONLY&nbsp;\/\/&nbsp;Read&nbsp;from&nbsp;write-only&nbsp;register<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">};<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Non-OK status codes are translated to appropriate faults (bus error, alignment fault, access violation) by the memory system and delivered through the normal exception path.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">10.6.4 MMIOWindow Access Attributes<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Each MMIO window carries fine-grained access attributes set during resource allocation:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">allowedWidths — bitmask: 0x01=byte, 0x02=word, 0x04=long, 0x08=quad<\/p>\n\r<p class=\"p_Normal\">stronglyOrdered — serialize all accesses in MMIOManager (true for all MMIO by default)<\/p>\n\r<p class=\"p_Normal\">sideEffectOnRead — read has side effects (FIFO pop, clear-on-read ISR)<\/p>\n\r<p class=\"p_Normal\">sideEffectOnWrite — write has side effects (doorbell, FIFO push, command start)<\/p>\n\r<p class=\"p_Normal\">regEndian — register endianness (Little\/Big)<\/p>\n\r<p class=\"p_Normal\">cachePolicy — always Uncacheable for MMIO<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: coreLib\/mmio_core.h (MMIOStatus, MMIOWindow).<\/span><\/p>\n\r"
})
