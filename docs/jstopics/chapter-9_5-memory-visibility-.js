hmLoadTopic({
hmKeywords:"",
hmTitle:"9.5 Memory Visibility in SMP",
hmDescription:"9.5.1 Default Behavior  By default, stores may be buffered per-CPU (in WriteBufferManager), loads may observe stale values, and CPUs may see memory changes at different times....",
hmPrevLink:"chapter-9_4-per-cpu-vs-shared-.html",
hmNextLink:"chapter-9_6-write-buffers-in-s.html",
hmParentLink:"chapter9-smparchitecture.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter9-smparchitecture.html\">Chapter 9 - SMP Architecture<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 9 - SMP Architecture > 9.5 Memory Visibility in SMP",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">9.5 Memory Visibility in SMP<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">9.5.1 Default Behavior<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">By default, stores may be buffered per-CPU (in WriteBufferManager), loads may observe stale values, and CPUs may see memory changes at different times. This behavior is architecturally correct — Alpha AXP\'s weak ordering model makes no guarantees about cross-CPU visibility without explicit barriers.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">9.5.2 Enforcing Visibility<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Visibility is enforced via MB (full memory barrier — drains local write buffer + global coordination), WMB (write barrier — drains local buffer only, no global coordination), EXCB\/TRAPB (exception\/trap precision), PAL transitions (implicit full serialization, global coordination for PAL-kind barriers), and certain device operations (MMIO writes bypass write buffer entirely).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">When a barrier completes, prior stores become globally visible (committed to GuestMemory), prior loads are ordered appropriately, and other CPUs will observe changes on their next access.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">9.5.3 Write Buffers in SMP<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Each CPU maintains its own logical write buffer via CBox → WriteBufferManager. There is no global write buffer. Stores retire from the pipeline before becoming globally visible. Buffers drain asynchronously, on barriers, and on PAL transitions. Buffers do not block other CPUs. ExecutionCoordinator::drainAllWriteBuffers() is available for system-wide operations (shutdown, halt).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: Section 5.9 – Write Buffers; Section 6.7 – MB; Section 6.8 – WMB.<\/span><\/p>\n\r"
})
