hmLoadTopic({
hmKeywords:"",
hmTitle:"20.5 Shadow Registers and HWPCB",
hmDescription:"20.5.1 PAL Shadow Registers  When PAL mode is entered, shadow registers are activated providing a separate register workspace for PAL code. PAL shadow registers substitute for...",
hmPrevLink:"20_4-pal-mode-entry-and-exit.html",
hmNextLink:"20_6-privileged-instructions.html",
hmParentLink:"chapter-20---boot-sequence_-pa.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-20---boot-sequence_-pa.html\">Chapter 20 – Boot Sequence, PAL, and SRM Integration<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 20 – Boot Sequence, PAL, and SRM Integration > 20.5 Shadow Registers and HWPCB",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">20.5 Shadow Registers and HWPCB<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">20.5.1 PAL Shadow Registers<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">When PAL mode is entered, shadow registers are activated providing a separate register workspace for PAL code. PAL shadow registers substitute for R8–R14 and R25 during PAL mode execution. This allows PAL code to use these registers without saving\/restoring the interrupted context\'s values — the hardware shadow bank automatically preserves the non-PAL register state.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Shadow registers are activated on <span class=\"f_CodeExample\">enterPal()<\/span> (<span class=\"f_CodeExample\">m_shadowRegsActive = true<\/span>) and deactivated on <span class=\"f_CodeExample\">executeREI()<\/span>. The execution engine checks the shadow register flag and routes register accesses to the appropriate bank. Shadow registers preserve state while the CPU is quiesced and enable efficient nested exception handling.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">20.5.2 HWPCB (Hardware Privileged Context Block)<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The HWPCB (<span class=\"f_CodeExample\">HWPCB_core.h<\/span>) is the per-CPU hardware process context block that holds the complete architectural state of a process. PAL entry captures full architectural state via <span class=\"f_CodeExample\">saveContext()<\/span> into the HWPCB, and HW_REI restores full architectural state via <span class=\"f_CodeExample\">restoreContext()<\/span> from the HWPCB. No partial restoration is permitted.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">HWPCB fields include: the architectural PC, processor status (PS), current mode (CM), IPL, ASN, stack pointers for all four modes (KSP, ESP, SSP, USP), AST registers (ASTEN, ASTER, ASTRR, ASTSR), FP enable (FEN), PCBB (PCB base address), PTBR (page table base), SCBB (system control block base), VPTB (virtual page table base), PRBR, SYSPTBR, MCES, and exception state (EXC_ADDR, EXC_SUM).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">HWPCBBank<\/span> (<span class=\"f_CodeExample\">globalHWPCBBank()<\/span>) manages per-CPU HWPCB instances. It is initialized during system construction via <span class=\"f_CodeExample\">globalHWPCBBank().init(numCpus)<\/span>. HWPCB state must be saved\/restored across context switches (SWPCTX), and all four AST registers are part of process context.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">20.5.3 Context Switch (SWPCTX)<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The SWPCTX PAL call coordinates process context switching. It saves the current process state to the outgoing HWPCB, loads the incoming process state from the new HWPCB (pointed to by R16), updates the active PCBB, clears LL\/SC reservations, and flushes per-process caches (PC and PA decode caches are flushed via IMB-equivalent behavior). ASN management during context switches uses the epoch-based lazy invalidation mechanism described in Chapter 17 — if the incoming process\'s ASN has a stale epoch, non-global TLB entries are invalidated.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: HWPCB_core.h – HWPCB field definitions; <a href=\"chapter-8_6-pal-and-exceptions.html\" class=\"topiclink\">8.6 PAL Execution Model<\/a> (shadow registers); <a href=\"17_7-asn-management-and-cohere.html\" class=\"topiclink\">17.7 ASN Management and Coherence<\/a> (epoch-based invalidation).<\/span><\/p>\n\r"
})
