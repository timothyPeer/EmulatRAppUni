hmLoadTopic({
hmKeywords:"",
hmTitle:"Chapter 20 – PAL Emulation & Boot Sequence",
hmDescription:"This chapter describes the implementation of the ASA-EmulatR Privileged Architecture Library (PAL) emulation layer and the boot sequence that brings the system from reset to...",
hmPrevLink:"19_9-repository-directory-mapp.html",
hmNextLink:"20_1-palbox-execution-domain.html",
hmParentLink:"architecture-overview.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 20 – Boot Sequence, PAL, and SRM Integration",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">Chapter 20 – PAL Emulation &amp; Boot Sequence<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">This chapter describes the implementation of the ASA-EmulatR Privileged Architecture Library (PAL) emulation layer and the boot sequence that brings the system from reset to the SRM console prompt. Where Chapter 8 defines the architectural contract — what PAL is, how privilege is enforced, entry\/exit semantics — this chapter covers the concrete PalBox execution domain, PalService delegation model, CALL_PAL dispatch, shadow register management, HWPCB context handling, privileged instruction implementation, CSERVE console services, and the phased boot sequence.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">A key design decision: ASA-EmulatR implements PAL as C++ code executed through <span class=\"f_CodeExample\">PalService<\/span> methods, not as Alpha instructions stored in memory. <span class=\"f_CodeExample\">CALL_PAL<\/span> instructions execute C++ handlers via <span class=\"f_CodeExample\">PalBoxBase<\/span> → <span class=\"f_CodeExample\">PalService<\/span> delegation. There is no PAL code stored in GuestMemory — this eliminates an entire class of memory synchronization issues while faithfully implementing the architectural interface.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Scope:<\/span> This chapter covers PalBox responsibilities and architecture, PalService delegation, CALL_PAL dispatch and vector calculation, PAL mode entry and exit (enterPal\/HW_REI), shadow registers, HWPCB context management, privileged instructions (HW_MFPR\/HW_MTPR\/HW_LD\/HW_ST), CSERVE console services, the SRM boot sequence, and the PAL function inventory. It does not re-cover the architectural privilege model (Chapter 8), fault delivery mechanics (Chapter 18), or interrupt delivery (Chapter 19).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-8---pal-and-privleged-.html\" class=\"topiclink\">Chapter 8 - PAL and Privileged Boundary<\/a> (architectural contract); <a href=\"14_6-palbox---privileged-archi.html\" class=\"topiclink\">14.6 PalBox – Privileged Architecture Library Execution Box<\/a> (box overview); <a href=\"chapter-18---fault-dispatcher-.html\" class=\"topiclink\">Chapter 18 – Fault Dispatcher &amp; Precise Exceptions<\/a> (event delivery to PAL).<\/span><\/p>\n\r"
})
