hmLoadTopic({
hmKeywords:"",
hmTitle:"17.6 Replacement Policies",
hmDescription:"TemplatePolicyBase.h defines the base classes and policies for cache replacement and invalidation strategies used by SPAMShardManager and SPAMBucket. When a TLB insert requires...",
hmPrevLink:"17_5-ev6silicontlb-and-layer-a.html",
hmNextLink:"17_7-asn-management-and-cohere.html",
hmParentLink:"chapter-17---tlb_-pte_-and-add.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-17---tlb_-pte_-and-add.html\">Chapter 17 – Address Translation, TLB, and PTE<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 17 – Address Translation, TLB, and PTE > 17.6 Replacement Policies",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">17.6 Replacement Policies<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\"><span class=\"f_CodeExample\">TemplatePolicyBase.h<\/span> defines the base classes and policies for cache replacement and invalidation strategies used by <span class=\"f_CodeExample\">SPAMShardManager<\/span> and <span class=\"f_CodeExample\">SPAMBucket<\/span>. When a TLB insert requires evicting an existing entry, the replacement policy selects the victim.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">17.6.1 Available Policies<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Policy<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Description<\/strong><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">SRRIPPolicy<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Static Re-Reference Interval Prediction. Assigns a re-reference prediction value to each entry; evicts the entry predicted to be re-referenced furthest in the future. Balances recency and frequency. Preferred for workloads with mixed locality.<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">ClockPolicy<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Clock-based (second-chance) replacement. A circular pointer sweeps through entries, clearing reference bits. Entries with cleared reference bits are evicted. Low overhead, good for uniform access patterns.<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">RandomPolicy<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Random victim selection. Minimal overhead, useful as a baseline and for workloads where access patterns are unpredictable.<\/p>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">All policies inherit from <span class=\"f_CodeExample\">ReplacementPolicyBase<\/span>, which defines the victim selection interface. The <span class=\"f_CodeExample\">DefaultInvalidationStrategy<\/span> provides the default invalidation behavior. Custom policies can be supplied by providing alternative implementations of <span class=\"f_CodeExample\">ReplacementPolicyBase<\/span>.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">17.6.2 Policy Selection<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The replacement policy is a template parameter to <span class=\"f_CodeExample\">SPAMShardManager<\/span>, selected at compile time. The <span class=\"f_CodeExample\">ReplacementPolicyEnum<\/span> in <span class=\"f_CodeExample\">TemplatePolicyBase.h<\/span> enumerates the supported options. The default is <span class=\"f_CodeExample\">SRRIPPolicy<\/span>, which provides the best balance of hit rate and overhead for typical OS workloads (multi-process, context-switching, mixed kernel\/user access).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: pteLib\/TemplatePolicyBase.h – Replacement and invalidation policy definitions; Appendix: Cache Replacement and Invalidation Policies.<\/span><\/p>\n\r"
})
