hmLoadTopic({
hmKeywords:"",
hmTitle:"22.7 Device and DMA Validation",
hmDescription:"Device validation focuses on the contract between devices and the architectural execution model.",
hmPrevLink:"22_6-pal-and-privilege-boundar.html",
hmNextLink:"22_8-regression-testing-policy.html",
hmParentLink:"chapter-22---testing_-validati.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-22---testing_-validati.html\">Chapter 22 – Testing, Validation, and Architectural Compliance<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 22 – Testing, Validation, and Architectural Compliance > 22.7 Device and DMA Validation",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">22.7 Device and DMA Validation<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">Device validation focuses on the contract between devices and the architectural execution model.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">MMIO ordering:<\/span> MMIO reads and writes respect the memory ordering model. Stores to MMIO regions are visible in program order after barriers. Device state changes are visible to the CPU only through architecturally defined paths (MMIO reads, interrupt delivery).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">DMA correctness:<\/span> DMA transfers write to GuestMemory through SafeMemory, producing the same visibility semantics as CPU stores. DMA completion signals arrive through the interrupt system. DMA + barrier interactions are verified (CPU stores before MB are visible to DMA engines, DMA stores before completion interrupt are visible to CPU after interrupt delivery).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Interrupt signaling:<\/span> Device interrupts assert through <span class=\"f_CodeExample\">IRQPendingState<\/span> and follow the standard delivery path. Interrupt masking by IPL is respected. Interrupt acknowledgment clears the pending state correctly. SMP DMA visibility (DMA completion on one CPU visible to another after barrier) is verified.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Devices must never:<\/span> Stall the CPU pipeline (devices execute on separate threads), bypass memory ordering rules (all device memory access goes through SafeMemory), or inject interrupts outside the IRQPendingState path.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">MMIO bugs are ordering bugs until proven otherwise — device validation always traces MMIO reads\/writes with CPU ID and correlates with barrier events.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-16---device-model--dma.html\" class=\"topiclink\">Chapter 16 – Device Model &amp; DMA<\/a> (device architecture under test); <a href=\"chapter-15---memory-system-imp.html\" class=\"topiclink\">Chapter 15 – Memory System Implementation Details<\/a> &nbsp;(SafeMemory and write buffer behavior).<\/span><\/p>\n\r"
})
