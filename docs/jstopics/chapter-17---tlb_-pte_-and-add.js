hmLoadTopic({
hmKeywords:"",
hmTitle:"Chapter 17 – Address Translation, TLB, and PTE",
hmDescription:"This chapter describes the implementation of address translation in EMulatR: how virtual addresses are converted to physical addresses, how TLB caches are organized and...",
hmPrevLink:"16_12-repository-directory-map.html",
hmNextLink:"17_1-alpha-virtual-address-for.html",
hmParentLink:"architecture-overview.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 17 – Address Translation, TLB, and PTE",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">Chapter 17 – Address Translation, TLB, and PTE<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">This chapter describes the implementation of address translation in EMulatR: how virtual addresses are converted to physical addresses, how TLB caches are organized and managed, how Page Table Entries (PTEs) are represented and manipulated, and how SMP coherence is maintained across per-CPU translation buffers. Where Chapter 5 defines the architectural contract for the memory system and Chapter 14 describes MBox as the execution domain that initiates translation, this chapter covers the concrete classes and data structures that implement the VA→PA path.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The translation subsystem is organized in three layers. Layer 0 (<strong style=\"font-weight: bold;\">silicon<\/strong>) provides the raw TLB storage and lookup via <span class=\"f_CodeExample\">SPAMShardManager<\/span> and <span class=\"f_CodeExample\">SPAMBucket<\/span> — these know nothing about page tables or miss handling. Layer 1 (<strong style=\"font-weight: bold;\">TLB interface<\/strong>) wraps Layer 0 with the <span class=\"f_CodeExample\">Ev6SiliconTLB<\/span> and <span class=\"f_CodeExample\">Ev6TLBInterface<\/span> classes, providing lookup, insert, and invalidate operations without trait or page-table knowledge. Layer 2 (<strong style=\"font-weight: bold;\">PAL \/ MMU \/ miss handling<\/strong>) performs page table walks on TLB miss, raises translation faults (TNV, FOE, FOW, FOR), and calls Layer 1 insert to refill the TLB.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Scope:<\/strong> This chapter covers PTE representation (<span class=\"f_CodeExample\">AlphaPTE<\/span>, <span class=\"f_CodeExample\">PTETraits<\/span>, <span class=\"f_CodeExample\">PTEView<\/span>), TLB cache organization (<span class=\"f_CodeExample\">SPAMShardManager<\/span>, <span class=\"f_CodeExample\">SPAMBucket<\/span>), the <span class=\"f_CodeExample\">Ev6SiliconTLB<\/span> singleton, translation paths (<span class=\"f_CodeExample\">ev6TranslateFastVA<\/span>, <span class=\"f_CodeExample\">ev6TranslateFullVA<\/span>), replacement policies, TLB invalidation and SMP shootdown, ASN management, and the dual DTB architecture. It does not cover fault dispatch mechanics (Chapter 18) or interrupt delivery (Chapter 19).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-5---memory-system-arch.html\" class=\"topiclink\">Chapter 5 - Memory System Architecture<\/a> (architectural contract, VA format); <a href=\"chapter-14---execution-domains.html\" class=\"topiclink\">Chapter 14 – Execution Domains (“Boxes”)<\/a> (MBox translation initiation); <a href=\"chapter-15---memory-system-imp.html\" class=\"topiclink\">Chapter 15 – Memory System Implementation Details<\/a>;  <a href=\"chapter-15---memory-system-imp.html\" class=\"topiclink\">Chapter 15 – Memory System Implementation Details<\/a> (GuestMemory PA routing).<\/span><\/p>\n\r"
})
