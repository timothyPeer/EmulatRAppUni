hmLoadTopic({
hmKeywords:"",
hmTitle:"3.2 Overview of the Pipeline Model",
hmDescription:"EMulatR implements a six-stage, in-order Alpha AXP pipeline optimized for clarity, correctness, and determinism. The pipeline is a single-issue, cycle-driven execution conveyor...",
hmPrevLink:"pupose-of-this-chapterchapter2.html",
hmNextLink:"chapter-3_3-the-six-pipeline-s.html",
hmParentLink:"chapter-3---pipeline-architect.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-3---pipeline-architect.html\">Chapter 3 - Pipeline Architecture<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 3 - Pipeline Architecture > 3.2 Overview of the Pipeline Model",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">3.2 Overview of the Pipeline Model<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">EMulatR implements a six-stage, in-order Alpha AXP pipeline optimized for clarity, correctness, and determinism. The pipeline is a single-issue, cycle-driven execution conveyor that models Alpha AXP execution behavior with weak ordering and precise exceptions.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Key characteristics:<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>In-order issue and retirement — one instruction may retire per cycle<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>All instruction semantics execute in a single stage (EX) via grain-&gt;execute(slot)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Lightweight stages for bookkeeping and control flow<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Explicit stall and serialization handling with well-defined release conditions<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Precise exception semantics — no architectural state becomes visible until WB<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Backward stage advancement (WB → IF) for hazard-free forwarding<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The pipeline is designed to model architectural behavior, not the microarchitectural speculation strategies of specific Alpha implementations. Its simplicity is intentional and enables correctness, debuggability, and long-term maintainability.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Pipeline state is owned exclusively by AlphaCPU. The pipeline is implemented as a ring buffer of six PipelineSlot entries, indexed by a rotating head pointer (m_head). Stage access is via the stage(N) accessor, which maps logical stage numbers to physical ring buffer positions.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">static&nbsp;constexpr&nbsp;int&nbsp;STAGE_COUNT&nbsp;=&nbsp;6;&nbsp;\/\/&nbsp;IF,&nbsp;DE,&nbsp;IS,&nbsp;EX,&nbsp;MEM,&nbsp;WB<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">static&nbsp;constexpr&nbsp;int&nbsp;STAGEWB&nbsp;=&nbsp;5;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">static&nbsp;constexpr&nbsp;int&nbsp;STAGEMEM&nbsp;=&nbsp;4;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">static&nbsp;constexpr&nbsp;int&nbsp;STAGEEX&nbsp;=&nbsp;3;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">static&nbsp;constexpr&nbsp;int&nbsp;STAGEIS&nbsp;=&nbsp;2;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">static&nbsp;constexpr&nbsp;int&nbsp;STAGEDE&nbsp;=&nbsp;1;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">static&nbsp;constexpr&nbsp;int&nbsp;STAGEIF&nbsp;=&nbsp;0;<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-3_3-the-six-pipeline-s.html\" class=\"topiclink\">3.3 The Six Pipeline Stages<\/a>; machineLib\/PipeLineSlot.h; cpuCoreLib\/AlphaPipeline.h.<\/span><\/p>\n\r"
})
