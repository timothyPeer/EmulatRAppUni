hmLoadTopic({
hmKeywords:"",
hmTitle:"Endianness Rules",
hmDescription:"Alpha is ALWAYS little-endian. There is no big-endian mode. Any big-endian data must be explicitly byte-swapped by software.",
hmPrevLink:"",
hmNextLink:"",
hmParentLink:"appendix---trait-examples.html",
hmBreadCrumbs:"",
hmTitlePath:"Introduction > Appendix > Appendix I – Global Singletons",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">Endianness Rules<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">Alpha is ALWAYS little-endian. There is no big-endian mode. Any big-endian data must be explicitly byte-swapped by software.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">ALPHA ENDIANNESS - ARCHITECTURAL FACTS:<\/p>\n\r<p class=\"p_Normal\">---------------------------------------<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">1.<\/span>ALPHA IS LITTLE-ENDIAN (Native)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">a.<\/span> &nbsp; - All Alpha processors (21064, 21164, 21264\/EV6) are little-endian<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">b.<\/span> &nbsp; - Memory is stored with least significant byte at lowest address<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">c.<\/span> &nbsp; - This is the ONLY native mode - no big-endian mode switch<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">2.<\/span>INSTRUCTIONS ARE LITTLE-ENDIAN<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">a.<\/span> &nbsp; - 32-bit instructions stored in little-endian format<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">b.<\/span> &nbsp; - Opcode extraction works on little-endian values<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">c.<\/span> &nbsp; - No byte swapping needed for instruction fetch<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">3.<\/span>DATA ACCESSES ARE LITTLE-ENDIAN<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">a.<\/span> &nbsp; - LDQ, LDL, LDWU, LDBU all assume little-endian memory<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">b.<\/span> &nbsp; - STQ, STL, STW, STB all write little-endian<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">c.<\/span> &nbsp; - No automatic byte swapping in hardware<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">4.<\/span>BYTE SWAPPING IS SOFTWARE-CONTROLLED<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">a.<\/span> &nbsp; - Alpha provides INSWL, EXTQH, etc. for manual byte manipulation<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">b.<\/span> &nbsp; - OSF\/1, Tru64, Linux\/Alpha all assume little-endian<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">c.<\/span> &nbsp; - Big-endian data must be explicitly converted by software<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">5.<\/span>MMIO CAN BE CONFIGURED<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">a.<\/span> &nbsp; - Some Alpha systems (like AlphaServer) have I\/O controllers<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">b.<\/span> &nbsp; &nbsp; that support per-device endianness configuration<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">c.<\/span> &nbsp; - This is handled by the I\/O bridge\/chipset, NOT the CPU<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">d.<\/span> &nbsp; - The CPU always operates in little-endian mode<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">Architecture Stack<\/span><\/h2>\n\r<p class=\"p_Normal\">--------------------------------------------<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">1.<\/span>LAYER 1: CPU (Alpha Instructions)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">a.<\/span> Native little-endian operations<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">b.<\/span> No byte swapping<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">c.<\/span> Operates on host-endian values in registers<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">2.<\/span>LAYER 2: GuestMemory \/ SafeMemory<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">a.<\/span>Stores memory in LITTLE-ENDIAN format (Alpha native)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">b.<\/span>readPA() converts from little-endian to host-endian<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">c.<\/span>writePA() converts from host-endian to little-endian<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">d.<\/span>This is WHERE endianness conversion happens<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">3.<\/span>LAYER 3: MMIO Manager<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">a.<\/span>Per-device endianness configuration<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">b.<\/span>Most devices: little-endian (native Alpha)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">c.<\/span>Some devices: big-endian (e.g., network interfaces)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">d.<\/span>Handled by device-specific read\/write handlers<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">4.<\/span>LAYER 4: Host Machine<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">a.<\/span>Could be x86-64 (little-endian) or ARM64 (bi-endian)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">b.<\/span>Qt provides qFromLittleEndian() \/ qToLittleEndian()<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 2.5000rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">c.<\/span>Use these for memory &lt;-&gt; register transfers<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">EmulatR Implementation (Endian Support)<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">From AlphaMemorySystem.h, your readRAM():<\/p>\n\r<p class=\"p_Normal\">-----------------------------------------<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">case&nbsp;8:&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;quint64&nbsp;val;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!m_guestMem-&gt;readPA(pa,&nbsp;&amp;val,&nbsp;8))&nbsp;return&nbsp;false;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;outValue&nbsp;=&nbsp;qFromLittleEndian(val);&nbsp;&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">}<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">Implementation Rule: <\/span><\/h3>\n\r<p class=\"p_Normal\">1. GuestMemory stores bytes in little-endian (Alpha native)<\/p>\n\r<p class=\"p_Normal\">2. readPA() returns raw bytes (little-endian)<\/p>\n\r<p class=\"p_Normal\">3. qFromLittleEndian() converts to host endianness<\/p>\n\r<p class=\"p_Normal\">4. CPU operates on host-endian values<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">From AlphaMemorySystem.h, your writeRAM():<\/p>\n\r<p class=\"p_Normal\">------------------------------------------<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">case&nbsp;8:&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;quint64&nbsp;val&nbsp;=&nbsp;qToLittleEndian(value);&nbsp;&nbsp;\/\/&nbsp;✅&nbsp;CORRECT!<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;m_guestMem-&gt;writePA(pa,&nbsp;&amp;val,&nbsp;8);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">}<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">Implementation Rule: <\/span><\/h3>\n\r<p class=\"p_Normal\">1. CPU provides value in host endianness<\/p>\n\r<p class=\"p_Normal\">2. qToLittleEndian() converts to Alpha native (little-endian)<\/p>\n\r<p class=\"p_Normal\">3. writePA() stores bytes in little-endian format<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">Implementation Rule: <\/span><\/h3>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The global_BoxMemory.h functions you\'re using:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">inline&nbsp;bool&nbsp;readPA_Quad(quint64&nbsp;pa,&nbsp;quint64&amp;&nbsp;outValue)&nbsp;noexcept<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;globalBoxMemory().readPA(pa,&nbsp;&amp;outValue,&nbsp;8);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">}<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This ultimately calls AlphaMemorySystem::readRAM() which does:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;outValue = qFromLittleEndian(val);<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">So endianness IS handled - at the memory system layer!<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">YOUR MBox FUNCTIONS Do not perform endian translations<\/p>\n\r<p class=\"p_Normal\">---------------------------------------------------------<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">void&nbsp;MBox::executeLDQ(const&nbsp;DecodedInstruction&amp;&nbsp;di)&nbsp;noexcept<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;\/\/&nbsp;...<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;quint64&nbsp;data;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;readPA_Quad(pa,&nbsp;data);&nbsp;&nbsp;\/\/&nbsp;Returns&nbsp;value&nbsp;in&nbsp;host&nbsp;endianness&nbsp;✅<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;writeIntReg(m_cpuId,&nbsp;di.ra,&nbsp;data);&nbsp;&nbsp;\/\/&nbsp;CPU&nbsp;uses&nbsp;host&nbsp;endianness&nbsp;✅<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">}<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">Implementation Rule: <\/span><\/h3>\n\r<p class=\"p_Normal\">1. readPA_Quad() handles conversion from little-endian memory<\/p>\n\r<p class=\"p_Normal\">2. CPU registers operate in host endianness<\/p>\n\r<p class=\"p_Normal\">3. No manual byte swapping needed at instruction level<\/p>\n\r<p class=\"p_Normal\">*\/<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_Heading2\">MMIO ENDIANNESS HANDLING. <\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">MMIO devices may need different endianness:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Network Interface Card (Big-Endian)<\/p>\n\r<p class=\"p_Normal\">--------------------------------------------<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">class&nbsp;NetworkDevice&nbsp;:&nbsp;public&nbsp;MMIODevice<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;MMIOStatus&nbsp;handleRead(quint64&nbsp;offset,&nbsp;quint8&nbsp;width,&nbsp;quint64&amp;&nbsp;outValue)&nbsp;override<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quint32&nbsp;rawValue&nbsp;=&nbsp;m_registers[offset&nbsp;\/&nbsp;4];<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\/\/&nbsp;This&nbsp;device&nbsp;is&nbsp;big-endian&nbsp;(common&nbsp;for&nbsp;network&nbsp;chips)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(width&nbsp;==&nbsp;4)&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outValue&nbsp;=&nbsp;qFromBigEndian(rawValue);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;MMIOStatus::OK;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;}<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;MMIOStatus&nbsp;handleWrite(quint64&nbsp;offset,&nbsp;quint8&nbsp;width,&nbsp;quint64&nbsp;value)&nbsp;override<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\/\/&nbsp;Convert&nbsp;from&nbsp;host&nbsp;to&nbsp;big-endian&nbsp;for&nbsp;this&nbsp;device<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(width&nbsp;==&nbsp;4)&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_registers[offset&nbsp;\/&nbsp;4]&nbsp;=&nbsp;qToBigEndian(static_cast&lt;quint32&gt;(value));<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;MMIOStatus::OK;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;}<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">};<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Example:&nbsp;Serial&nbsp;Port&nbsp;(Little-Endian)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">------------------------------------<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">class&nbsp;SerialDevice&nbsp;:&nbsp;public&nbsp;MMIODevice<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;MMIOStatus&nbsp;handleRead(quint64&nbsp;offset,&nbsp;quint8&nbsp;width,&nbsp;quint64&amp;&nbsp;outValue)&nbsp;override<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\/\/&nbsp;Most&nbsp;serial&nbsp;devices&nbsp;are&nbsp;byte-oriented,&nbsp;no&nbsp;endianness&nbsp;issues<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(width&nbsp;==&nbsp;1)&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outValue&nbsp;=&nbsp;m_registers[offset];<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;MMIOStatus::OK;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;}<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">};<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">Implementation Rule: <\/span><\/h3>\n\r<p class=\"p_Normal\">---------<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>RAM is always little-endian (Alpha native)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>MMIO endianness is device-specific<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Handle it in the device\'s read\/write methods<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>NOT in the CPU instruction handlers<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">INSTRUCTION FETCH ENDIANNESS<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Instructions are 32-bit little-endian values:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Example instruction: 0x47E03400 (little-endian in memory)<\/p>\n\r<p class=\"p_Normal\">Memory bytes: [0x00, 0x34, 0xE0, 0x47] at addresses [n, n+1, n+2, n+3]<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">When fetched:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;quint32 raw;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;readPA_Long(pc, raw); &nbsp;\/\/ Returns 0x47E03400 in host endianness<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Decode:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;opcode = (raw &gt;&gt; 26) &amp; 0x3F; &nbsp;\/\/ Bits 31:26<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;ra = (raw &gt;&gt; 21) &amp; 0x1F; &nbsp; &nbsp; &nbsp;\/\/ Bits 25:21<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">Implementation Rule: <\/span><\/h3>\n\r<p class=\"p_Normal\">1. Memory stores instruction in little-endian<\/p>\n\r<p class=\"p_Normal\">2. readPA_Long() converts to host endianness<\/p>\n\r<p class=\"p_Normal\">3. Bit extraction works on host-endian value<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">\/\/ ============================================================================<\/p>\n\r<p class=\"p_Normal\">\/\/ ENDIANNESS IN DIFFERENT SCENARIOS<\/p>\n\r<p class=\"p_Normal\">\/\/ ============================================================================<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SCENARIO 1: x86-64 Host (Little-Endian)<\/p>\n\r<p class=\"p_Normal\">---------------------------------------<\/p>\n\r<p class=\"p_Normal\">Alpha Memory: [0x78, 0x56, 0x34, 0x12] (little-endian, value = 0x12345678)<\/p>\n\r<p class=\"p_Normal\">Host Machine: Little-endian<\/p>\n\r<p class=\"p_Normal\">Conversion: qFromLittleEndian() is a no-op on x86-64<\/p>\n\r<p class=\"p_Normal\">Result: 0x12345678 in CPU register ✅<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SCENARIO 2: Big-Endian Host (Hypothetical)<\/p>\n\r<p class=\"p_Normal\">------------------------------------------<\/p>\n\r<p class=\"p_Normal\">Alpha Memory: [0x78, 0x56, 0x34, 0x12] (little-endian, value = 0x12345678)<\/p>\n\r<p class=\"p_Normal\">Host Machine: Big-endian<\/p>\n\r<p class=\"p_Normal\">Conversion: qFromLittleEndian() byte-swaps to [0x12, 0x34, 0x56, 0x78]<\/p>\n\r<p class=\"p_Normal\">Result: 0x12345678 in CPU register ✅<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SCENARIO 3: ARM64 Host (Bi-Endian, Running Little-Endian)<\/p>\n\r<p class=\"p_Normal\">---------------------------------------------------------<\/p>\n\r<p class=\"p_Normal\">Same as x86-64 case - qFromLittleEndian() is a no-op ✅<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">KEY INSIGHT:<\/p>\n\r<p class=\"p_Normal\">-----------<\/p>\n\r<p class=\"p_Normal\">Your code is PORTABLE because:<\/p>\n\r<p class=\"p_Normal\">1. Alpha memory is always little-endian<\/p>\n\r<p class=\"p_Normal\">2. Qt\'s qFromLittleEndian\/qToLittleEndian handle host conversion<\/p>\n\r<p class=\"p_Normal\">3. CPU operates on host-endian values<\/p>\n\r<p class=\"p_Normal\">4. No #ifdef needed for different host architectures<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">\/*<\/p>\n\r<p class=\"p_Normal\">Your GuestMemory should do something like:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">bool&nbsp;GuestMemory::readPA(quint64&nbsp;pa,&nbsp;void*&nbsp;buffer,&nbsp;size_t&nbsp;size)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;\/\/&nbsp;Read&nbsp;bytes&nbsp;from&nbsp;guest&nbsp;memory&nbsp;(stored&nbsp;in&nbsp;little-endian)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;memcpy(buffer,&nbsp;m_ram&nbsp;+&nbsp;pa,&nbsp;size);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">}<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">bool&nbsp;GuestMemory::writePA(quint64&nbsp;pa,&nbsp;const&nbsp;void*&nbsp;buffer,&nbsp;size_t&nbsp;size)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;\/\/&nbsp;Write&nbsp;bytes&nbsp;to&nbsp;guest&nbsp;memory&nbsp;(stored&nbsp;in&nbsp;little-endian)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;memcpy(m_ram&nbsp;+&nbsp;pa,&nbsp;buffer,&nbsp;size);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">}<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Then in AlphaMemorySystem::readRAM():<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;quint64 val;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;m_guestMem-&gt;readPA(pa, &amp;val, 8); &nbsp; &nbsp; &nbsp;\/\/ Raw bytes (little-endian)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;outValue = qFromLittleEndian(val); &nbsp; &nbsp;\/\/ Convert to host endianness <\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">And in AlphaMemorySystem::writeRAM():<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;quint64 val = qToLittleEndian(value); \/\/ Convert to little-endian<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;m_guestMem-&gt;writePA(pa, &amp;val, 8); &nbsp; &nbsp; \/\/ Store bytes <\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">WHERE ENDIANNESS IS HANDLED:<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>GuestMemory\/SafeMemory Layer:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; - Stores bytes in little-endian (Alpha native)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; - Converts to\/from host endianness on read\/write<\/p>\n\r<p class=\"p_Normal\"> &nbsp; - Uses qFromLittleEndian() \/ qToLittleEndian()<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>MMIO Layer (Device-Specific):<\/p>\n\r<p class=\"p_Normal\"> &nbsp; - Per-device endianness configuration<\/p>\n\r<p class=\"p_Normal\"> &nbsp; - Most devices: little-endian (Alpha native)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; - Some devices: big-endian (handled in device code)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">❌ CPU Instruction Layer (MBox, EBox, etc.):<\/p>\n\r<p class=\"p_Normal\"> &nbsp; - NO endianness handling needed<\/p>\n\r<p class=\"p_Normal\"> &nbsp; - Operates on host-endian values<\/p>\n\r<p class=\"p_Normal\"> &nbsp; - Memory layer handles conversion<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">❌ Register File:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; - NO endianness handling needed<\/p>\n\r<p class=\"p_Normal\"> &nbsp; - Just stores native host values<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">VERIFICATION CHECKLIST:<\/p>\n\r<p class=\"p_Normal\">----------------------<\/p>\n\r<p class=\"p_Normal\">1. ✅ Check AlphaMemorySystem::readRAM() uses qFromLittleEndian()<\/p>\n\r<p class=\"p_Normal\">2. ✅ Check AlphaMemorySystem::writeRAM() uses qToLittleEndian()<\/p>\n\r<p class=\"p_Normal\">3. ✅ GuestMemory stores bytes in little-endian order<\/p>\n\r<p class=\"p_Normal\">4. ✅ MMIO devices handle their own endianness<\/p>\n\r<p class=\"p_Normal\">5. ✅ CPU instructions just use values, no swapping<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">ALPHA ARCHITECTURAL FACT.<\/span><\/h3>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">&nbsp;<\/span><\/h3>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">TESTING ENDIANNESS CORRECTNESS<\/span><\/h3>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Test Case: Write and Read Back<\/p>\n\r<p class=\"p_Normal\">------------------------------<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;Write&nbsp;known&nbsp;value<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">quint64&nbsp;testValue&nbsp;=&nbsp;0x0123456789ABCDEF;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">writePA_Quad(0x1000,&nbsp;testValue);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;Read&nbsp;back<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">quint64&nbsp;readValue;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">readPA_Quad(0x1000,&nbsp;readValue);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;Verify<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">assert(readValue&nbsp;==&nbsp;testValue);&nbsp;&nbsp;\/\/&nbsp;Should&nbsp;be&nbsp;identical<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;Check&nbsp;memory&nbsp;bytes&nbsp;(should&nbsp;be&nbsp;little-endian)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">quint8*&nbsp;bytes&nbsp;=&nbsp;getMemoryPointer(0x1000);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">assert(bytes[0]&nbsp;==&nbsp;0xEF);&nbsp;&nbsp;\/\/&nbsp;Least&nbsp;significant&nbsp;byte&nbsp;at&nbsp;lowest&nbsp;address<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">assert(bytes[1]&nbsp;==&nbsp;0xCD);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">assert(bytes[2]&nbsp;==&nbsp;0xAB);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">assert(bytes[3]&nbsp;==&nbsp;0x89);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">assert(bytes[4]&nbsp;==&nbsp;0x67);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">assert(bytes[5]&nbsp;==&nbsp;0x45);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">assert(bytes[6]&nbsp;==&nbsp;0x23);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">assert(bytes[7]&nbsp;==&nbsp;0x01);&nbsp;&nbsp;\/\/&nbsp;Most&nbsp;significant&nbsp;byte&nbsp;at&nbsp;highest&nbsp;address<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_Normal\">This verifies:<\/p>\n\r<p class=\"p_Normal\">1. Write converts host → little-endian<\/p>\n\r<p class=\"p_Normal\">2. Memory stores in little-endian<\/p>\n\r<p class=\"p_Normal\">3. Read converts little-endian → host<\/p>\n\r<p class=\"p_Normal\">4. Round-trip preserves value<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">CONCLUSION.<\/span><\/h2>\n\r<p class=\"p_Normal\">----------<\/p>\n\r<p class=\"p_Normal\">The current architecture is CORRECT. Endianness is handled at the right layer (memory system), and your instruction implementations don\'t need to worry about it. Keep doing what you\'re doing! <\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r"
})
