hmLoadTopic({
hmKeywords:"",
hmTitle:"21.5 Tracing by Subsystem",
hmDescription:"21.5.1 Instruction Tracing  Instruction tracing records: PC at fetch, decoded instruction (opcode, function, ra\/rb\/rc), grain identity (pointer from InstructionGrainRegistry),...",
hmPrevLink:"21_4-subsystem-logging-(debug_.html",
hmNextLink:"21_6-logreader-diagnostic-appl.html",
hmParentLink:"chapter-21---debugging_-tracin.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-21---debugging_-tracin.html\">Chapter 21 – Debugging, Tracing, and Determinism<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 21 – Debugging, Tracing, and Determinism > 21.5 Tracing by Subsystem",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">21.5 Tracing by Subsystem<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">21.5.1 Instruction Tracing<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Instruction tracing records: PC at fetch, decoded instruction (opcode, function, ra\/rb\/rc), grain identity (pointer from <span class=\"f_CodeExample\">InstructionGrainRegistry<\/span>), operand values (optional), result values, and retirement cycle via <span class=\"f_CodeExample\">EXECTRACE_WB_RETIRE<\/span>. Tracing granularity is configurable: fetch-level (records all fetched instructions including flushed), execute-level (records instruction execution outcomes), or retirement-level (records only architecturally committed results). Tracing may be continuous, conditional (filtered by PC range, opcode class, or CPU), or event-triggered.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">21.5.2 Pipeline Tracing<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Pipeline tracing observes: slot occupancy across the six stages (IF → DE → IS → EX → MEM → WB), stall reasons (barrier engagement, hazard detection, memory wait), barrier engagement and release events (CBox logs barrier kind, stall entry, and release cycle), flush events via <span class=\"f_CodeExample\">EXECTRACE_PIPELINE_FLUSH<\/span> (caller name, current PC, flush reason), and branch misprediction recovery. This is critical for diagnosing deadlocks, verifying barrier correctness, and understanding stall behavior.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">21.5.3 Exception and Fault Tracing<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The FaultDispatcher integrates deeply with the tracing infrastructure. Traceable events include: fault creation (ExceptionFactory method called, ExceptionClass assigned), priority arbitration (when multiple events pending), deliverability decisions (event reaches WB, slot.faultPending checked), PAL vector selection (ExceptionMapping_inl::mapClassToPalVector, PalVectorTable lookup), PAL mode entry (<span class=\"f_CodeExample\">EXECTRACE_PAL_ENTRY<\/span> with PalEntryReasonTrace), and HW_REI restoration (<span class=\"f_CodeExample\">EXECTRACE_PAL_EXIT<\/span>). Each exception is traceable to the exact faulting instruction, exact architectural state, and exact cycle.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">21.5.4 Interrupt and IPI Tracing<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Interrupt tracing records: IRQ assertion (device thread raises interrupt via <span class=\"f_CodeExample\">raiseInterrupt()<\/span>), masking decisions (current IPL vs pending level), delivery cycle (when <span class=\"f_CodeExample\">claimNext()<\/span> succeeds), PAL entry (<span class=\"f_CodeExample\">EXECTRACE_INTERRUPT<\/span>), and handler completion (HW_REI). IPI tracing includes: sender CPU, target CPU(s), IPICommand payload type, encoded parameter (VA\/ASN), acknowledgment timing, and <span class=\"f_CodeExample\">IPIManager<\/span> per-CPU statistics (<span class=\"f_CodeExample\">totalCount<\/span>). This is essential for SMP debugging — IPI-related bugs are often the hardest to diagnose without comprehensive tracing.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">21.5.5 Memory and LL\/SC Diagnostics<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Memory tracing supports: load\/store address, size, and data values, write buffer enqueue and drain events, barrier-forced drain sequences, LL\/SC reservation creation (<span class=\"f_CodeExample\">setReservation()<\/span> with cache line address and CPU ID), reservation invalidation (<span class=\"f_CodeExample\">breakReservationsOnCacheLine()<\/span> with triggering CPU and address), STx_C success\/failure outcomes, and MMIO reads\/writes with CPU ID. False sharing and livelock scenarios are explicitly observable through reservation tracing — every creation and invalidation event is logged with the responsible CPU and cache line address.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-18---fault-dispatcher-.html\" class=\"topiclink\">Chapter 18 – Fault Dispatcher &amp; Precise Exceptions<\/a> (fault event tracing); <a href=\"chapter-19---debugging_-tracin.html\" class=\"topiclink\">Chapter 19 – Interrupt Architecture &amp; IPI<\/a> (IPI tracing); <a href=\"chapter-15---memory-system-imp.html\" class=\"topiclink\">Chapter 15 – Memory System Implementation Details<\/a> &nbsp;(memory and reservation diagnostics).<\/span><\/p>\n\r"
})
