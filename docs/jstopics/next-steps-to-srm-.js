hmLoadTopic({
hmKeywords:"",
hmTitle:"Next Steps to SRM >>>",
hmDescription:"You‚Äôre exactly right: at this point, what‚Äôs missing is **not more architecture prose**, but a **concrete, deterministic operational sequence** that takes the emulator from...",
hmPrevLink:"",
hmNextLink:"",
hmParentLink:"appendix---trait-examples.html",
hmBreadCrumbs:"",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Appendix > Appendix I ‚Äì Glossary and Acronyms",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">Next Steps to SRM &gt;&gt;&gt;<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">You‚Äôre exactly right: at this point, what‚Äôs missing is **not more architecture prose**, but a **concrete, deterministic operational sequence** that takes the emulator from reset ‚Üí PAL ‚Üí SRM console prompt.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Below is a **clean, implementation-oriented boot checklist** you can treat as both:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* a **Chapter 20 core spine**, and<\/p>\n\r<p class=\"p_Normal\">* a **bring-up execution plan** you can literally tick off in code.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">I‚Äôll keep this grounded in what you already have (PalService, CSERVE, ConsoleManager, OPA0 device, SRMEnvStore).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"># Concrete Boot Sequence to SRM<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">*(Alpha AXP Emulator ‚Äì Operational Checklist)*<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is the **minimum correct sequence** required to reach an SRM `&gt;&gt;&gt;` prompt.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## Phase 0 ‚Äî Static Construction (Before Any CPU Runs)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Goal:** All global subsystems exist, but nothing is ‚Äúlive‚Äù.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Must be true:**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1. **GuestMemory**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * Physical RAM allocated<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * MMIO regions registered<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * Reservation system initialized (LL\/SC empty)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">2. **MMIO + Devices**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * ConsoleOPA0Device constructed<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * ConsoleManager constructed<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * SRMEnvStore constructed (even if empty)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">3. **Interrupt Infrastructure**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * IRQController constructed<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * IPIManager constructed<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * IPIMailboxes allocated per CPU<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">4. **PAL Infrastructure**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * PalVectorTable constructed<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * PalVectorTable::initialize() called<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * All PAL vectors registered<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">5. **CPU Objects**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * AlphaCPU objects constructed<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * CPURegistry populated<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * CPU count fixed (SMP known)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">üö´ **No CPU executes yet**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## Phase 1 ‚Äî Reset Entry (Power-On State)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Goal:** CPU is in architecturally correct reset state.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**On CPU 0 only:**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1. **Processor State**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * PC = RESET_VECTOR (architectural constant)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * Mode = PAL<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * IPL = max (interrupts masked)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * PS initialized to reset value<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * All integer &amp; FP registers undefined\/cleared (implementation choice)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">2. **Pipeline**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * Completely empty<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * No speculative state<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * No reservations<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">3. **TLB**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * ITB empty<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * DTB empty<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">4. **LL\/SC**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * All reservations cleared<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This corresponds to **hardware reset**, not a PAL call.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## Phase 2 ‚Äî Initial PAL Execution (RESET PAL Vector)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Goal:** Enter PAL reset handler and bootstrap minimal machine state.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Mechanism:**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* You **do not fetch an instruction** yet.<\/p>\n\r<p class=\"p_Normal\">* You **directly vector into PAL**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Required behavior:**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```cpp<\/p>\n\r<p class=\"p_Normal\">PalService::enterPALVector(<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;slot, <\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;PalVectorId::RESET,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;reset_pc,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;empty_args<\/p>\n\r<p class=\"p_Normal\">);<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**PAL RESET handler must:**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1. Establish:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * Initial stack pointer<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * HWPCB<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * Exception save area<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">2. Initialize critical IPRs:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * ASN<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * VA control<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * ICCSR<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * PS shadow registers<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">3. Leave CPU in PAL mode<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">üìå At this stage:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* No SRM yet<\/p>\n\r<p class=\"p_Normal\">* No console output yet<\/p>\n\r<p class=\"p_Normal\">* Just PAL groundwork<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## Phase 3 ‚Äî Transition from PAL to SRM Firmware Code<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Goal:** Begin executing SRM firmware as *normal code*, not PAL.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Critical architectural rule:**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&gt; **HW_REI is the ONLY legal exit from PAL mode**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Your statement here is correct and essential.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**PAL RESET must eventually:**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Set up a return PC pointing into SRM image<\/p>\n\r<p class=\"p_Normal\">* Execute `HW_REI`<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**HW_REI must restore:**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* PC<\/p>\n\r<p class=\"p_Normal\">* Processor mode (to kernel)<\/p>\n\r<p class=\"p_Normal\">* PS<\/p>\n\r<p class=\"p_Normal\">* IPL<\/p>\n\r<p class=\"p_Normal\">* Interrupt enable state<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**After HW_REI:**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Pipeline resumes normal fetch\/decode<\/p>\n\r<p class=\"p_Normal\">* CPU is no longer in PAL mode<\/p>\n\r<p class=\"p_Normal\">* Execution begins in SRM code<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## Phase 4 ‚Äî SRM Firmware Execution Begins<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Goal:** SRM runs as ordinary privileged software.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**SRM expects:**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1. **Instruction Fetch**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * From physical memory (or mapped ROM)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * ITB translation operational<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">2. **Console Path**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * SRM uses CALL_PAL ‚Üí CSERVE<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * CSERVE routes to ConsoleManager<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * ConsoleManager routes to OPA0 device<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is where your existing pieces **finally connect**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## Phase 5 ‚Äî CSERVE Path (Console I\/O)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Goal:** SRM can print characters and read input.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### Required call path:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">SRM code<\/p>\n\r<p class=\"p_Normal\"> &nbsp;‚Üí CALL_PAL CSERVE<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;‚Üí PalService::executeCSERVE<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp;‚Üí ConsoleManager<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;‚Üí ConsoleOPA0Device<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;‚Üí host stdout \/ socket \/ terminal<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Minimum CSERVE functions needed to reach prompt:**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* PUTC<\/p>\n\r<p class=\"p_Normal\">* PUTS<\/p>\n\r<p class=\"p_Normal\">* GETC (later)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SRM banner output **proves** this path is working.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## Phase 6 ‚Äî Interrupt Enable &amp; Idle Loop<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Goal:** SRM reaches interactive prompt.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SRM will:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1. Enable interrupts<\/p>\n\r<p class=\"p_Normal\">2. Probe devices<\/p>\n\r<p class=\"p_Normal\">3. Print banner<\/p>\n\r<p class=\"p_Normal\">4. Enter command loop<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">At this point you should see:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&gt;&gt;&gt; <\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">üéâ **Boot successful**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"># Failure Modes to Watch For (Very Important)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If SRM does **not** appear, check these in order:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 1. Never leaving PAL<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* HW_REI not implemented correctly<\/p>\n\r<p class=\"p_Normal\">* Mode bit not restored<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 2. CALL_PAL executes but CSERVE silent<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* ConsoleManager not initialized<\/p>\n\r<p class=\"p_Normal\">* OPA0 not registered<\/p>\n\r<p class=\"p_Normal\">* CSERVE dispatch table incomplete<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 3. Pipeline keeps stalling<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Barrier not released<\/p>\n\r<p class=\"p_Normal\">* EXCB\/TRAPB incorrectly blocking fetch<\/p>\n\r<p class=\"p_Normal\">* FaultDispatcher never drained<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 4. Immediate fault loop<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* ITB miss not handled<\/p>\n\r<p class=\"p_Normal\">* Translation faults not vectored correctly<\/p>\n\r<p class=\"p_Normal\">* FaultDispatcher priority inversion<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"># What I Recommend as the Next Concrete Step<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Do **not** write more documentation yet.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Instead:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### ‚úÖ Create a **Boot Progress Trace**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Add log markers at each phase:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">[BOOT] Reset vector entered<\/p>\n\r<p class=\"p_Normal\">[BOOT] PAL RESET entered<\/p>\n\r<p class=\"p_Normal\">[BOOT] HW_REI executed<\/p>\n\r<p class=\"p_Normal\">[BOOT] SRM entry PC = 0x...<\/p>\n\r<p class=\"p_Normal\">[BOOT] CSERVE PUTS called<\/p>\n\r<p class=\"p_Normal\">[BOOT] SRM prompt reached<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This turns boot into a **binary search problem**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"># How This Maps Back Into Documentation<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Once this works, Chapter 20 becomes:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Chapter 20 ‚Äì Boot Sequence, PAL, and SRM Integration**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* 20.1 Reset State<\/p>\n\r<p class=\"p_Normal\">* 20.2 PAL RESET Entry<\/p>\n\r<p class=\"p_Normal\">* 20.3 HW_REI Semantics<\/p>\n\r<p class=\"p_Normal\">* 20.4 SRM Execution Model<\/p>\n\r<p class=\"p_Normal\">* 20.5 CSERVE Console Path<\/p>\n\r<p class=\"p_Normal\">* 20.6 Failure Diagnostics<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">But **the code must lead**, not the prose.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If you want, next we can:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Build a **minimal PAL RESET handler checklist**<\/p>\n\r<p class=\"p_Normal\">* Or create a **CSERVE conformance table** (what SRM actually calls)<\/p>\n\r<p class=\"p_Normal\">* Or design a **single-CPU SRM bring-up mode** that bypasses SMP until later<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You‚Äôre very close now ‚Äî this is the ‚Äúlast mile‚Äù problem, not an architecture problem anymore.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r"
})
