hmLoadTopic({
hmKeywords:"",
hmTitle:"15.5 Load and Store Semantics",
hmDescription:"15.5.1 Loads – Synchronous and Visible  All loads in ASA EmulatR complete synchronously during the EX stage. The MBox calls GuestMemory::readRouted() (or the typed wrappers...",
hmPrevLink:"15_4-sparsememorybacking---on-.html",
hmNextLink:"15_6-write-buffer-implementati.html",
hmParentLink:"chapter-15---memory-system-imp.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-15---memory-system-imp.html\">Chapter 15 – Memory System Implementation Details<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 15 – Memory System Implementation Details > 15.5 Load and Store Semantics",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">15.5 Load and Store Semantics<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">15.5.1 Loads – Synchronous and Visible<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">All loads in ASA EmulatR complete synchronously during the EX stage. The MBox calls <span class=\"f_CodeExample\">GuestMemory::readRouted()<\/span> (or the typed wrappers <span class=\"f_CodeExample\">read8\/16\/32\/64<\/span>), which classifies the PA, routes to SafeMemory or MMIOManager, and returns data and a <span class=\"f_CodeExample\">MEM_STATUS<\/span> code immediately. There is no speculative or deferred load completion. A completed load reflects architectural memory state at that moment, subject to write buffer forwarding and ordering rules.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">15.5.2 Stores – Buffered and Deferred<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Stores do not immediately update SafeMemory. Instead, the CBox enqueues each store into a per-CPU write buffer via <span class=\"f_CodeExample\">WriteBufferManager::addEntry()<\/span>. The <span class=\"f_CodeExample\">WriteBufferEntry<\/span> structure records the physical address, data, access size (1\/2\/4\/8), a validity flag, an MMIO flag, and a timestamp for ordering enforcement. Write buffers drain asynchronously; memory barriers control when stores become globally visible.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">A store becomes architecturally visible when it drains from the write buffer and is committed to SafeMemory (or dispatched to the MMIOManager for MMIO writes). This models Alpha\'s weak memory ordering faithfully.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Invariant:<\/span> A store may retire from the pipeline before it becomes globally visible. Loads are synchronous; stores are buffered.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: coreLib\/WriteBufferEntry.h (~67 lines) – Write buffer entry structure; <a href=\"14_5-cbox---cache-_-control-bo.html\" class=\"topiclink\">14.5 CBox – Cache \/ Control Box<\/a>; <a href=\"15_6-write-buffer-implementati.html\" class=\"topiclink\">15.6 Write Buffer Implementation<\/a>.<\/span><\/p>\n\r"
})
