hmLoadTopic({
hmKeywords:"",
hmTitle:"8.2 What PAL Is (and Is Not)",
hmDescription:"8.2.1 What PAL Is  PAL is a hardware-defined privileged execution mode. It is the sole authority for exception dispatch, interrupt dispatch, privileged register access (IPRs),...",
hmPrevLink:"8_1-purpose-of-this-chapter.html",
hmNextLink:"chapter-8_3-privilege-levels-i.html",
hmParentLink:"chapter-8---pal-and-privleged-.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-8---pal-and-privleged-.html\">Chapter 8 - PAL and Privileged Boundary<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 8 - PAL and Privileged Boundary > 8.2 What PAL is (and is Not)",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">8.2 What PAL Is (and Is Not)<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">8.2.1 What PAL Is<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">PAL is a hardware-defined privileged execution mode. It is the sole authority for exception dispatch, interrupt dispatch, privileged register access (IPRs), context switching primitives, and low-level SMP coordination. PAL code executes using normal Alpha instructions inside the normal pipeline, but under strictly elevated privileges. It is entered only through architecturally defined vectors.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">8.2.2 What PAL Is Not<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">PAL is not microcode, not a firmware blob that runs outside the pipeline, not a device driver layer, not a replacement for the operating system, and not a software trap handler. PAL is part of the architectural contract — it defines the interface between hardware and the operating system.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">In ASA-EmulatR, PAL is implemented as C++ code executed through PalService methods, not as a memory region. CALL_PAL instructions execute C++ handlers via PalBoxBase → PalService delegation. There is no PAL code stored in memory — this is a deliberate design choice that eliminates an entire class of memory synchronization issues.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-4_9-palbox---privilege.html\" class=\"topiclink\">4.9 PalBox - Privileged Architecture Library Box (PalService delegation model)<\/a>.<\/span><\/p>\n\r"
})
