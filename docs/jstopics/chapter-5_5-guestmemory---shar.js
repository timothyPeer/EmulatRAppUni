hmLoadTopic({
hmKeywords:"",
hmTitle:"5.5 GuestMemory - Shared Physical Address Space",
hmDescription:"5.5.1 Definition  GuestMemory represents the entire physical address space visible to all CPUs. It is the conceptual memory system — the single shared physical address space...",
hmPrevLink:"alpha-va-format-contract.html",
hmNextLink:"chapter-5_6-safememory---phsyi.html",
hmParentLink:"chapter-5---memory-system-arch.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-5---memory-system-arch.html\">Chapter 5 - Memory System Architecture<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 5 - Memory System Architecture > 5.5 GuestMemory - Shared Physical Memory",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">5.5 GuestMemory - Shared Physical Address Space<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">5.5.1 Definition<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">GuestMemory represents the entire physical address space visible to all CPUs. It is the conceptual memory system — the single shared physical address space that receives load\/store requests, applies routing, and tracks LL\/SC reservations. There is one global GuestMemory instance shared by all CPUs (accessed via global_GuestMemory()).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">GuestMemory contains:<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Physical RAM (via SafeMemory)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>MMIO regions (via mmio_Manager)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>PA routing table (QVector&lt;PARouteEntry&gt;)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Reservation tracking (via ReservationManager)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Invariant: GuestMemory is global and authoritative. All CPUs observe the same backing store. No per-CPU private memory exists.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">5.5.2 PA Routing Table<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">GuestMemory routes physical addresses to subsystems via a PA routing table (non-overlapping, ordered by PA). Each entry specifies a start PA (inclusive), end PA (exclusive), target subsystem, and an offset base for address translation into the subsystem\'s internal address space.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">struct&nbsp;PARouteEntry&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;quint64&nbsp;startPA;&nbsp;\/\/&nbsp;Inclusive<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;quint64&nbsp;endPA;&nbsp;\/\/&nbsp;Exclusive<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;RouteTarget&nbsp;target;&nbsp;\/\/&nbsp;SafeMemory,&nbsp;MMIOManager<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;quint64&nbsp;offsetBase;&nbsp;\/\/&nbsp;Added&nbsp;to&nbsp;(pa&nbsp;-&nbsp;startPA)&nbsp;for&nbsp;subsystem&nbsp;offset<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">};<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">5.5.3 Default PA Region Map<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The default physical address map (Option A) defines the following non-overlapping regions:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">0x0000_0000 – 0x0001_0000 (64 KB) → SafeMemory — Low memory scratch, includes HWRPB at PA 0x2000<\/p>\n\r<p class=\"p_Normal\">0x0001_0000 – 0x2000_0000 (~512 MB) → Unmapped — Reserved, faults on access<\/p>\n\r<p class=\"p_Normal\">0x2000_0000 – 0x2020_0000 (2 MB) → SRM Firmware — clipper.bin, read-only<\/p>\n\r<p class=\"p_Normal\">0x2020_0000 – 0x8000_0000 (~1.5 GB) → Unmapped — Reserved<\/p>\n\r<p class=\"p_Normal\">0x8000_0000 – 0x8_8000_0000 (32 GB) → SafeMemory — Main RAM<\/p>\n\r<p class=\"p_Normal\">0x8_8000_0000 – 0x10_0000_0000 (~96 GB) → Unmapped — Reserved for future expansion<\/p>\n\r<p class=\"p_Normal\">0x10_0000_0000 – 0x20_0000_0000 (64 GB) → MMIO Manager — Device CSRs, BARs, PCI config<\/p>\n\r<p class=\"p_Normal\">0x20_0000_0000+ → Unmapped — Reserved<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">5.5.4 Read\/Write API<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">GuestMemory provides typed read\/write methods at all standard widths: read8\/write8, read16\/write16, read32\/write32, read64\/write64, and bulk readPA\/writePA. All methods route through the PA routing table via findRoute(pa), which returns the matching PARouteEntry or nullptr (AccessViolation) for unmapped regions.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The routing logic dispatches to SafeMemory::load\/store (for RAM), SRM firmware (read-only), or mmio_Manager::handleRead\/handleWrite (for device regions). The routing path also provides classifyPA() and classifyPARange() for pre-flight address classification.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">5.5.5 Span-Based Access<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">For bulk operations (e.g., HWRPB initialization, PAL CSERVE PUTS), GuestMemory provides getSpanToPA(pa, requestedLen, intent) which returns a MemorySpan — a direct pointer into SafeMemory\'s backing storage. Spans are truncated at page boundaries and are not available for MMIO regions. This avoids per-byte routing overhead for large transfers.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Implementation: GuestMemory.h (286 lines) + GuestMemory.cpp.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-5_6-safememory---phsyi.html\" class=\"topiclink\">5.6 SafeMemory - Phsyical RAM Backend<\/a>; memoryLib\/GuestMemory.h.<\/span><\/p>\n\r"
})
