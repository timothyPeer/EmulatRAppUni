hmLoadTopic({
hmKeywords:"",
hmTitle:"15.9 Memory Barrier Coordination",
hmDescription:"15.9.1 Barrier Mechanics  Memory barriers do not perform memory I\/O. Instead, they stall the pipeline, prevent fetch and speculation, wait until memory system conditions are...",
hmPrevLink:"15_8-ll_sc-reservation-trackin.html",
hmNextLink:"15_10-smp-visibility-guarantee.html",
hmParentLink:"chapter-15---memory-system-imp.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-15---memory-system-imp.html\">Chapter 15 – Memory System Implementation Details<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 15 – Memory System Implementation Details > 15.9 Memory Barrier Coordination",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">15.9 Memory Barrier Coordination<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">15.9.1 Barrier Mechanics<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Memory barriers do not perform memory I\/O. Instead, they stall the pipeline, prevent fetch and speculation, wait until memory system conditions are satisfied (write buffer drain, read queue emptiness), and then release execution. Barrier correctness depends entirely on write buffer state and SMP coordination.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">15.9.2 MemoryBarrierCoordinator – SMP Global Barriers<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The <span class=\"f_CodeExample\">MemoryBarrierCoordinator<\/span> is a singleton that coordinates cross-CPU memory barrier acknowledgment. When a CPU executes an MB instruction in an SMP system with more than one active CPU, the CBox calls <span class=\"f_CodeExample\">initiateGlobalMemoryBarrier(cpuId, activeCpuCount)<\/span>. This sets the <span class=\"f_CodeExample\">barrierInProgress<\/span> flag, initializes the participant count, and the initiating CPU immediately acknowledges. Other CPUs acknowledge via <span class=\"f_CodeExample\">acknowledgeMemoryBarrier(cpuId)<\/span>, which calls <span class=\"f_CodeExample\">Alpha::Memory::fullBarrier()<\/span> (a host-side memory fence) before incrementing the atomic acknowledged counter.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The initiating CPU blocks in <span class=\"f_CodeExample\">waitForBarrierAcknowledge()<\/span> on a <span class=\"f_CodeExample\">QWaitCondition<\/span> until all participating CPUs have acknowledged. A 2-second timeout triggers a machine check exception (SMP barrier timeout) if the <span class=\"f_CodeExample\">MCES&lt;MME&gt;<\/span> IPR bit is enabled. When all CPUs have acknowledged, <span class=\"f_CodeExample\">completeGlobalMemoryBarrier()<\/span> clears the barrier state and wakes all waiters.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">15.9.3 Source Files<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">File<\/span><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Lines (approx)<\/span><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Content<\/span><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">memoryLib\/MemoryBarrierCoordinator.h<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">~278<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Singleton: initiate, acknowledge, wait, timeout\/MCE, state query<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">memoryLib\/global_MemoryBarrierCoordinator.h<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">~30<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Inline singleton accessor<\/p>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-6---serialization-and-.html\" class=\"topiclink\">Chapter 6 - Serialization and Stall Model<\/a>; <a href=\"14_5-cbox---cache-_-control-bo.html\" class=\"topiclink\">14.5.4 CBox – Cache \/ Control Box (serialization types)<\/a>; grainFactoryLib\/MemoryBarrier_core.h – Barrier type definitions.<\/span><\/p>\n\r"
})
