hmLoadTopic({
hmKeywords:"",
hmTitle:"Interrupt - Methodology & Convention",
hmDescription:"IPR-ORDER-OF-OPERATIONS.TXT  (ASCII)  ## Goal  Define a concrete, stepwise \"state transition script\" for an EV6 (21264) interrupt delivery and return path, expressed as *bitwi",
hmPrevLink:"",
hmNextLink:"",
hmParentLink:"appendix---trait-examples.html",
hmBreadCrumbs:"",
hmTitlePath:"Introduction > Appendix > Appendix I â€“ Global Singletons",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">Interrupt - Methodology &amp; Convention<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">IPR-ORDER-OF-OPERATIONS.TXT &nbsp;(ASCII)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## Goal<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Define a concrete, stepwise &quot;state transition script&quot; for an EV6 (21264) interrupt<\/p>\n\r<p class=\"p_Normal\">delivery and return path, expressed as *bitwise deltas* to architectural state.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## Conventions used here<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* &quot;PALmode&quot; is indicated by PC[0] (LSB). PC[0]=1 means PALmode active.<\/p>\n\r<p class=\"p_Normal\">* &quot;CM&quot; (Current Mode) is a field in the processor status state (PS). On EV6,<\/p>\n\r<p class=\"p_Normal\"> &nbsp;PS contains the architectural mode state (K\/E\/S\/U). PAL execution is effectively<\/p>\n\r<p class=\"p_Normal\"> &nbsp;at Kernel privilege.<\/p>\n\r<p class=\"p_Normal\">* ICCSR is the Interrupt Control and CPU Status Register (EV6 IPR) that gates<\/p>\n\r<p class=\"p_Normal\"> &nbsp;delivery (interrupt enable, IPL, pending summary, etc.). Exact bit names vary<\/p>\n\r<p class=\"p_Normal\"> &nbsp;by implementation, but the ordering requirements are stable.<\/p>\n\r<p class=\"p_Normal\">* EXC_ADDR is the Exception Address IPR: restart\/continuation PC for the event.<\/p>\n\r<p class=\"p_Normal\">* EXC_SUM is the Exception Summary IPR: reason classification (interrupt vs fault,<\/p>\n\r<p class=\"p_Normal\"> &nbsp;and which class), plus sticky indicators.<\/p>\n\r<p class=\"p_Normal\">* HWPCB points to the per-CPU Hardware PCB save area used by PAL entry\/exit.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Important: the EV6 reference manual distinguishes &quot;what the hardware must do<\/p>\n\r<p class=\"p_Normal\">architecturally&quot; from &quot;what PALcode does as policy&quot;. Below is the architectural<\/p>\n\r<p class=\"p_Normal\">minimum plus the typical EV6 PAL policy actions, clearly separated.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## A. INTERRUPT REQUEST ARRIVES (NO PALMODE)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">A0. External condition asserts an interrupt request<\/p>\n\r<p class=\"p_Normal\">- Source can be I\/O interrupt controller, timer, IPI, corrected MCHK, etc.<\/p>\n\r<p class=\"p_Normal\">- Bitwise effect:<\/p>\n\r<p class=\"p_Normal\">* Some per-CPU pending latch is set. Architecturally visible as a pending<\/p>\n\r<p class=\"p_Normal\">condition via ICCSR (pending summary \/ request bits) and\/or via a<\/p>\n\r<p class=\"p_Normal\">platform-specific interrupt controller CSR. The CPU does not vector yet.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">A1. Eligibility check point (performed at defined points in the pipeline)<\/p>\n\r<p class=\"p_Normal\">Hardware evaluates:<\/p>\n\r<p class=\"p_Normal\">- PC[0] == 0 &nbsp;(not in PALmode)<\/p>\n\r<p class=\"p_Normal\">- Interrupts enabled (ICCSR.IE == 1, and\/or PS.IE == 1 depending on EV6<\/p>\n\r<p class=\"p_Normal\">implementation; EV6 uses ICCSR as the primary gate)<\/p>\n\r<p class=\"p_Normal\">- IPL allows delivery (ICCSR.IPL &lt; request_level) or equivalent.<\/p>\n\r<p class=\"p_Normal\">- No higher-priority synchronous exception is taking precedence.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">This is a &quot;check step&quot; in your sequence model. No state changes yet.<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">A2. Commit-to-deliver (the moment the CPU decides &quot;this interrupt will be taken&quot;)<\/p>\n\r<p class=\"p_Normal\">Ordering requirements you listed begin here.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">A2.1 Pipeline drain \/ precise state point<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; - Required architectural property:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; * All older instructions are completed (retired) with their architected<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; effects, or an older exception wins and this interrupt is deferred.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; * For interrupts, EV6 requires a precise point: the continuation PC<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; corresponds to the next instruction that would have executed.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; - Typical EV6 requirement also includes completion of outstanding<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; D-cache fills prior to vectoring (as you stated).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">A2.2 Latch the continuation PC into EXC_ADDR<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; - Bitwise effect:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; * EXC_ADDR := continuation_pc<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; (continuation_pc is the address of the next instruction to execute<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if the interrupt had not occurred; i.e., restart point.)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; - NOTE:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; * EXC_ADDR itself does not &quot;cause PALmode&quot;; it is just storage.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; * The LSB convention is about the PC that becomes active; EXC_ADDR<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; typically holds a non-PAL address (PC[0]=0) for normal return.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">A2.3 Record reason\/classification into EXC_SUM<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; - Bitwise effect:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; * EXC_SUM.INTERRUPT_CLASS (or equivalent summary bits) set.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; * EXC_SUM may also capture &quot;which vector family&quot; (INTERRUPT vs MCHK<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; vs ARITH vs ITB\/DTB vs CALL_PAL). Exact encoding is EV6-specific,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; but the key point is: EXC_SUM is written BEFORE PAL dispatch so PAL<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; can interrogate it.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">A2.4 Enter PALmode (hardware state transition)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; - Bitwise effect (architectural):<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; * PC[0] becomes 1 for the active fetch PC (PAL dispatch address).<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; (Implementation may set an internal PAL flag derived from PC[0].)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; * Current privilege becomes Kernel for PAL execution:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PS.CM := KERNEL<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; (If your model has an explicit IER_CM or PS&lt;CM&gt;, treat this as the<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;single authoritative update point.)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; * Interrupt delivery is disabled while in PAL:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ICCSR.IE := 0 &nbsp; (and\/or PS.IE := 0 if modeled separately)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; This is the &quot;Disable Interrupts when entering PALmode&quot; step.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">A2.5 Disable or bypass I-stream VA translation for PAL fetch<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; - Bitwise effect:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; * &quot;I-stream mapping enable&quot; is forced off for PAL fetch<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; (often modeled as ITB enable gating).<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; * In an emulator: treat this as &quot;PAL fetch uses physical addressing&quot;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; unless your model already implements the EV6 PAL I-stream rules.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">A2.6 Load PAL vector PC (dispatch)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; - Bitwise effect:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; * New PC := PAL_BASE + vector_offset_for_interrupt<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; * Force PC[0] := 1 (PALmode indicator)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; - Vector offset depends on event class; &quot;interrupt&quot; vectors are distinct<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; from faults (DTB miss, etc.).<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">At this point, PALcode begins executing.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## B. PAL INTERRUPT HANDLING (POLICY, STILL IPR-CENTRIC)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">B0. PAL begins with interrupts effectively disabled<\/p>\n\r<p class=\"p_Normal\">- Already achieved by A2.4.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">B1. PAL determines the specific interrupt source<\/p>\n\r<p class=\"p_Normal\">- Reads:<\/p>\n\r<p class=\"p_Normal\">* ICCSR (pending summary\/level)<\/p>\n\r<p class=\"p_Normal\">* Platform interrupt controller registers (not IPR, but often memory-mapped)<\/p>\n\r<p class=\"p_Normal\">* IPIR state if it is an IPI<\/p>\n\r<p class=\"p_Normal\">- Bitwise effect:<\/p>\n\r<p class=\"p_Normal\">* None yet (reads only).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">B2. PAL performs acknowledgment\/clear at the appropriate layer<\/p>\n\r<p class=\"p_Normal\">- IMPORTANT separation:<\/p>\n\r<p class=\"p_Normal\">* CPU-level &quot;pending&quot; summary may clear by:<\/p>\n\r<p class=\"p_Normal\">- writing ICCSR (if the architecture provides W1C semantics), and\/or<\/p>\n\r<p class=\"p_Normal\">- reading a platform &quot;ack&quot; register, and\/or<\/p>\n\r<p class=\"p_Normal\">- servicing the interrupt controller so it deasserts the level.<\/p>\n\r<p class=\"p_Normal\">* Many EV6 systems are level-triggered; the CPU pending will reassert if<\/p>\n\r<p class=\"p_Normal\">the platform source is not cleared.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">In your sequence model, make this explicit as:<\/p>\n\r<p class=\"p_Normal\"> &nbsp;- &quot;Clear platform source&quot; step (non-IPR)<\/p>\n\r<p class=\"p_Normal\"> &nbsp;- &quot;Clear CPU summary latch&quot; step (IPR, if applicable)<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">B3. PAL decides whether and when to re-enable interrupts inside PAL<\/p>\n\r<p class=\"p_Normal\">- Often: PAL keeps interrupts disabled except in carefully controlled windows.<\/p>\n\r<p class=\"p_Normal\">- If re-enabled:<\/p>\n\r<p class=\"p_Normal\">ICCSR.IE := 1<\/p>\n\r<p class=\"p_Normal\">but PALmode remains active (PC[0]=1), so delivery may still be constrained<\/p>\n\r<p class=\"p_Normal\">by EV6 rules (implementation policy).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## C. RETURN FROM PAL (HW_REI PATH)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">C0. PAL prepares return state (if needed)<\/p>\n\r<p class=\"p_Normal\">- PAL may update:<\/p>\n\r<p class=\"p_Normal\">* EXC_ADDR (rare, but possible if it wants to redirect return)<\/p>\n\r<p class=\"p_Normal\">* HWPCB save slots<\/p>\n\r<p class=\"p_Normal\">* PS fields (if PAL is responsible for restoring a prior mode snapshot)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">In a minimal interrupt handler, EXC_ADDR already contains the correct return PC.<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">C1. Execute HW_REI (hardware return from exception\/interrupt)<\/p>\n\r<p class=\"p_Normal\">This is the &quot;point of no ambiguity&quot; where the hardware consumes IPR state.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">C1.1 Load return PC from EXC_ADDR<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; - Bitwise effect:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; * New PC := EXC_ADDR<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; - PALmode determination:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; * If New PC[0] == 0, hardware exits PALmode.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; * If New PC[0] == 1, hardware remains in PALmode (used for chaining<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; or returning into PAL).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">C1.2 Exit PALmode (typical interrupt return case)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; If New PC[0] == 0:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; - Bitwise effects:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; * PALmode flag cleared (derived from PC[0]=0).<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; * Re-enable I-stream VA translation (restore ITB enable gating).<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; * Restore interrupt enable state:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ICCSR.IE := 1 &nbsp;(or restored from a saved PS\/IE snapshot)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; * Restore current mode:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PS.CM := prior_mode<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (On a pure interrupt return to kernel, prior_mode is often kernel;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;on user return, prior_mode is user.)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; NOTE ON &quot;which register owns Kernel Mode&quot;:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; - Treat PS.CM (processor status current mode) as the single owner.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; ICCSR does NOT own the current privilege mode; it owns interrupt<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; gating and priority (IPL) policy. If you have an IER_CM field in<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; your codebase, it should either be an alias to PS.CM or eliminated<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; to avoid dual sources of truth.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">C1.3 Exception summary cleanup (optional but typical)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; - Some EXC_SUM bits are sticky until explicitly cleared by PAL.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; - Model explicitly:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; EXC_SUM.interrupt_taken := 0 &nbsp; (if defined as a latch)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; or:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; EXC_SUM := (EXC_SUM &amp; ~INT_BITS)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; depending on your EV6 definition.<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## D. YOUR &quot;TRIVIAL SEQUENCE&quot; REWRITTEN AS A STRICT STEP TABLE<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Below is your list normalized and de-duplicated, with explicit deltas:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1. Interrupt pending asserted<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * ICCSR.PENDING := 1 (or equivalent summary becomes 1)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * No vector yet.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">2. Eligibility check<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * Require PC[0]==0, ICCSR.IE==1, IPL allows.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">3. Drain to precise point<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * Pipeline drained; outstanding D-cache fills completed (EV6 rule you cited).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">4. Save continuation PC<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * EXC_ADDR := continuation_pc &nbsp;(typically PC[0]=0)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">5. Record event class<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * EXC_SUM := EXC_SUM OR INT_CLASS_BITS<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">6. Enter PALmode and disable interrupts<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * Active fetch PC will be PAL vector PC with PC[0]=1<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * PS.CM := KERNEL<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * ICCSR.IE := 0<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * I-stream mapping forced off for PAL fetch<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">7. Dispatch PAL vector<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * PC := PAL_BASE + INTERRUPT_VECTOR_OFFSET<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * PC[0] := 1<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">8. PAL services interrupt source (policy)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * Read ICCSR\/platform regs<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * Clear platform source<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * Optionally clear ICCSR pending latch if writable-clearing exists<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">9. HW_REI executed<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * PC := EXC_ADDR<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">10. Exit PALmode if PC[0]==0<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;* PALmode cleared<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;* I-stream mapping restored<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;* ICCSR.IE restored to 1 (or restored snapshot)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;* PS.CM restored to prior mode (Kernel or User)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">11. Resume fetch at PC with normal interrupt gating<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## E. WHAT I NEED FROM YOUR HEADERS (NO QUESTIONS, JUST A CHECKLIST)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">When you upload your interrupt headers, I will map them to this sequence and<\/p>\n\r<p class=\"p_Normal\">produce a &quot;bit-delta audit&quot; that answers, for each step:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Which write occurs (ICCSR, EXC_ADDR, EXC_SUM, PS, HWPCB)<\/p>\n\r<p class=\"p_Normal\">* Exactly which bits are set\/cleared (W1C\/W1S semantics if used)<\/p>\n\r<p class=\"p_Normal\">* Where PALmode is derived (PC[0] only, or duplicated flags)<\/p>\n\r<p class=\"p_Normal\">* Where &quot;disable interrupts&quot; is implemented (ICCSR.IE vs PS.IE duplication)<\/p>\n\r<p class=\"p_Normal\">* Where &quot;current mode&quot; is implemented (PS.CM only, not ICCSR)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If your current code stores &quot;PALmode&quot; and &quot;CM&quot; in multiple places, I will<\/p>\n\r<p class=\"p_Normal\">recommend a single-source-of-truth rule and show the exact reorder-safe update<\/p>\n\r<p class=\"p_Normal\">points to avoid OoO artifacts in the emulator.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Upload the headers when ready.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r"
})
