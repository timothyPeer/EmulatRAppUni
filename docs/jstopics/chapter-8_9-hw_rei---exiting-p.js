hmLoadTopic({
hmKeywords:"",
hmTitle:"8.9 HW_REI - Exiting PAL Mode",
hmDescription:"8.9.1 Purpose  HW_REI (Hardware Return from Exception\/Interrupt) is the only architecturally legal exit from PAL mode. It restores processor execution from a privileged PAL...",
hmPrevLink:"chapter-8_8-pal-and-memory-ord.html",
hmNextLink:"chapter-8_10-enforcing-the-pri.html",
hmParentLink:"chapter-8---pal-and-privleged-.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-8---pal-and-privleged-.html\">Chapter 8 - PAL and Privileged Boundary<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 8 - PAL and Privileged Boundary > 8.9 HW_REI - Exiting PAL Mode",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">8.9 HW_REI - Exiting PAL Mode<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">8.9.1 Purpose<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">HW_REI (Hardware Return from Exception\/Interrupt) is the only architecturally legal exit from PAL mode. It restores processor execution from a privileged PAL context back to the interrupted or faulted execution context while preserving precise architectural state. No other instruction may exit PAL mode, restore privilege level, or resume interrupted execution. Any attempt to bypass HW_REI is architecturally illegal and must fault.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">8.9.2 Implementation<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">AlphaCPU::executeREI() performs a complete architectural state restore:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">BoxResult&nbsp;executeREI(PipelineSlot&amp;&nbsp;slot)&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;1.&nbsp;Restore&nbsp;COMPLETE&nbsp;context&nbsp;(HWPCB&nbsp;+&nbsp;registers)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;m_iprGlobalMaster-&gt;restoreContext();<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;2.&nbsp;Get&nbsp;return&nbsp;PC&nbsp;(now&nbsp;restored)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;quint64&nbsp;returnPC&nbsp;=&nbsp;m_iprGlobalMaster-&gt;h-&gt;pc;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;3.&nbsp;Setup&nbsp;pipeline&nbsp;redirect<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;slot.reiTarget&nbsp;=&nbsp;returnPC;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;slot.pcModified&nbsp;=&nbsp;true;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;4.&nbsp;Flush&nbsp;pipeline<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;return&nbsp;BoxResult().flushPipeline();<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">}<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">restoreContext() performs a full vector copy from the saved register-context snapshot back into the active processor state. This includes integer registers, floating-point registers (if enabled), PS, IPL, PC, and relevant internal execution state.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">8.9.3 Restored State<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">On HW_REI execution, the following state is restored atomically:<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Program Counter (PC) — instruction address at which execution resumes<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Processor Mode (CM) — returns to prior mode (User, Supervisor, Executive, or Kernel)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Processor Status (PS) — condition codes, interrupt enable state, architectural flags<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Interrupt Priority Level (IPL) — restores prior IPL for correct interrupt arbitration<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Interrupt state — re-enables or maintains interrupt masking as defined by the restored PS<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">8.9.4 Serialization Guarantees<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">HW_REI is an implicit serialization point. Before execution resumes: PAL execution completes, write buffers are drained if required, LL\/SC reservations are cleared, pipeline is flushed, and instruction fetch restarts at the restored PC. No speculative instruction may execute across an HW_REI boundary.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">8.9.5 Design Rationale<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">EMulatR\'s choice to restore the full register context (rather than selectively restoring fields) provides stronger correctness guarantees, easier verification and debugging, and clear separation between PAL and non-PAL execution. No residual PAL state leaks into non-PAL execution. This is a deliberate design choice that supports nested exceptions, SMP preemption, and debugger integration.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r"
})
