hmLoadTopic({
hmKeywords:"",
hmTitle:"19.2 IRQPendingState Implementation",
hmDescription:"19.2.1 Per-CPU Tracking Structure  IRQPendingState (coreLib\/IRQPendingState.h, ~378 lines) is the per-CPU interrupt tracking structure. It is the central data structure through...",
hmPrevLink:"19_1-interrupt-sources.html",
hmNextLink:"19_3-interrupt-routing.html",
hmParentLink:"chapter-19---debugging_-tracin.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-19---debugging_-tracin.html\">Chapter 19 – Interrupt Architecture &amp; IPI<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 19 – Interrupt Architecture & IPI > 19.2 IRQPendingState Implementation",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">19.2 IRQPendingState Implementation<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">19.2.1 Per-CPU Tracking Structure<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">IRQPendingState<\/span> (<span class=\"f_CodeExample\">coreLib\/IRQPendingState.h<\/span>, ~378 lines) is the per-CPU interrupt tracking structure. It is the central data structure through which all interrupt sources (devices, software, IPIs) communicate pending interrupts to the CPU. Its design is driven by the cross-thread safety requirement: device I\/O threads may assert interrupts at any time while the CPU thread checks for deliverable interrupts every cycle.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">19.2.2 Data Structures<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Field<\/span><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Purpose<\/span><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">pendingLevelsMask<\/span> (<span class=\"f_CodeExample\">atomic&lt;quint32&gt;<\/span>)<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Summary bitset: bit L set means at least one pending source at IPL L. Provides a single fast check for &quot;what needs attention.&quot;<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">pendingSourcesByLevel<\/span> (array of <span class=\"f_CodeExample\">atomic&lt;quint64&gt;<\/span>)<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Per-level source bitmask — up to 64 interrupt sources per level. Identifies which specific device or source triggered the interrupt.<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">highestPendingLevel<\/span> (<span class=\"f_CodeExample\">atomic&lt;quint8&gt;<\/span>)<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Cached highest pending IPL for ultra-fast per-instruction checking. 0xFF means &quot;nothing pending.&quot; Updated atomically by raise\/clear\/claim operations.<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">inServiceMask<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">CPU-thread-only mask tracking claimed (in-service) level-triggered interrupts. Not atomic — only accessed by the owning CPU thread.<\/p>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Additionally, per-source static configuration records the trigger mode (edge or level), SCB vector index, and IPL assignment for each interrupt source.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">19.2.3 Hot-Path Operations<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The interrupt check is the second-hottest path in the emulator (after <span class=\"f_CodeExample\">FaultDispatcher::eventPending()<\/span>). The key operations:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">hasDeliverable(currentIPL)<\/span> — tests whether any pending interrupt level exceeds the current IPL. Implementation: single atomic load of <span class=\"f_CodeExample\">highestPendingLevel<\/span> and comparison against <span class=\"f_CodeExample\">currentIPL<\/span>. Cost: ~5 cycles (one atomic load, one compare). Returns immediately if nothing pending (0xFF).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">claimNext()<\/span> — atomically claims the highest-priority pending interrupt and returns a <span class=\"f_CodeExample\">ClaimedInterrupt<\/span> containing the source, IPL, and vector. For level-triggered interrupts, the source is added to <span class=\"f_CodeExample\">inServiceMask<\/span>. For edge-triggered interrupts, the pending bit is cleared atomically.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">raiseInterrupt(sourceId, ipl)<\/span> — called by device threads to assert an interrupt. Sets the source bit in <span class=\"f_CodeExample\">pendingSourcesByLevel[ipl]<\/span>, sets the level bit in <span class=\"f_CodeExample\">pendingLevelsMask<\/span>, and updates <span class=\"f_CodeExample\">highestPendingLevel<\/span> if the new level is higher. All operations use <span class=\"f_CodeExample\">memory_order_release<\/span> to ensure device-side data is visible to the CPU thread.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">clearInterrupt(sourceId, ipl)<\/span> — called when a device deasserts its interrupt line. Clears the source bit; if no sources remain at that level, clears the level bit and recalculates <span class=\"f_CodeExample\">highestPendingLevel<\/span>.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: coreLib\/IRQPendingState.h (~378 lines); <a href=\"chapter-7_9-interrupt-handling.html\" class=\"topiclink\">7.10 Interrupt Handling<\/a>.<\/span><\/p>\n\r"
})
