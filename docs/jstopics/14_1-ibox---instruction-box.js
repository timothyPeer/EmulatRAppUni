hmLoadTopic({
hmKeywords:"",
hmTitle:"14.1 IBox – Instruction Box",
hmDescription:"The IBox is the instruction-supply front end of the emulated processor. It owns the fetch-decode pipeline and manages two levels of decode caching to accelerate repeated...",
hmPrevLink:"chapter-14---execution-domains.html",
hmNextLink:"14_2-ebox---integer-execution-.html",
hmParentLink:"chapter-14---execution-domains.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-14---execution-domains.html\">Chapter 14 – Execution Domains (“Boxes”)<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 14 – Execution Domains (“Boxes”) > 14.1 IBox – Instruction Box",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">14.1 IBox – Instruction Box<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">The IBox is the instruction-supply front end of the emulated processor. It owns the fetch-decode pipeline and manages two levels of decode caching to accelerate repeated instruction sequences. On the Alpha 21264 silicon, the Ibox encompassed the fetch unit, branch predictor, instruction-stream TLB (ITB), issue queues, and register rename maps. In EmulatR, the IBox focuses specifically on fetch coordination and instruction decode; branch prediction and issue queuing are handled by the CBox and the pipeline manager respectively.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">14.1.1 Responsibilities<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>PC-driven instruction fetch coordination<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Instruction decode via the GrainResolver (opcode-to-grain mapping)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Two-level decode cache: <span class=\"f_CodeExample\">PcDecodeCache<\/span> (virtual PC key, 64 entries) and <span class=\"f_CodeExample\">PaDecodeCache<\/span> (physical address key, 64 entries)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span><span class=\"f_CodeExample\">FetchResult<\/span> generation for downstream pipeline consumption<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>VA-to-PA translation delegation to MBox for ITB lookups<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>CALL_PAL detection and early routing to PalBox<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">14.1.2 Key Interfaces<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Method<\/span><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Return Type<\/span><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Description<\/span><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">fetchNext()<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">FetchResult<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Top-level fetch entry point; drives one cycle of instruction supply<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">fetchAndDecode(FetchResult&amp;)<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">bool<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Fetch and decode a single instruction into the provided FetchResult<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">tryFetchFromCache(FetchResult&amp;)<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">bool<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Attempt cache-first decode (PC cache, then PA cache promotion)<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">fetchFromMemory(FetchResult&amp;)<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">bool<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Full-path fetch: translate VA, read GuestMemory, decode, populate caches<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">invalidateDecodeCache()<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">void<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Flush both PC and PA decode caches (triggered by IMB, context switch)<\/p>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">14.1.3 Decode Cache Architecture<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The IBox maintains two independent decode caches to avoid redundant instruction decoding. The <span class=\"f_CodeExample\">PcDecodeCache<\/span> is indexed by virtual PC and provides the fastest lookup path for tight loops and repeated code sequences. The <span class=\"f_CodeExample\">PaDecodeCache<\/span> is indexed by physical address and serves as a fallback when the virtual mapping has changed but the underlying physical instruction is still valid. A PA cache hit triggers automatic promotion into the PC cache for subsequent fast access.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Both caches use a direct-mapped structure with 64 entries and a simple index mask. Each entry stores the full <span class=\"f_CodeExample\">DecodedInstruction<\/span> along with the lookup key and a validity flag.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">14.1.4 Code Example – Fetch and Decode Path<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">AXP_HOT&nbsp;AXP_FLATTEN&nbsp;bool&nbsp;fetchAndDecode(FetchResult&amp;&nbsp;fr)&nbsp;noexcept&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;quint64&nbsp;pc&nbsp;=&nbsp;m_iprGlobalMaster-&gt;h-&gt;pc;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;\/\/&nbsp;Attempt&nbsp;cache-first&nbsp;lookup<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(tryFetchFromCache(fr))<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;\/\/&nbsp;Cache&nbsp;miss&nbsp;—&nbsp;full&nbsp;translate&nbsp;+&nbsp;memory&nbsp;fetch<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;fetchFromMemory(fr);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">}<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">14.1.5 Source Files<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">File<\/span><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Lines (approx)<\/span><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Content<\/span><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">IBoxLib\/IBoxBase.h<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">~842<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Complete IBox class, PcDecodeCache, PaDecodeCache, FetchStats<\/p>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: grainFactoryLib\/DecodedInstruction.h – DecodedInstruction structure; coreLib\/FetchResult.h – FetchResult pipeline transport type; pteLib\/ev6Translation_struct.h – Translation result structure.<\/span><\/p>\n\r"
})
