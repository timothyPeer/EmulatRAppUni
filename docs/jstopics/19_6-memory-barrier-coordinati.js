hmLoadTopic({
hmKeywords:"",
hmTitle:"19.6 Memory Barrier Coordination",
hmDescription:"19.6.1 MemoryBarrierCoordinator  MemoryBarrierCoordinator (memoryLib\/MemoryBarrierCoordinator.h, ~278 lines) is a singleton accessed via global_MemoryBarrierCoordinator() that...",
hmPrevLink:"19_5-ipi-architecture.html",
hmNextLink:"19_7-tlb-shootdown-protocol.html",
hmParentLink:"chapter-19---debugging_-tracin.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-19---debugging_-tracin.html\">Chapter 19 – Interrupt Architecture &amp; IPI<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 19 – Interrupt Architecture & IPI > 19.6 Memory Barrier Coordination",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">19.6 Memory Barrier Coordination<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">19.6.1 MemoryBarrierCoordinator<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">MemoryBarrierCoordinator<\/span> (<span class=\"f_CodeExample\">memoryLib\/MemoryBarrierCoordinator.h<\/span>, ~278 lines) is a singleton accessed via <span class=\"f_CodeExample\">global_MemoryBarrierCoordinator()<\/span> that manages global memory barrier synchronization across all CPUs. It tracks barrier state: <span class=\"f_CodeExample\">barrierInProgress<\/span> (atomic bool), <span class=\"f_CodeExample\">initiatingCpu<\/span>, <span class=\"f_CodeExample\">participatingCpus<\/span> count, <span class=\"f_CodeExample\">waitingCpus<\/span> count (atomic), <span class=\"f_CodeExample\">acknowledgedCpus<\/span> count (atomic), and a <span class=\"f_CodeExample\">QWaitCondition<\/span> (<span class=\"f_CodeExample\">barrierComplete<\/span>) for blocking the initiating CPU until all acknowledgments arrive.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">19.6.2 Global Barrier Sequence<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">When CPU N executes MB in an SMP configuration:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">1.&nbsp;CBox::executeMB()&nbsp;drains&nbsp;the&nbsp;local&nbsp;write&nbsp;buffer<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">2.&nbsp;CBox::RequestMemoryBarrier()<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;→&nbsp;ExecutionCoordinator::requestMemoryBarrier(cpuId)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">3.&nbsp;MemoryBarrierCoordinator::initiateGlobalMemoryBarrier(cpuId,&nbsp;activeCpuCount)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;If&nbsp;activeCpuCount&nbsp;==&nbsp;1&nbsp;→&nbsp;barrier&nbsp;completes&nbsp;immediately&nbsp;(returns&nbsp;false)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;If&nbsp;barrier&nbsp;already&nbsp;in&nbsp;progress&nbsp;→&nbsp;CPU&nbsp;joins&nbsp;existing&nbsp;barrier&nbsp;(returns&nbsp;false)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">4.&nbsp;Coordinator&nbsp;initializes&nbsp;barrier&nbsp;state<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;Initiating&nbsp;CPU&nbsp;self-acknowledges&nbsp;immediately<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">5.&nbsp;ExecutionCoordinator&nbsp;sends&nbsp;MEMORY_BARRIER_FULL&nbsp;IPIs&nbsp;to&nbsp;all&nbsp;other&nbsp;active&nbsp;CPUs<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;encodeIPIData(IPICommand::MEMORY_BARRIER_FULL,&nbsp;0)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">6.&nbsp;Initiating&nbsp;CPU&nbsp;calls&nbsp;waitForBarrierAcknowledge(cpuId)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;Blocks&nbsp;on&nbsp;QWaitCondition&nbsp;with&nbsp;2-second&nbsp;timeout<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">7.&nbsp;Target&nbsp;CPUs:&nbsp;receive&nbsp;IPI&nbsp;→&nbsp;enter&nbsp;PAL&nbsp;→&nbsp;drain&nbsp;write&nbsp;buffers<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;→&nbsp;call&nbsp;acknowledgeMemoryBarrier(cpuId)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">8.&nbsp;All&nbsp;CPUs&nbsp;acknowledged&nbsp;→&nbsp;QWaitCondition&nbsp;signaled<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;barrierInProgress&nbsp;cleared&nbsp;→&nbsp;initiating&nbsp;CPU&nbsp;resumes<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">19.6.3 Local vs Global Barriers<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">WMB<\/span> is local-only — it drains the local write buffer with no global coordination and no IPIs. This makes WMB significantly cheaper than MB in SMP configurations. <span class=\"f_CodeExample\">MB<\/span> requires global coordination when <span class=\"f_CodeExample\">activeCpuCount &gt; 1<\/span>. PAL barriers (<span class=\"f_CodeExample\">MemoryBarrierKind::PAL<\/span>) use the same global coordination path as MB.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">19.6.4 Barrier Timeout and Machine Check<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If the 2-second timeout expires before all CPUs acknowledge, the coordinator raises a machine check event (<span class=\"f_CodeExample\">MachineCheckReason::SMP_BARRIER_TIMEOUT<\/span>) via the FaultDispatcher. The MCES register\'s MME bit determines whether this is a fatal error or suppressed. This prevents a hung CPU from deadlocking the system — the timeout acts as a safety valve for SMP correctness.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: memoryLib\/MemoryBarrierCoordinator.h (~278 lines); emulatrLib\/ExecutionCoordinator.h – requestMemoryBarrier(); <a href=\"chapter-9_7-reservation-invali.html\" class=\"topiclink\">9.7 Memory Barrier Coordination<\/a>; <a href=\"chapter-6---serialization-and-.html\" class=\"topiclink\">Chapter 6 - Serialization and Stall Model<\/a>.<\/span><\/p>\n\r"
})
