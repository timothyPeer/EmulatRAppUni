hmLoadTopic({
hmKeywords:"",
hmTitle:"Chapter 13 – AlphaPipeline Implementation",
hmDescription:"Below is a **clean, final, drop-in Chapter 13 – AlphaPipeline Implementation**, written in the same tone, rigor, and discipline as Chapter 12.",
hmPrevLink:"12_13-summary.html",
hmNextLink:"13_1-purpose-of-this-chapter.html",
hmParentLink:"architecture-overview.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 13 – AlphaPipeline Implementation",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">Chapter 13 – AlphaPipeline Implementation<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">Below is a **clean, final, drop-in Chapter 13 – AlphaPipeline Implementation**, written in the same tone, rigor, and discipline as Chapter 12.<\/p>\n\r<p class=\"p_Normal\">This chapter is **mechanical and implementation-oriented**, not conceptual. It explains *exactly how the pipeline works, how stalls propagate, and how correctness is enforced*.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"># Chapter 13 – AlphaPipeline Implementation<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 13.1 Purpose of This Chapter<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This chapter documents the **AlphaPipeline** implementation: the internal execution conveyor that moves decoded instructions (“grains”) from fetch through architectural retirement.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This chapter answers:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* How instructions flow through the pipeline<\/p>\n\r<p class=\"p_Normal\">* How stalls, flushes, and serialization are enforced<\/p>\n\r<p class=\"p_Normal\">* Where architectural state becomes visible<\/p>\n\r<p class=\"p_Normal\">* How correctness is guaranteed in the presence of speculation<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This chapter does **not** define instruction semantics — those live in grains and execution boxes.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 13.2 Pipeline Role in EmulatR<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The AlphaPipeline is a **single-issue, in-order, cycle-driven pipeline** that models Alpha AXP execution behavior with weak ordering and precise exceptions.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Key principles:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* One instruction may retire per cycle<\/p>\n\r<p class=\"p_Normal\">* Instructions advance one stage per cycle unless stalled<\/p>\n\r<p class=\"p_Normal\">* All execution happens in **EX stage**<\/p>\n\r<p class=\"p_Normal\">* Commit occurs only in **WB stage**<\/p>\n\r<p class=\"p_Normal\">* Pipeline state is owned exclusively by AlphaCPU<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 13.3 Pipeline Structure<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 13.3.1 Pipeline Stages<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The pipeline consists of **six fixed stages**:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">| Stage | Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Responsibility &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| ----: | -------------- | ----------------------------------------- |<\/p>\n\r<p class=\"p_Normal\">| &nbsp; &nbsp; 0 | Fetch (IF) &nbsp; &nbsp; | Fetch instruction, resolve branch targets |<\/p>\n\r<p class=\"p_Normal\">| &nbsp; &nbsp; 1 | Decode (ID) &nbsp; &nbsp;| Attach decoded grain (mostly bookkeeping) |<\/p>\n\r<p class=\"p_Normal\">| &nbsp; &nbsp; 2 | Issue (IS) &nbsp; &nbsp; | Operand readiness &amp; hazard checks &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| &nbsp; &nbsp; 3 | Execute (EX) &nbsp; | **All real work occurs here** &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| &nbsp; &nbsp; 4 | Memory (MEM) &nbsp; | Advancement only (execution already done) |<\/p>\n\r<p class=\"p_Normal\">| &nbsp; &nbsp; 5 | Writeback (WB) | Architectural commit &amp; PC update &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The pipeline advances **backward (WB → IF)** each cycle to prevent data hazards.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 13.4 PipelineSlot Structure<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Each stage holds a **PipelineSlot**, which represents one in-flight instruction.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 13.4.1 Slot Contents<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">A PipelineSlot contains:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Decoded instruction metadata (`DecodedInstruction`)<\/p>\n\r<p class=\"p_Normal\">* Pointer to resolved grain<\/p>\n\r<p class=\"p_Normal\">* Operand values<\/p>\n\r<p class=\"p_Normal\">* Execution results (payload)<\/p>\n\r<p class=\"p_Normal\">* Branch target (if applicable)<\/p>\n\r<p class=\"p_Normal\">* Stall flags<\/p>\n\r<p class=\"p_Normal\">* Serialization type<\/p>\n\r<p class=\"p_Normal\">* Exception \/ fault metadata<\/p>\n\r<p class=\"p_Normal\">* Valid \/ invalid state<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Slots are lightweight and reused aggressively.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 13.5 Instruction Lifetime<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 13.5.1 Fetch → Decode<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* IF fetches raw instruction<\/p>\n\r<p class=\"p_Normal\">* IBox resolves or creates grain<\/p>\n\r<p class=\"p_Normal\">* Grain pointer is attached to slot<\/p>\n\r<p class=\"p_Normal\">* Slot becomes valid in Decode stage<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">No execution occurs here.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 13.5.2 Decode → Issue<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Slot metadata is validated<\/p>\n\r<p class=\"p_Normal\">* Privilege checks may enqueue exceptions<\/p>\n\r<p class=\"p_Normal\">* Functional requirements are identified<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Decode is intentionally minimal.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 13.5.3 Issue → Execute<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Source operands are read<\/p>\n\r<p class=\"p_Normal\">* Register hazards are checked<\/p>\n\r<p class=\"p_Normal\">* Forwarding may occur<\/p>\n\r<p class=\"p_Normal\">* If operands unavailable → stall<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is the **last gate before execution**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 13.5.4 Execute Stage (Critical)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**All instruction semantics occur here.**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">In EX:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```cpp<\/p>\n\r<p class=\"p_Normal\">slot.di.grain-&gt;execute(slot);<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The grain:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Performs arithmetic or logical work<\/p>\n\r<p class=\"p_Normal\">* Executes memory accesses<\/p>\n\r<p class=\"p_Normal\">* Calls EBox \/ FBox \/ MBox \/ CBox<\/p>\n\r<p class=\"p_Normal\">* Detects exceptions<\/p>\n\r<p class=\"p_Normal\">* Sets stall or serialization flags<\/p>\n\r<p class=\"p_Normal\">* Produces result payload<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Multi-cycle operations **block EX** until complete.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 13.5.5 Memory Stage<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Despite the name:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* No memory access occurs here<\/p>\n\r<p class=\"p_Normal\">* Memory was already accessed in EX<\/p>\n\r<p class=\"p_Normal\">* MEM stage exists for structural completeness<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">MEM may queue faults or propagate stalls.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 13.5.6 Writeback Stage (Commit Point)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">WB is the **only architectural commit point**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Actions:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Write registers<\/p>\n\r<p class=\"p_Normal\">* Commit stores<\/p>\n\r<p class=\"p_Normal\">* Update PC<\/p>\n\r<p class=\"p_Normal\">* Retire instruction<\/p>\n\r<p class=\"p_Normal\">* Clear slot validity<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If an instruction reaches WB, it is guaranteed to be precise.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 13.6 Stall Mechanics<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 13.6.1 Stall Sources<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">A PipelineSlot may stall due to:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Operand unavailability<\/p>\n\r<p class=\"p_Normal\">* Multi-cycle FP execution<\/p>\n\r<p class=\"p_Normal\">* Memory barrier<\/p>\n\r<p class=\"p_Normal\">* Exception barrier<\/p>\n\r<p class=\"p_Normal\">* Pending fault delivery<\/p>\n\r<p class=\"p_Normal\">* Device backpressure<\/p>\n\r<p class=\"p_Normal\">* Write buffer saturation<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 13.6.2 Stall Propagation<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Stalls propagate **forward only**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If stage N stalls:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Stage N-1 cannot advance<\/p>\n\r<p class=\"p_Normal\">* Earlier stages remain frozen<\/p>\n\r<p class=\"p_Normal\">* Later stages continue draining<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This guarantees forward progress.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 13.7 Serialization and Barriers<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Barrier instructions do **not** execute work — they enforce ordering.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 13.7.1 Barrier Types<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">| Barrier &nbsp;| Effect &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| -------- | ----------------------- |<\/p>\n\r<p class=\"p_Normal\">| EXCB &nbsp; &nbsp; | Exception serialization |<\/p>\n\r<p class=\"p_Normal\">| TRAPB &nbsp; &nbsp;| Trap serialization &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| MB &nbsp; &nbsp; &nbsp; | Full memory ordering &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| WMB &nbsp; &nbsp; &nbsp;| Store ordering only &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| CALL_PAL | Privileged boundary &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 13.7.2 Barrier Implementation<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">In EX stage:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Grain sets `slot.stalled = true`<\/p>\n\r<p class=\"p_Normal\">* Sets `slot.serializationType`<\/p>\n\r<p class=\"p_Normal\">* Prevents fetch and issue<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Release occurs only when AlphaCPU confirms:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Pipeline drained<\/p>\n\r<p class=\"p_Normal\">* Buffers flushed<\/p>\n\r<p class=\"p_Normal\">* Faults delivered<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 13.8 Flush Semantics<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 13.8.1 Flush Causes<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Pipeline flush occurs when:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Branch misprediction<\/p>\n\r<p class=\"p_Normal\">* Exception delivery<\/p>\n\r<p class=\"p_Normal\">* Interrupt delivery<\/p>\n\r<p class=\"p_Normal\">* CALL_PAL<\/p>\n\r<p class=\"p_Normal\">* HW_REI<\/p>\n\r<p class=\"p_Normal\">* Fatal fault<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 13.8.2 Flush Behavior<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">On flush:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* All speculative slots invalidated<\/p>\n\r<p class=\"p_Normal\">* WB state preserved<\/p>\n\r<p class=\"p_Normal\">* PC reset to correct target<\/p>\n\r<p class=\"p_Normal\">* Fetch restarts cleanly<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Flushes are **precise and deterministic**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 13.9 Branch Handling<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Branches are resolved in EX stage.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 13.9.1 Prediction<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* IBox predicts target during fetch<\/p>\n\r<p class=\"p_Normal\">* Branch target stored in slot<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 13.9.2 Resolution<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">In EX:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Actual condition evaluated<\/p>\n\r<p class=\"p_Normal\">* Mismatch triggers flush<\/p>\n\r<p class=\"p_Normal\">* Correct PC supplied to WB<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">PC is updated **only in WB**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 13.10 LL\/SC Interaction<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The pipeline enforces LL\/SC semantics by:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Allowing speculation between LDL_L and STL_C<\/p>\n\r<p class=\"p_Normal\">* Clearing reservations on:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Exceptions<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Interrupts<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Barriers<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* PAL entry<\/p>\n\r<p class=\"p_Normal\">* Ensuring STL_C retires atomically<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">No reservation survives a pipeline flush.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 13.11 Exception Precision<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Exceptions are detected early but delivered late.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Rules:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Exception detected in EX<\/p>\n\r<p class=\"p_Normal\">* Fault queued<\/p>\n\r<p class=\"p_Normal\">* Instruction allowed to reach safe point<\/p>\n\r<p class=\"p_Normal\">* Pipeline flushed<\/p>\n\r<p class=\"p_Normal\">* PAL entered<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This guarantees **precise exceptions**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 13.12 Determinism Guarantees<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The pipeline guarantees:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* In-order retirement<\/p>\n\r<p class=\"p_Normal\">* One architectural commit per cycle<\/p>\n\r<p class=\"p_Normal\">* No speculative side effects<\/p>\n\r<p class=\"p_Normal\">* No privilege leakage<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">All behavior is replayable and debuggable.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 13.13 Summary<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The AlphaPipeline is:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Simple in structure<\/p>\n\r<p class=\"p_Normal\">* Strict in correctness<\/p>\n\r<p class=\"p_Normal\">* Aggressively deterministic<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Key takeaways:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1. **EX does everything**<\/p>\n\r<p class=\"p_Normal\">2. **WB is the only commit**<\/p>\n\r<p class=\"p_Normal\">3. **MEM is a misnomer**<\/p>\n\r<p class=\"p_Normal\">4. **Barriers stall, not execute**<\/p>\n\r<p class=\"p_Normal\">5. **Flushes are precise**<\/p>\n\r<p class=\"p_Normal\">6. **Speculation never leaks**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r"
})
