hmLoadTopic({
hmKeywords:"",
hmTitle:"TODO-PalVectoring",
hmDescription:"SRM_BOOTSTRAP_READINESS_AUDIT.txt ASCII \/ UTF-8 (no BOM)  ================================================================================ Question: What is needed yet to begi",
hmPrevLink:"",
hmNextLink:"",
hmParentLink:"appendix---trait-examples.html",
hmBreadCrumbs:"",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Appendix > Appendix I – Glossary and Acronyms",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">TODO-PalVectoring<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">SRM_BOOTSTRAP_READINESS_AUDIT.txt<\/p>\n\r<p class=\"p_Normal\">ASCII \/ UTF-8 (no BOM)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">Question:<\/p>\n\r<p class=\"p_Normal\">What is needed yet to begin planning bootstrap to SRM?<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Short answer:<\/p>\n\r<p class=\"p_Normal\">You are *past* the PAL\/CPU correctness gate. You are now at the point where<\/p>\n\r<p class=\"p_Normal\">bootstrap planning can begin, but three concrete layers must be completed<\/p>\n\r<p class=\"p_Normal\">or explicitly stubbed before SRM can execute meaningfully.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is not speculative work anymore; it is dependency-driven.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">BOOTSTRAP DEFINITION (clarity first)<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">For SRM, “bootstrap” means:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1) CPU resets into PAL RESET vector<\/p>\n\r<p class=\"p_Normal\">2) PAL establishes a minimal execution environment<\/p>\n\r<p class=\"p_Normal\">3) PAL transfers control to SRM firmware image<\/p>\n\r<p class=\"p_Normal\">4) SRM initializes console devices, memory map, and I\/O<\/p>\n\r<p class=\"p_Normal\">5) SRM reaches a visible prompt (&gt;&gt;&gt;)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You do NOT need:<\/p>\n\r<p class=\"p_Normal\">- OpenVMS<\/p>\n\r<p class=\"p_Normal\">- Filesystems<\/p>\n\r<p class=\"p_Normal\">- Disks<\/p>\n\r<p class=\"p_Normal\">- Networking<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You DO need:<\/p>\n\r<p class=\"p_Normal\">- Correct PAL behavior<\/p>\n\r<p class=\"p_Normal\">- Deterministic memory mapping<\/p>\n\r<p class=\"p_Normal\">- Minimal console I\/O<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">LAYER 1 — PAL + CPU (STATUS: essentially ready)<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You already have or are finishing:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">✔ PAL entry\/exit centralized (PalService)<\/p>\n\r<p class=\"p_Normal\">✔ PAL IRQ suppression<\/p>\n\r<p class=\"p_Normal\">✔ Correct IPL SSOT via IRQController<\/p>\n\r<p class=\"p_Normal\">✔ HW_REI restore via snapshot<\/p>\n\r<p class=\"p_Normal\">✔ PAL vector table infrastructure<\/p>\n\r<p class=\"p_Normal\">✔ PC[0] semantics controlled<\/p>\n\r<p class=\"p_Normal\">✔ RESET \/ MCHK \/ INTERRUPT vectors defined<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Remaining *blocking* PAL items (small but mandatory):<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">TODO 1.1) RESET vector must be fully wired<\/p>\n\r<p class=\"p_Normal\">- RESET must:<\/p>\n\r<p class=\"p_Normal\"> &nbsp;- Clear PAL mode state<\/p>\n\r<p class=\"p_Normal\"> &nbsp;- Initialize HWPCB for CPU 0<\/p>\n\r<p class=\"p_Normal\"> &nbsp;- Set PAL_BASE<\/p>\n\r<p class=\"p_Normal\"> &nbsp;- Jump to PAL RESET handler<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SRM always enters via RESET.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">TODO 1.2) PAL must provide minimal IPR read\/write<\/p>\n\r<p class=\"p_Normal\">SRM will immediately use:<\/p>\n\r<p class=\"p_Normal\">- MFPR \/ MTPR for:<\/p>\n\r<p class=\"p_Normal\"> &nbsp;- IPL<\/p>\n\r<p class=\"p_Normal\"> &nbsp;- PAL_BASE<\/p>\n\r<p class=\"p_Normal\"> &nbsp;- WHAMI<\/p>\n\r<p class=\"p_Normal\"> &nbsp;- ICCSR<\/p>\n\r<p class=\"p_Normal\"> &nbsp;- TB control registers (even if stubbed)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You do not need full semantics yet.<\/p>\n\r<p class=\"p_Normal\">You *must not fault* on access.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">TODO 1.3) ITB mapping for PAL + SRM image<\/p>\n\r<p class=\"p_Normal\">- PALcode and SRM must execute without I-stream faults.<\/p>\n\r<p class=\"p_Normal\">- Simplest acceptable solution:<\/p>\n\r<p class=\"p_Normal\"> &nbsp;- Identity-map a low physical region permanently<\/p>\n\r<p class=\"p_Normal\"> &nbsp;- Disable ITB faults during PAL\/SRM bootstrap<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is explicitly allowed by ASA.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">LAYER 2 — Memory Model (STATUS: partially ready, must finish)<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SRM assumes a very specific early-memory environment.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Mandatory:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">TODO 2.1) Physical memory must be contiguous and readable<\/p>\n\r<p class=\"p_Normal\">- SRM probes memory early.<\/p>\n\r<p class=\"p_Normal\">- You can lie (fixed-size RAM), but reads must succeed.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">TODO 2.2) VA -&gt; PA translation model must be stable<\/p>\n\r<p class=\"p_Normal\">Acceptable bootstrap models:<\/p>\n\r<p class=\"p_Normal\">- Flat identity map (VA == PA)<\/p>\n\r<p class=\"p_Normal\">- Or: MMU disabled until SRM enables it<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Do NOT attempt partial page table correctness yet.<\/p>\n\r<p class=\"p_Normal\">SRM expects to manage this itself.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">TODO 2.3) No speculative memory faults<\/p>\n\r<p class=\"p_Normal\">- All instruction fetches and data reads during SRM must succeed<\/p>\n\r<p class=\"p_Normal\">- Return zero-filled memory if unimplemented<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">LAYER 3 — Console I\/O (STATUS: NOT READY, REQUIRED)<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is the largest missing functional piece.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SRM requires:<\/p>\n\r<p class=\"p_Normal\">- One writable output device<\/p>\n\r<p class=\"p_Normal\">- One readable input device (even blocking\/polling)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Minimum viable console:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">TODO 3.1) Emulate *one* SRM console device<\/p>\n\r<p class=\"p_Normal\">Acceptable targets:<\/p>\n\r<p class=\"p_Normal\">- Serial TTA0<\/p>\n\r<p class=\"p_Normal\">- Graphics not required<\/p>\n\r<p class=\"p_Normal\">- Keyboard optional (polling OK)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Implementation:<\/p>\n\r<p class=\"p_Normal\">- Memory-mapped device or port-based<\/p>\n\r<p class=\"p_Normal\">- SRM will probe known addresses<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">TODO 3.2) Implement character putc\/getc semantics<\/p>\n\r<p class=\"p_Normal\">SRM prints extremely early:<\/p>\n\r<p class=\"p_Normal\">- Banner<\/p>\n\r<p class=\"p_Normal\">- CPU type<\/p>\n\r<p class=\"p_Normal\">- Memory size<\/p>\n\r<p class=\"p_Normal\">- “&gt;&gt;&gt;”<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If putc does not work, you will think SRM is dead when it is not.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">LAYER 4 — Platform Model (STATUS: can be stubbed)<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SRM expects some platform identity.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">TODO 4.1) WHAMI and CPU type<\/p>\n\r<p class=\"p_Normal\">- Return a known Alpha system (ES40 is fine)<\/p>\n\r<p class=\"p_Normal\">- Hardcode if necessary<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">TODO 4.2) Minimal PCI \/ I\/O probing responses<\/p>\n\r<p class=\"p_Normal\">- SRM probes buses<\/p>\n\r<p class=\"p_Normal\">- You may:<\/p>\n\r<p class=\"p_Normal\"> &nbsp;- Return “no device”<\/p>\n\r<p class=\"p_Normal\"> &nbsp;- Or stub a minimal PCI root<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SRM tolerates missing devices surprisingly well.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">LAYER 5 — Firmware Image Handling (STATUS: planning phase)<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You must decide how SRM is loaded and invoked.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">TODO 5.1) Decide SRM image format<\/p>\n\r<p class=\"p_Normal\">Typical options:<\/p>\n\r<p class=\"p_Normal\">- Raw .SYS image loaded at fixed PA<\/p>\n\r<p class=\"p_Normal\">- Extracted SRM ROM blob<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">TODO 5.2) Decide PAL -&gt; SRM handoff mechanism<\/p>\n\r<p class=\"p_Normal\">Common model:<\/p>\n\r<p class=\"p_Normal\">- PAL RESET vector jumps to SRM entry point<\/p>\n\r<p class=\"p_Normal\">- PC set to SRM start address<\/p>\n\r<p class=\"p_Normal\">- PAL mode exited or partially retained (implementation-specific)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">TODO 5.3) Instrument first execution<\/p>\n\r<p class=\"p_Normal\">You *must* have:<\/p>\n\r<p class=\"p_Normal\">- Instruction trace<\/p>\n\r<p class=\"p_Normal\">- Console output trace<\/p>\n\r<p class=\"p_Normal\">- Early breakpoint\/log when SRM entry is reached<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">WHAT YOU DO NOT NEED YET (important)<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You do NOT need:<\/p>\n\r<p class=\"p_Normal\">- Disk controllers<\/p>\n\r<p class=\"p_Normal\">- Filesystems<\/p>\n\r<p class=\"p_Normal\">- Networking<\/p>\n\r<p class=\"p_Normal\">- SCSI<\/p>\n\r<p class=\"p_Normal\">- Full MMU correctness<\/p>\n\r<p class=\"p_Normal\">- Full interrupt routing<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SRM will happily reach &gt;&gt;&gt; without them.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">ORDERED NEXT STEPS (ACTIONABLE)<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">STEP 1) Finalize PAL RESET path<\/p>\n\r<p class=\"p_Normal\">- Make RESET vector deterministic<\/p>\n\r<p class=\"p_Normal\">- Jump to SRM entry reliably<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">STEP 2) Lock down memory model<\/p>\n\r<p class=\"p_Normal\">- Identity map<\/p>\n\r<p class=\"p_Normal\">- No I-stream faults<\/p>\n\r<p class=\"p_Normal\">- Zero-fill on read<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">STEP 3) Implement minimal console output<\/p>\n\r<p class=\"p_Normal\">- Even printf-to-log is acceptable initially<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">STEP 4) Load SRM image and jump<\/p>\n\r<p class=\"p_Normal\">- Instrument heavily<\/p>\n\r<p class=\"p_Normal\">- Expect early failures<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">STEP 5) Iterate only where SRM touches next<\/p>\n\r<p class=\"p_Normal\">- Do not pre-implement features SRM does not yet reach<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">REALITY CHECK<\/p>\n\r<p class=\"p_Normal\">================================================================================<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You are no longer blocked by:<\/p>\n\r<p class=\"p_Normal\">- PAL architecture<\/p>\n\r<p class=\"p_Normal\">- CPU correctness<\/p>\n\r<p class=\"p_Normal\">- IRQ\/REI semantics<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You are blocked by:<\/p>\n\r<p class=\"p_Normal\">- Console I\/O<\/p>\n\r<p class=\"p_Normal\">- Early memory assumptions<\/p>\n\r<p class=\"p_Normal\">- RESET-to-SRM handoff mechanics<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">That is exactly where a real Alpha platform spends most of its firmware effort.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If you want next:<\/p>\n\r<p class=\"p_Normal\">- I can draft a minimal “SRM bootstrap PAL RESET handler”<\/p>\n\r<p class=\"p_Normal\">- Or outline a fake ES40 memory\/console map SRM will accept<\/p>\n\r<p class=\"p_Normal\">- Or help you identify exactly which IPRs SRM touches first (from trace history)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Just tell me which you want to tackle first.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r"
})
