hmLoadTopic({
hmKeywords:"",
hmTitle:"10.5 MMIOManager - MMIO Address Space",
hmDescription:"10.5.1 MMIO vs RAM Routing  MMIO regions are distinguished from RAM by address range, not instruction type. When GuestMemory::findRoute(pa) resolves to RouteTarget::MMIOManager,",
hmPrevLink:"10_3_2-device-attachment.html",
hmNextLink:"10_5-mmio-access-semantics.html",
hmParentLink:"chapter-10---devices-and-mmio.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-10---devices-and-mmio.html\">Chapter 10 – Devices and Memory-Mapped I\/O (MMIO)<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 10 – Devices and Memory-Mapped I\/O (MMIO) > 10.5 MMIOManager - MMIO Address Space",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">10.5 MMIOManager - MMIO Address Space<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">10.5.1 MMIO vs RAM Routing<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">MMIO regions are distinguished from RAM by address range, not instruction type. When GuestMemory::findRoute(pa) resolves to RouteTarget::MMIOManager, the access is forwarded to the MMIOManager. When it resolves to RouteTarget::SafeMemory, the access goes to RAM. This distinction occurs after VA→PA translation in MBox.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The default MMIO PA range is 0x10_0000_0000–0x20_0000_0000 (64 GB), as defined by the GuestMemory PA routing table.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">10.5.2 MMIOManager<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">MMIOManager (mmio_Manager.h, 114 lines) is the central MMIO dispatch engine. It maintains a table of registered regions and routes reads\/writes to the appropriate device handler.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Handler registration uses function pointers for maximum performance:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">typedef&nbsp;quint64&nbsp;(*ReadFn)(void*&nbsp;ctx,&nbsp;quint64&nbsp;offset,&nbsp;quint8&nbsp;width)&nbsp;noexcept;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">typedef&nbsp;void&nbsp;(*WriteFn)(void*&nbsp;ctx,&nbsp;quint64&nbsp;offset,&nbsp;quint64&nbsp;value,&nbsp;quint8&nbsp;width)&nbsp;noexcept;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">struct&nbsp;Handlers&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;void*&nbsp;ctx;&nbsp;\/\/&nbsp;Device&nbsp;context&nbsp;pointer<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;ReadFn&nbsp;read;&nbsp;\/\/&nbsp;Read&nbsp;handler<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;WriteFn&nbsp;write;&nbsp;\/\/&nbsp;Write&nbsp;handler<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">};<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">10.5.3 Region Registration<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Each MMIO region is described by RegionDescriptor:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">struct&nbsp;RegionDescriptor&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;quint64&nbsp;basePA;&nbsp;\/\/&nbsp;Start&nbsp;physical&nbsp;address<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;quint64&nbsp;sizeBytes;&nbsp;\/\/&nbsp;Region&nbsp;size<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;quint32&nbsp;flags;&nbsp;\/\/&nbsp;Access&nbsp;policy&nbsp;(see&nbsp;RegionFlags)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;quint32&nbsp;deviceUid;&nbsp;\/\/&nbsp;Owning&nbsp;device&nbsp;UID<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;quint32&nbsp;hoseId;&nbsp;\/\/&nbsp;PCI&nbsp;hose&nbsp;(interrupt&nbsp;domain)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">};<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">RegionFlags control per-region access policy: WIDTH_8\/16\/32\/64 (allowed access widths), REQUIRE_NATURAL_ALIGNMENT or ALLOW_UNALIGNED, and HAS_SIDE_EFFECTS (indicates the region has side effects on access).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">API: registerRegion(desc, handlers) adds a region; finalize() locks the region table for runtime; handleRead(pa, width, &amp;value) and handleWrite(pa, width, value) dispatch to device handlers, returning MMIOStatus.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: mmioLib\/mmio_Manager.h; <a href=\"chapter-5_5-guestmemory---shar.html\" class=\"topiclink\">5.5 GuestMemory - Shared Physical Memory (PA routing)<\/a>.<\/span><\/p>\n\r"
})
