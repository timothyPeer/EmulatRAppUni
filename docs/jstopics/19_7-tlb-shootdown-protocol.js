hmLoadTopic({
hmKeywords:"",
hmTitle:"19.7 TLB Shootdown Protocol",
hmDescription:"TLB shootdown is the primary use case for IPIs. When a CPU modifies page tables, other CPUs may have stale TLB entries. Without invalidation, memory safety would be violated —...",
hmPrevLink:"19_6-memory-barrier-coordinati.html",
hmNextLink:"19_8-architectural-invariants-.html",
hmParentLink:"chapter-19---debugging_-tracin.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-19---debugging_-tracin.html\">Chapter 19 – Interrupt Architecture &amp; IPI<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 19 – Interrupt Architecture & IPI > 19.7 TLB Shootdown Protocol",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">19.7 TLB Shootdown Protocol<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">TLB shootdown is the primary use case for IPIs. When a CPU modifies page tables, other CPUs may have stale TLB entries. Without invalidation, memory safety would be violated — stale entries could allow access to freed pages, bypass permission changes, or map incorrect physical addresses.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Shootdown&nbsp;Sequence:<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;1.&nbsp;CPU&nbsp;A&nbsp;modifies&nbsp;page&nbsp;table&nbsp;entries&nbsp;in&nbsp;GuestMemory<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;2.&nbsp;CPU&nbsp;A&nbsp;performs&nbsp;local&nbsp;TLB&nbsp;invalidation&nbsp;(TBIS\/TBIA&nbsp;on&nbsp;own&nbsp;TLB)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;3.&nbsp;CPU&nbsp;A&nbsp;sends&nbsp;TLB&nbsp;invalidation&nbsp;IPIs&nbsp;to&nbsp;all&nbsp;other&nbsp;CPUs<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;IPICommand&nbsp;selects&nbsp;scope:<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;TLB_INVALIDATE_VA_ITB&nbsp;→&nbsp;single&nbsp;VA,&nbsp;ITB&nbsp;only<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;TLB_INVALIDATE_VA_DTB&nbsp;→&nbsp;single&nbsp;VA,&nbsp;DTB&nbsp;only<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;TLB_INVALIDATE_VA_BOTH&nbsp;→&nbsp;single&nbsp;VA,&nbsp;ITB&nbsp;+&nbsp;DTB<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;TLB_INVALIDATE_ASN&nbsp;→&nbsp;all&nbsp;entries&nbsp;for&nbsp;ASN<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;TLB_INVALIDATE_ALL&nbsp;→&nbsp;flush&nbsp;all&nbsp;TLB&nbsp;entries<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;VA-specific:&nbsp;VA&nbsp;encoded&nbsp;via&nbsp;encodeIPIWithVA()<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;ASN-specific:&nbsp;ASN&nbsp;encoded&nbsp;via&nbsp;encodeIPIWithASN()<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;4.&nbsp;Target&nbsp;CPUs&nbsp;receive&nbsp;IPI&nbsp;via&nbsp;checkInterrupts()<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;Enter&nbsp;PAL&nbsp;mode<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;Call&nbsp;handleTLBShootdownIPI(cpuId,&nbsp;ipiData)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;Decode&nbsp;IPICommand,&nbsp;perform&nbsp;TLB&nbsp;invalidation&nbsp;on&nbsp;local&nbsp;ITB\/DTB<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;5.&nbsp;Target&nbsp;CPUs&nbsp;acknowledge&nbsp;completion<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;6.&nbsp;CPU&nbsp;A&nbsp;resumes&nbsp;after&nbsp;all&nbsp;targets&nbsp;acknowledge<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Shootdowns are serialized operations — the initiating CPU stalls until all targets have acknowledged. No global locks are required; the protocol uses per-CPU atomic IPI slots and acknowledgment counts.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Invariant:<\/span> Shootdown is always explicit and synchronized. No CPU may execute with a stale TLB entry after a shootdown completes. Reservation clearing is a mandatory side effect of TLB invalidation (see Chapter 17).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-9_8-inter-processor-in.html\" class=\"topiclink\">9.8 TLB Shootdown<\/a>; <a href=\"17_8-tlb-invalidation-and-shoo.html\" class=\"topiclink\">17.8 TLB Invalidation and Shootdown<\/a>; cpuCoreLib\/AlphaCPU.h – handleTLBShootdownIPI().<\/span><\/p>\n\r"
})
