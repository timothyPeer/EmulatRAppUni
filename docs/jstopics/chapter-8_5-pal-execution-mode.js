hmLoadTopic({
hmKeywords:"",
hmTitle:"8.5 PAL Vector Dispatch",
hmDescription:"PAL entry vectors are computed differently for exceptions\/interrupts (direct vectors) and CALL_PAL instructions (calculated offsets).",
hmPrevLink:"chapter-8_4-call_pal---enterin.html",
hmNextLink:"chapter-8_6-pal-and-exceptions.html",
hmParentLink:"chapter-8---pal-and-privleged-.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-8---pal-and-privleged-.html\">Chapter 8 - PAL and Privileged Boundary<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 8 - PAL and Privileged Boundary > 8.5 PAL Vector Dispatch",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">8.5 PAL Vector Dispatch<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">PAL entry vectors are computed differently for exceptions\/interrupts (direct vectors) and CALL_PAL instructions (calculated offsets).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">8.5.1 EV6 Hardware Exception Vectors<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Exception and interrupt vectors are fixed offsets from PAL_BASE, defined by PalVectorId_EV6 (Alpha 21264 Hardware Reference Manual, Table 5-8):<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">RESET&nbsp;=&nbsp;0x0000&nbsp;\/\/&nbsp;Reset\/wakeup<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">MCHK&nbsp;=&nbsp;0x0080&nbsp;\/\/&nbsp;Machine&nbsp;check<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">ARITH&nbsp;=&nbsp;0x0100&nbsp;\/\/&nbsp;Arithmetic&nbsp;exception<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">INTERRUPT&nbsp;=&nbsp;0x0180&nbsp;\/\/&nbsp;Interrupts&nbsp;(HW\/SW\/AST)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">DTB_MISS_SINGLE&nbsp;=&nbsp;0x0200&nbsp;\/\/&nbsp;Single-level&nbsp;DTB&nbsp;miss<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">DTB_MISS_DOUBLE&nbsp;=&nbsp;0x0280&nbsp;\/\/&nbsp;Double&nbsp;(3-level&nbsp;walk)&nbsp;DTB&nbsp;miss<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">ITB_MISS&nbsp;=&nbsp;0x0300&nbsp;\/\/&nbsp;Instruction&nbsp;TB&nbsp;miss<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">ITB_ACV&nbsp;=&nbsp;0x0380&nbsp;\/\/&nbsp;I-stream&nbsp;access&nbsp;violation<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">DTB_MISS_NATIVE&nbsp;=&nbsp;0x0400&nbsp;\/\/&nbsp;DTB&nbsp;miss&nbsp;(native&nbsp;mode)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">UNALIGN&nbsp;=&nbsp;0x0480&nbsp;\/\/&nbsp;Unaligned&nbsp;access<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">OPCDEC&nbsp;=&nbsp;0x0500&nbsp;\/\/&nbsp;Illegal\/privileged&nbsp;opcode<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">FEN&nbsp;=&nbsp;0x0580&nbsp;\/\/&nbsp;Floating-point&nbsp;disabled<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">For exceptions and interrupts, the entry PC is PAL_BASE + vector offset, passed directly to enterPal() as the vectorOrSelector parameter.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">8.5.2 CALL_PAL Vector Calculation<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">CALL_PAL vectors are calculated, not enumerated. The function selector from the instruction\'s low bits determines the entry point:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Privileged CALL_PAL (functions 0x00–0x3F): entry = PAL_BASE + 0x2000 + ([5:0] &lt;&lt; 6)<\/p>\n\r<p class=\"p_Normal\">Unprivileged CALL_PAL (functions 0x80–0xBF): entry = PAL_BASE + 0x3000 + ([5:0] &lt;&lt; 6)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This produces 128 possible entry points spaced 64 bytes apart (enough for a short PAL dispatch stub per function). The computeCallPalEntry() method performs this calculation.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Examples: CALL_PAL HALT (function 0x00) → PAL_BASE + 0x2000. CALL_PAL CSERVE (function 0x09) → PAL_BASE + 0x2240. CALL_PAL CALLSYS (function 0x83) → PAL_BASE + 0x30C0.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: palLib_EV6\/PalVectorId_refined.h; Alpha 21264 Hardware Reference Manual, Table 5-8.<\/span><\/p>\n\r"
})
