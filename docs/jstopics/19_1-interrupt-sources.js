hmLoadTopic({
hmKeywords:"",
hmTitle:"19.1 Interrupt Sources",
hmDescription:"19.1.1 Device Interrupts  External devices (MMIO controllers, timers, disks, NICs) assert interrupts when DMA completes, an error occurs, or a status threshold is reached....",
hmPrevLink:"chapter-19---debugging_-tracin.html",
hmNextLink:"19_2-irqpendingstate-implement.html",
hmParentLink:"chapter-19---debugging_-tracin.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-19---debugging_-tracin.html\">Chapter 19 – Interrupt Architecture &amp; IPI<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 19 – Interrupt Architecture & IPI > 19.1 Interrupt Sources",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">19.1 Interrupt Sources<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">19.1.1 Device Interrupts<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">External devices (MMIO controllers, timers, disks, NICs) assert interrupts when DMA completes, an error occurs, or a status threshold is reached. Devices assert an IRQ line via <span class=\"f_CodeExample\">IRQPendingState<\/span> but never directly invoke CPU code or stall the pipeline. Device interrupt assertion is cross-thread: a device I\/O thread (QThread) may raise an interrupt at any time while the CPU thread is executing instructions. This drives the atomic design of <span class=\"f_CodeExample\">IRQPendingState<\/span>.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">19.1.2 Software Interrupts (SIRR \/ SISR)<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Software interrupts are raised by CPU instructions or PAL code via the SIRR (Software Interrupt Request Register). Writing <span class=\"f_CodeExample\">MTPR_SIRR<\/span> sets a bit in the software interrupt request bitmap (bits [15:1] for IPL 1–15). The SISR (Software Interrupt Summary Register) is the read-only view of pending software interrupt state. Software interrupts use the same interrupt delivery path as hardware interrupts and obey the same IPL masking rules.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">MTPR_SIRR<\/span> updates IPR state only — it does not directly cause interrupt delivery. Pending software interrupts are evaluated at instruction retirement boundaries by the CPU run loop, and delivery is performed through PalService, identically to hardware interrupts.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">19.1.3 Asynchronous System Traps (ASTs)<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">ASTs are deferred interrupts that deliver signals or notifications to specific processor modes. The AST subsystem uses four IPR registers maintained in the HWPCB (Hardware Process Control Block):<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Register<\/span><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Purpose<\/span><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">ASTEN<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">AST Enable — bitmask of which AST levels (0–3, one per mode) are enabled<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">ASTER<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">AST Enable Request — enable bits maintained by PAL\/OS<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">ASTRR<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">AST Request — write by OS or PAL requesting an AST at a given level<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">ASTSR<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">AST Summary — hardware-computed: <span class=\"f_CodeExample\">ASTSR = ASTRR &amp; ASTEN<\/span>, reflects pending-and-enabled ASTs<\/p>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">AST delivery is gated by IPL (AST interrupts fire at IPL 2) and current mode. ASTs do not cross CPUs — the OS arranges delivery to a specific CPU. All four AST registers are part of process context and must be saved\/restored on context switches. The <span class=\"f_CodeExample\">checkPendingAST()<\/span> method computes the effective ASTSR and determines if an AST is deliverable at the current IPL and mode.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">19.1.4 Inter-Processor Interrupts (IPIs)<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">IPIs are CPU-to-CPU notifications used for SMP coordination: TLB shootdowns, memory barrier synchronization, scheduler notifications, CPU halt\/wake, and context switch requests. IPIs are generated by one CPU (via <span class=\"f_CodeExample\">MTPR_IPIR<\/span> or <span class=\"f_CodeExample\">WRIPIR<\/span> PAL instructions), routed via <span class=\"f_CodeExample\">IPIManager<\/span>, and delivered to the target CPU as interrupts through the same delivery path as device interrupts.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-7_9-interrupt-handling.html\" class=\"topiclink\">7.10 Interrupt Handling<\/a>; <a href=\"16_8-irq-integration-architect.html\" class=\"topiclink\">16.8 IRQ Integration Architecture<\/a> (device interrupt flow).<\/span><\/p>\n\r"
})
