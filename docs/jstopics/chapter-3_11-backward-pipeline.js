hmLoadTopic({
hmKeywords:"",
hmTitle:"3.11 Backward Pipeline Advancement",
hmDescription:"The pipeline advances from WB backward to IF each cycle. Within the tick() method, stages execute in this order:",
hmPrevLink:"chapter-3_10-pipeline-semantic.html",
hmNextLink:"chapter-3_12-stalls-and-serial.html",
hmParentLink:"chapter-3---pipeline-architect.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-3---pipeline-architect.html\">Chapter 3 - Pipeline Architecture<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 3 - Pipeline Architecture > 3.11 Backward Pipeline Advancement",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">3.11 Backward Pipeline Advancement<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">The pipeline advances from WB backward to IF each cycle. Within the tick() method, stages execute in this order:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">stage_WB();&nbsp;\/\/&nbsp;Stage&nbsp;5&nbsp;—&nbsp;Retire,&nbsp;commit&nbsp;stores,&nbsp;dispatch&nbsp;faults&nbsp;(OLDEST)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">stage_MEM();&nbsp;\/\/&nbsp;Stage&nbsp;4&nbsp;—&nbsp;Deferred&nbsp;register&nbsp;writeback&nbsp;(forwarding&nbsp;path)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">stage_EX();&nbsp;\/\/&nbsp;Stage&nbsp;3&nbsp;—&nbsp;Read&nbsp;registers,&nbsp;execute&nbsp;instruction&nbsp;semantics<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">stage_IS();&nbsp;\/\/&nbsp;Stage&nbsp;2&nbsp;—&nbsp;Hazard&nbsp;check<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">stage_DE();&nbsp;\/\/&nbsp;Stage&nbsp;1&nbsp;—&nbsp;Decode&nbsp;\/&nbsp;Box&nbsp;routing<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">stage_IF();&nbsp;\/\/&nbsp;Stage&nbsp;0&nbsp;—&nbsp;Instruction&nbsp;fetch&nbsp;(YOUNGEST)<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This backward ordering provides three critical benefits:<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Prevents overwrite hazards — WB retires and frees a slot before younger stages attempt to fill it<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Enables result forwarding — MEM commits register writes before EX reads registers in the same cycle, so a value written by instruction N at MEM is immediately available to instruction N+2 at EX<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Supports precise exceptions — older instructions complete before younger ones, so flushing younger stages at any point produces a consistent architectural state<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">Ring Buffer Mechanics<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The pipeline uses a ring buffer of six physical PipelineSlot entries. The m_head index points to the oldest instruction (always in the WB logical position). Stage mapping uses modular arithmetic:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;Logical-to-physical&nbsp;mapping:<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;stage(5)&nbsp;[WB&nbsp;]&nbsp;=&nbsp;m_ringSlots[m_head]&nbsp;—&nbsp;Oldest<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;stage(4)&nbsp;[MEM]&nbsp;=&nbsp;m_ringSlots[(m_head&nbsp;-&nbsp;1&nbsp;+&nbsp;6)&nbsp;%&nbsp;6]<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;stage(3)&nbsp;[EX&nbsp;]&nbsp;=&nbsp;m_ringSlots[(m_head&nbsp;-&nbsp;2&nbsp;+&nbsp;6)&nbsp;%&nbsp;6]<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;stage(2)&nbsp;[IS&nbsp;]&nbsp;=&nbsp;m_ringSlots[(m_head&nbsp;-&nbsp;3&nbsp;+&nbsp;6)&nbsp;%&nbsp;6]<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;stage(1)&nbsp;[DE&nbsp;]&nbsp;=&nbsp;m_ringSlots[(m_head&nbsp;-&nbsp;4&nbsp;+&nbsp;6)&nbsp;%&nbsp;6]<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;stage(0)&nbsp;[IF&nbsp;]&nbsp;=&nbsp;m_ringSlots[(m_head&nbsp;-&nbsp;5&nbsp;+&nbsp;6)&nbsp;%&nbsp;6]&nbsp;—&nbsp;Youngest<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">After all stages execute, advanceRing() increments m_head: m_head = (m_head + 1) % 6. This effectively retires the WB slot and makes a fresh slot available at the IF position.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-2_7-execution-and-comm.html\" class=\"topiclink\">2.7.2 Execution and Commit Semantics<\/a> (Writeback as Commit Point); cpuCoreLib\/AlphaPipeline.h.<\/span><\/p>\n\r"
})
