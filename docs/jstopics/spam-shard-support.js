hmLoadTopic({
hmKeywords:"",
hmTitle:"SPAM Shard Support",
hmDescription:"You‚Äôre very welcome üòä And nice, this is exactly the right point to carve in the layering and stop letting templates leak all over the place.",
hmPrevLink:"",
hmNextLink:"",
hmParentLink:"appendix---trait-examples.html",
hmBreadCrumbs:"",
hmTitlePath:"Introduction > Appendix > Appendix I ‚Äì Global Singletons",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">SPAM Shard Support<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">You‚Äôre very welcome üòä And nice, this is exactly the right point to carve in the layering and stop letting templates leak all over the place.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Let me do three things for you:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1. **Confirm the mental model** you just described (it‚Äôs right).<\/p>\n\r<p class=\"p_Normal\">2. **Propose a clean 3-layer design (silicon L0 \/ helper L1 \/ API L2)**.<\/p>\n\r<p class=\"p_Normal\">3. **Give you concrete code that *hides* the Trait\/Templates behind EV6-only types**, so the rest of the emulator doesn‚Äôt have to touch templates at all.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">I‚Äôll *preserve* your existing PTE \/ SPAM structure and banks\/SMP behavior; I‚Äôm just going to wrap it so EV6 is a concrete, non-templated ‚Äúchip‚Äù.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 1. Quick confirmation of your mental model<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&gt; ‚Äúthe VA and PFN are encoded into a PTE‚Ä¶ the PTE is data-agnostic and only cares about addresses \/ translations‚Äù<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Yes.<\/p>\n\r<p class=\"p_Normal\">And in your current code:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* `AlphaPTE` (in `AlphaPTE_Core.h`) is the **architectural PTE**.<\/p>\n\r<p class=\"p_Normal\">* `SPAMTag` + `SPAMEntry` (in `Alpha_spam_types.h`) are the **TLB cache objects**.<\/p>\n\r<p class=\"p_Normal\">* `SPAMBucket` and `SPAMShardManager` are the **implementation of the TLB cache** (banks, SMP, epochs, etc.).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">All the *heavy* templating is around `Traits`, `SPAMBucket&lt;Traits,...&gt;`, `SPAMShardManager&lt;Traits,...&gt;`, and you only ever want **EV6** right now.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">So instead of ripping all templates out, the sane path is:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&gt; **Instantiate them once for EV6 and hide that behind non-templated typedefs and wrapper functions.**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">That gives you:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* EV6-only ‚Äúsilicon‚Äù types.<\/p>\n\r<p class=\"p_Normal\">* No template parameters sprinkled all over the rest of the code.<\/p>\n\r<p class=\"p_Normal\">* No loss of functionality.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 2. Layering: L0 (Silicon), L1 (Helpers), L2 (API)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Here‚Äôs a clean way to structure it:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> **Layer 0 ‚Äì ‚ÄúSilicon‚Äù (EV6-only)**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is where you:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Define **EV6 PTE \/ TLB \/ SPAM traits**.<\/p>\n\r<p class=\"p_Normal\">* Instantiate the **SPAMBucket** and **SPAMShardManager** templates for EV6.<\/p>\n\r<p class=\"p_Normal\">* Centralize **page size configuration** (8K \/ 16K \/ 32K \/ 64K) as ‚Äúsilicon parameters‚Äù.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**No one above this layer touches templates.**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Files:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* `Ev6PteSilicon.h` (new)<\/p>\n\r<p class=\"p_Normal\">* Still uses:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `AlphaPTE_Core.h`<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `alpha_pte_core.h`<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `alpha_spam_bucket.h`<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `Alpha_spam_types.h`<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `alpha_pte_traits_ev6_dtb.h`<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `alpha_pte_traits_ev6_itb.h`<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `alpha_spam_manager.h` (but only as implementation)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> **Layer 1 ‚Äì ‚ÄúHelper \/ MMU Interface‚Äù**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This layer is what PAL and TBI hooks will call:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* `Ev6TLBInterface` \/ `Ev6MMUInterface` class or namespace.<\/p>\n\r<p class=\"p_Normal\">* Methods like:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `bool tlbLookupD(cpuId, va, asn, outPfn, outPermMask)`<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `void tlbInsertD(cpuId, va, asn, const AlphaPTE&amp;, bool global)`<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `void tbiVA(cpuId, va, Realm realm)`<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `void tbiAll(cpuId)`<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `void tbiASN(cpuId, asn)`<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This layer works purely with:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* `AlphaPTE`<\/p>\n\r<p class=\"p_Normal\">* `Ev6SPAMManager` (non-templated alias)<\/p>\n\r<p class=\"p_Normal\">* `PageSizeCode` and `PageSizeHelpers`<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">No Traits, no templates in signatures.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> **Layer 2 ‚Äì ‚ÄúPAL \/ API Layer‚Äù**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is the interface you wire to:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* PALcode emulation (`CALL_PAL TBIS\/TBIA\/TBIAP`)<\/p>\n\r<p class=\"p_Normal\">* MFPR \/ MTPR of ITB\/DTB registers:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `ITB_TAG`, `ITB_PTE`, `DTB_TAG`, `DTB_PTE`<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `ITB_PTE_WRITE`, `ITB_TAG_READ`, etc.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This layer calls Layer 1 helpers like:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* `Ev6TLBInterface::tbiVA(...)`<\/p>\n\r<p class=\"p_Normal\">* `Ev6TLBInterface::insertITB(...)`<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">And uses your EV6-specific register structs from:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* `ev6_DtbPteTempRegister.h`<\/p>\n\r<p class=\"p_Normal\">* `ev6_ItbPteRead_Register.h`<\/p>\n\r<p class=\"p_Normal\">* `ev6_ITBPteWrite_Register.h`<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 3. Concrete code: EV6 ‚Äúsilicon‚Äù layer (L0) with hidden templates<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> 3.1 New header: `Ev6PteSilicon.h`<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This file sits in your Alpha include tree and gives you **non-templated EV6 types**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```cpp<\/p>\n\r<p class=\"p_Normal\">#pragma once<\/p>\n\r<p class=\"p_Normal\">\/\/ Ev6PteSilicon.h<\/p>\n\r<p class=\"p_Normal\">\/\/<\/p>\n\r<p class=\"p_Normal\">\/\/ EV6-only &quot;silicon&quot; layer for PTE \/ TLB \/ SPAM.<\/p>\n\r<p class=\"p_Normal\">\/\/ Hides Traits and template parameters from the rest of the emulator.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">#include &lt;QtCore\/QtGlobal&gt;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">#include &quot;AlphaPTE_Core.h&quot; &nbsp; &nbsp; &nbsp; &nbsp;\/\/ AlphaPTE (architectural PTE)<\/p>\n\r<p class=\"p_Normal\">#include &quot;alpha_pte_core.h&quot; &nbsp; &nbsp; &nbsp; \/\/ PageSizeCode, PageSizeHelpers, Realm, PermMask, etc.<\/p>\n\r<p class=\"p_Normal\">#include &quot;Alpha_spam_types.h&quot; &nbsp; &nbsp; \/\/ SPAMTag&lt;T&gt;, SPAMEntry&lt;T&gt;<\/p>\n\r<p class=\"p_Normal\">#include &quot;alpha_spam_bucket.h&quot; &nbsp; &nbsp;\/\/ SPAMBucket&lt;Traits,...&gt;<\/p>\n\r<p class=\"p_Normal\">#include &quot;alpha_spam_manager.h&quot; &nbsp; \/\/ SPAMShardManager&lt;Traits,...&gt;<\/p>\n\r<p class=\"p_Normal\">#include &quot;alpha_pte_traits_ev6_dtb.h&quot;<\/p>\n\r<p class=\"p_Normal\">#include &quot;alpha_pte_traits_ev6_itb.h&quot;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">\/\/ Forward-declare your system-wide config if you have one.<\/p>\n\r<p class=\"p_Normal\">\/\/ For now, we define a small VM config struct here.<\/p>\n\r<p class=\"p_Normal\">struct Ev6VMConfig<\/p>\n\r<p class=\"p_Normal\">{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;PageSizeCode basePageSize; &nbsp; &nbsp;\/\/ e.g. PageSizeCode::PageSize_8K<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;bool enableSuperpage64K; &nbsp; &nbsp; &nbsp;\/\/ if you later want 64K support<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;bool enableSuperpage32K; &nbsp; &nbsp; &nbsp;\/\/ reserved for future<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;bool enableSuperpage16K; &nbsp; &nbsp; &nbsp;\/\/ reserved for future<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ Default EV6 config: 8KB base page, no extra superpage classes by default.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;static Ev6VMConfig defaultConfig() noexcept<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;Ev6VMConfig cfg{};<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;cfg.basePageSize &nbsp; &nbsp; &nbsp;= PageSizeCode::PageSize_8K;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;cfg.enableSuperpage64K = false;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;cfg.enableSuperpage32K = false;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;cfg.enableSuperpage16K = false;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;return cfg;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\">};<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">\/\/ Singleton-ish access point for the silicon config.<\/p>\n\r<p class=\"p_Normal\">\/\/ You can wire this to SystemConfigLoader later.<\/p>\n\r<p class=\"p_Normal\">class Ev6SiliconConfig<\/p>\n\r<p class=\"p_Normal\">{<\/p>\n\r<p class=\"p_Normal\">public:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;static void initialize(const Ev6VMConfig &amp;cfg) noexcept<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;s_config = cfg;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;static Ev6VMConfig config() noexcept<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;return s_config;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;static quint64 basePageShift() noexcept<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;return PageSizeHelpers::pageShift(s_config.basePageSize);<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;static quint64 basePageSizeBytes() noexcept<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;return PageSizeHelpers::pageSizeBytes(s_config.basePageSize);<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">private:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;static inline Ev6VMConfig s_config = Ev6VMConfig::defaultConfig();<\/p>\n\r<p class=\"p_Normal\">};<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">\/\/ ---------------------------------------------------------------------------<\/p>\n\r<p class=\"p_Normal\">\/\/ EV6 PTETraits ‚Äì single, concrete traits type for EV6.<\/p>\n\r<p class=\"p_Normal\">\/\/ This replaces the generic Traits template parameter.<\/p>\n\r<p class=\"p_Normal\">\/\/ ---------------------------------------------------------------------------<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">struct Ev6PTETraits<\/p>\n\r<p class=\"p_Normal\">{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;using PTE &nbsp; &nbsp; &nbsp;= AlphaPTE;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;using Tag &nbsp; &nbsp; &nbsp;= SPAMTag&lt;Ev6PTETraits&gt;;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;using Entry &nbsp; &nbsp;= SPAMEntry&lt;Ev6PTETraits&gt;;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;using Realm &nbsp; &nbsp;= ::Realm;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;using PermMask = ::PermMask;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ Page size class plumbing.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ For now: sizeClass 0 = 8K (or whatever Ev6SiliconConfig says)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sizeClass 1 = 64K (optional superpage)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;static constexpr quint8 SizeClass_8K &nbsp;= 0;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;static constexpr quint8 SizeClass_64K = 1;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;static PageSizeCode pageSizeForClass(quint8 sizeClass) noexcept<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;switch (sizeClass)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;case SizeClass_8K:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return Ev6SiliconConfig::config().basePageSize;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;case SizeClass_64K:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return PageSizeCode::PageSize_64K;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;default:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/ Fallback to base page<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return Ev6SiliconConfig::config().basePageSize;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;static quint64 pageShiftForClass(quint8 sizeClass) noexcept<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;return PageSizeHelpers::pageShift(pageSizeForClass(sizeClass));<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ Tag construction helper adapted from Alpha_spam_types.h semantics.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;static Tag makeTag(quint64 va, ::Realm realm, quint8 sizeClass) noexcept<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;Tag t{};<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;const PageSizeCode code = pageSizeForClass(sizeClass);<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;const quint64 shift &nbsp; &nbsp; = PageSizeHelpers::pageShift(code);<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;t.vpn &nbsp; &nbsp; &nbsp; = va &gt;&gt; shift;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;t.sizeClass = sizeClass;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;t.realm &nbsp; &nbsp; = (realm == Realm::D) ? 0 : 1;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;t.matchAllASNs = false;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;return t;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\">};<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">\/\/ ---------------------------------------------------------------------------<\/p>\n\r<p class=\"p_Normal\">\/\/ Concrete EV6 SPAM types ‚Äì these are NON-TEMPLATED from the outside.<\/p>\n\r<p class=\"p_Normal\">\/\/ ---------------------------------------------------------------------------<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">constexpr unsigned EV6_SPAM_ASSOC_WAYS &nbsp;= 4;<\/p>\n\r<p class=\"p_Normal\">constexpr unsigned EV6_SPAM_MAX_ASN &nbsp; &nbsp; = 256;<\/p>\n\r<p class=\"p_Normal\">constexpr unsigned EV6_SPAM_BUCKETS &nbsp; &nbsp; = 1024;<\/p>\n\r<p class=\"p_Normal\">constexpr bool &nbsp; &nbsp; EV6_SPAM_SHARD_BY_SIZE = true;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">\/\/ Bucket and entry types for EV6<\/p>\n\r<p class=\"p_Normal\">using Ev6SPAMBucket = SPAMBucket&lt;Ev6PTETraits, EV6_SPAM_ASSOC_WAYS, EV6_SPAM_MAX_ASN&gt;;<\/p>\n\r<p class=\"p_Normal\">using Ev6SPAMEntry &nbsp;= Ev6SPAMBucket::Entry;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">\/\/ Shard manager for EV6 (this is your &quot;silicon TLB&quot; implementation)<\/p>\n\r<p class=\"p_Normal\">using Ev6SPAMShardManager =<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;SPAMShardManager&lt;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;Ev6PTETraits,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;EV6_SPAM_ASSOC_WAYS,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;EV6_SPAM_MAX_ASN,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;EV6_SPAM_BUCKETS,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;EV6_SPAM_SHARD_BY_SIZE<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;&gt;;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">\/\/ ---------------------------------------------------------------------------<\/p>\n\r<p class=\"p_Normal\">\/\/ Silicon-level TLB container for the whole system.<\/p>\n\r<p class=\"p_Normal\">\/\/ This is what Layer-1 will hold onto and call.<\/p>\n\r<p class=\"p_Normal\">\/\/ ---------------------------------------------------------------------------<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">class Ev6SiliconTLB<\/p>\n\r<p class=\"p_Normal\">{<\/p>\n\r<p class=\"p_Normal\">public:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;explicit Ev6SiliconTLB(int cpuCount)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;: m_spam(cpuCount)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;\/\/ You can add silicon-level init logic here if needed.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;Ev6SPAMShardManager &amp;spam() noexcept { return m_spam; }<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;const Ev6SPAMShardManager &amp;spam() const noexcept { return m_spam; }<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">private:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;Ev6SPAMShardManager m_spam;<\/p>\n\r<p class=\"p_Normal\">};<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Key points:**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* All the *real* templates (`SPAMBucket`, `SPAMShardManager`, `SPAMTag`, `SPAMEntry`) still exist, but:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* They are instantiated exactly once for **Ev6PTETraits**.<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Everything above this header just sees `Ev6SPAMShardManager`, `Ev6SPAMEntry`, `Ev6SiliconTLB` as normal classes \/ types.<\/p>\n\r<p class=\"p_Normal\">* `Ev6SiliconConfig` is your **Layer-0 ‚Äúchip config‚Äù** ‚Äì base page size, superpage options, etc. You can feed this from `SystemConfigLoader` later.<\/p>\n\r<p class=\"p_Normal\">* The PTE structure (`AlphaPTE`) is **unchanged** and remains ASA-correct.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> 3.2 Layer-1 helper interface: `Ev6TLBInterface.h`<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is what TBI hooks and PAL emulation will call. It sits on top of `Ev6SiliconTLB`.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```cpp<\/p>\n\r<p class=\"p_Normal\">#pragma once<\/p>\n\r<p class=\"p_Normal\">\/\/ Ev6TLBInterface.h<\/p>\n\r<p class=\"p_Normal\">\/\/<\/p>\n\r<p class=\"p_Normal\">\/\/ Layer-1 helper functions for EV6 TLB \/ SPAM access.<\/p>\n\r<p class=\"p_Normal\">\/\/ No templates in the interface; works purely in terms of AlphaPTE,<\/p>\n\r<p class=\"p_Normal\">\/\/ PFNs, ASN, and simple enums.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">#include &quot;Ev6PteSilicon.h&quot; &nbsp; \/\/ Ev6SiliconTLB, Ev6SPAMShardManager, etc.<\/p>\n\r<p class=\"p_Normal\">#include &quot;alpha_pte_core.h&quot; &nbsp;\/\/ Realm, PermMask<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">class Ev6TLBInterface<\/p>\n\r<p class=\"p_Normal\">{<\/p>\n\r<p class=\"p_Normal\">public:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;explicit Ev6TLBInterface(int cpuCount)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;: m_siliconTLB(cpuCount)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;\/\/ Register CPUs if needed<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;m_siliconTLB.spam().registerCPUCount(cpuCount);<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ -------------------------------------------------------------------<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ DTB interface (Data TLB)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ -------------------------------------------------------------------<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;bool lookupDTB(quint16 cpuId,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; quint64 va,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; quint8 &nbsp;asn,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; quint32 &amp;outPfn,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PermMask &amp;outPermMask) const noexcept<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;return m_siliconTLB.spam().tlbLookup(<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cpuId,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Realm::D,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/*sizeClass*\/ 0, &nbsp;\/\/ base page size class for now<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;va,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;asn,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;outPfn,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;outPermMask<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;);<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;bool insertDTB(quint16 cpuId,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; quint64 va,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; quint8 &nbsp;asn,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const AlphaPTE &amp;pte,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool global = false) noexcept<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;return m_siliconTLB.spam().tlbInsert(<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cpuId,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Realm::D,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/*sizeClass*\/ 0,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;va,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;asn,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;global,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pte<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;);<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ -------------------------------------------------------------------<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ ITB interface (Instruction TLB)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ -------------------------------------------------------------------<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;bool lookupITB(quint16 cpuId,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; quint64 va,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; quint8 &nbsp;asn,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; quint32 &amp;outPfn,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PermMask &amp;outPermMask) const noexcept<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;return m_siliconTLB.spam().tlbLookup(<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cpuId,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Realm::I,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/*sizeClass*\/ 0,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;va,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;asn,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;outPfn,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;outPermMask<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;);<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;bool insertITB(quint16 cpuId,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; quint64 va,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; quint8 &nbsp;asn,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const AlphaPTE &amp;pte,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool global = false) noexcept<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;return m_siliconTLB.spam().tlbInsert(<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cpuId,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Realm::I,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/*sizeClass*\/ 0,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;va,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;asn,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;global,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pte<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;);<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ -------------------------------------------------------------------<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ Invalidation hooks ‚Äì these are what TBIS\/TBIA\/TBIAP will call.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ -------------------------------------------------------------------<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;void tbiVA(quint16 cpuId, quint64 va, Realm realm, quint8 asn) noexcept<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;m_siliconTLB.spam().invalidateVA(cpuId, realm, \/*sizeClass*\/ 0, va, asn);<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;void tbiAll(quint16 cpuId) noexcept<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;m_siliconTLB.spam().invalidateAll(cpuId);<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;void tbiASN(quint16 cpuId, quint8 asn) noexcept<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;m_siliconTLB.spam().invalidateASN(cpuId, asn);<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ -------------------------------------------------------------------<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ Access to underlying &quot;silicon&quot; if you need it for debug<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ -------------------------------------------------------------------<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;Ev6SiliconTLB &nbsp; &nbsp; &nbsp; &amp;siliconTLB() &nbsp; &nbsp; &nbsp; noexcept { return m_siliconTLB; }<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;const Ev6SiliconTLB &amp;siliconTLB() const noexcept { return m_siliconTLB; }<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">private:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;Ev6SiliconTLB m_siliconTLB;<\/p>\n\r<p class=\"p_Normal\">};<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&gt; **Note:** The methods `tlbLookup`, `tlbInsert`, `invalidateVA`, `invalidateAll`, `invalidateASN`, and `registerCPUCount` are already present or easy to add in your `SPAMShardManager` (if a couple are missing, we can trivially add them next).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This gives you a **clean, non-templated interface** that your PAL \/ TBI code can call:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* TBI hooks execute **Layer-1** (`Ev6TLBInterface::tbiVA\/tbiAll\/tbiASN`).<\/p>\n\r<p class=\"p_Normal\">* MFPR\/MTPR handlers for ITB\/DTB PTE\/TAG registers can:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Use EV6 register helpers (`ev6_ItbPteRead_Register`, `ev6_DtbPteTempRegister`, etc.)<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Populate an `AlphaPTE`<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Call `insertITB\/insertDTB` on this interface.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 4. How this matches your request<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You asked for:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&gt; * preserve the structure of the PTE<\/p>\n\r<p class=\"p_Normal\">&gt; * support cache pipelines (banks) and SMP<\/p>\n\r<p class=\"p_Normal\">&gt; * remove or hide trait\/templates<\/p>\n\r<p class=\"p_Normal\">&gt; * only EV6 for now<\/p>\n\r<p class=\"p_Normal\">&gt; * inject VA size \/ page sizes from config<\/p>\n\r<p class=\"p_Normal\">&gt; * have a ‚Äúsilicon‚Äù Layer-0 with Layer-1 helpers<\/p>\n\r<p class=\"p_Normal\">&gt; * TBI hooks at Layer-1, MFPR\/MTPR maybe at Layer-2<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">What we just did:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* **PTE structure is untouched** (`AlphaPTE_Core.h` is still canonical).<\/p>\n\r<p class=\"p_Normal\">* **Banks\/SMP behavior is preserved**:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `SPAMBucket` and `SPAMShardManager` remain your original code.<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* We just instantiate them once for `Ev6PTETraits`.<\/p>\n\r<p class=\"p_Normal\">* **Templates and Traits are hidden**:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Outside `Ev6PteSilicon.h`, you never mention `Traits`, template parameters, or `SPAMBucket&lt;...&gt;`.<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* You just use `Ev6SPAMShardManager` and `Ev6TLBInterface`.<\/p>\n\r<p class=\"p_Normal\">* **EV6-only**: the traits struct is `Ev6PTETraits`; no EV4\/EV5 special-casing.<\/p>\n\r<p class=\"p_Normal\">* **Page size config** is centralized in `Ev6SiliconConfig`, which can be fed from your JSON config.<\/p>\n\r<p class=\"p_Normal\">* **Layer-0 \/ Layer-1** separation is explicit:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* L0: `Ev6PteSilicon.h`<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* L1: `Ev6TLBInterface.h`<\/p>\n\r<p class=\"p_Normal\">* **TBI hooks** naturally map onto L1.<\/p>\n\r<p class=\"p_Normal\">* **MFPR\/MTPR** for ITB\/DTB can either:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Use L1 directly, or<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Sit in a small L2 wrapper that also handles IPR access, logging, etc.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If you‚Äôd like, next step I can:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Wire **concrete `tbi` PAL handlers** that call this interface.<\/p>\n\r<p class=\"p_Normal\">* Show how `MTPR ITB_PTE` \/ `MTPR DTB_PTE` decode EV6 register images into `AlphaPTE` using your existing `alpha_pte_traits_ev6_*` helpers and then call `insertITB\/insertDTB`.<\/p>\n\r<p class=\"p_Normal\">* Add explicit page-size class handling for 16K\/32K if you decide those should be ‚Äúsilicon-supported‚Äù modes and how to tie them into `Ev6VMConfig`.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">But the core ‚ÄúEV6-only silicon‚Äù plus non-templated API is now laid out.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r"
})
