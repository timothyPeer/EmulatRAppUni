hmLoadTopic({
hmKeywords:"",
hmTitle:"13.6 Stage Implementations",
hmDescription:"13.6.1 stage_IF() — Instruction Fetch  Consumes the FetchResult from m_pendingFetch (supplied by IBox via supplyFetchResult()). Transfers the decoded instruction...",
hmPrevLink:"13_5-pipeline-execution---tick.html",
hmNextLink:"13_7-stall-mechanics.html",
hmParentLink:"alphapipeline-implementation.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"alphapipeline-implementation.html\">Chapter 13 – AlphaPipeline Implementation<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 13 – AlphaPipeline Implementation > 13.6 Stage Implementations",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">13.6 Stage Implementations<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.6.1 stage_IF() — Instruction Fetch<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Consumes the FetchResult from m_pendingFetch (supplied by IBox via supplyFetchResult()). Transfers the decoded instruction (DecodedInstruction + grain pointer) into the IF-stage slot. Assigns monotonic sequence number (m_nextSequence++). Sets slot.valid = true, slot.cycle = m_cycleCount. No execution occurs here.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.6.2 stage_DE() — Decode<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Mostly a pass-through — the grain was pre-decoded in IBox during fetch. Future: could detect early hazards here.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.6.3 stage_IS() — Issue<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Mostly a pass-through — hazard checks are now performed in boxes during EX. Future: could handle dual-issue logic here.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.6.4 stage_EX() — Execute (Critical Stage)<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">All instruction semantics occur here. The implementation:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Early exits: if (!slot.valid || slot.stalled || slot.faultPending) return.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Illegal instruction check: if (!slot.grain) → set faultPending, trapCode = ILLEGAL_INSTRUCTION, return.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Grain execution: slot.grain→execute(slot) — the grain calls EBox, FBox, MBox, CBox, or PalBox as needed, performs arithmetic\/logical work, executes memory accesses, detects exceptions, sets stall or serialization flags, and produces result payload in slot.payLoad.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Branch\/jump misprediction detection: after execution, if isBranchOrJump and branchTaken, compare actualTarget vs predictedTarget. If mispredicted, set slot.flushPipeline = true.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Multi-cycle operations block EX until complete.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.6.5 stage_MEM() — Register Writeback + Stall Check<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Despite the name, no memory access occurs here (memory was accessed in EX via MBox). stage_MEM() has two responsibilities:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Register writeback: commitPending(slot) writes deferred register results from the PendingCommit structure. For integer results: slot.writeIntReg(destReg, value), then m_eBox→clearDirty(reg). For FP results: slot.writeFpReg(destReg, value), then m_fBox→clearDirty(reg).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Stall check: if needsMemoryBarrier and !memoryBarrierCompleted → stall. If needsWriteBufferDrain and !writeBufferDrained → stall. This is where barrier instructions block the pipeline until CBox confirms completion.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.6.6 stage_WB() — Store Commit and Retirement<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">WB is the architectural commit point. Execution order within stage_WB:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1. Fault check — if slot.faultPending: discard m_pending (younger instruction squashed), set PipelineAction::FAULT with trapCode\/faultVA\/faultPC, return immediately. The fault propagates to AlphaCPU via BoxResult::faultDispatched().<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">2. CALL_PAL check — if isCallPal(slot.di): discard m_pending (pipeline serializes), compute PAL entry vector via computeCallPalEntry(), set PipelineAction::PAL_CALL, return.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">3. Store commit — if slot has store semantics (S_Store): m_guestMemory→write64(slot.pa, slot.payLoad), then m_reservationManager→breakReservationsOnCacheLine(slot.pa).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">4. Branch predictor update — if branchTaken: m_cBox→updatePrediction(pc, taken, target).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">5. Retirement — commitInstruction(slot): increment m_instructionsRetired, update m_totalCycles, emit EXECTRACE_WB_RETIRE.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">6. Cleanup — slot.valid = false, slot.clear().<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Note: registers were already written in stage_MEM — WB only commits stores and retires.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: cpuCoreLib\/AlphaPipeline.h (stage implementations lines 860–1430).<\/span><\/p>\n\r"
})
