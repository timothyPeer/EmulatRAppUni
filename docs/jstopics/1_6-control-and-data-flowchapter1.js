hmLoadTopic({
hmKeywords:"",
hmTitle:"1.6 Control and Data Flow",
hmDescription:"At a high level, execution flows through the system as follows:",
hmPrevLink:"1_5-non-goalschapter1.html",
hmNextLink:"1_7-architectural-invariants.html",
hmParentLink:"chapter-1_.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-1_.html\">Chapter 1 - System Overview<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 1 - System Overview > 1.6 Control and Data Flow",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">1.6 Control and Data Flow<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">At a high level, execution flows through the system as follows:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">1.<\/span>Instructions are fetched and decoded by the IBox frontend. Decoding produces a grain — a cached instruction abstraction that is reused on subsequent fetches of the same pattern.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">2.<\/span>The grain enters the six-stage pipeline and advances through Fetch, Decode, Issue, Execute, Memory, and Writeback stages.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">3.<\/span>All architectural work occurs in the Execute (EX) stage. The grain\'s execute() method dispatches work to one or more Boxes (EBox for integer, FBox for floating-point, MBox for memory, CBox for barriers, PalBox for privileged operations).<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">4.<\/span>Memory accesses flow through MBox to GuestMemory. Virtual addresses are translated via the DTB (data) or ITB (instruction) translation buffers. Physical addresses route to SafeMemory (RAM) or MMIO regions (devices).<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">5.<\/span>Serialization is enforced explicitly through barriers (MB, WMB, EXCB, TRAPB) and PAL transitions. Barriers stall the pipeline frontend until release conditions are met.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">6.<\/span>Exceptions and interrupts are queued by the FaultDispatcher and delivered precisely at the Writeback commit point. Delivery flushes younger pipeline slots, preserves state, and vectors execution to PAL handlers.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">7.<\/span>Devices interact with the CPU through MMIO reads\/writes (strongly ordered, synchronous) and interrupts (asynchronous, sampled between instructions).<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">8.<\/span>Architectural state commits only in the Writeback stage. No earlier stage produces architecturally visible effects.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">No layer bypasses another\'s authority. The one-way dependency hierarchy enforces this: ExecutionCoordinator → AlphaCPU → IBox → AlphaPipeline\/Boxes → GuestMemory\/FaultDispatcher.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-2---execution-model.html\" class=\"topiclink\">Chapter 2 - Execution Model<\/a>; <a href=\"chapter-3---pipeline-architect.html\" class=\"topiclink\">Chapter 3 - Pipeline Architecture<\/a>; <a href=\"chapter-4---functionexecution-.html\" class=\"topiclink\">Chapter 4 - Functional Execution Domains (&quot;Boxes)<\/a>.<\/span><\/p>\n\r"
})
