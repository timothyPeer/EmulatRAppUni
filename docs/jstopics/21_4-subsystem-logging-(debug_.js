hmLoadTopic({
hmKeywords:"",
hmTitle:"21.4 Subsystem Logging (DEBUG_LOG)",
hmDescription:"Every major subsystem includes DEBUG_LOG instrumentation for operational diagnostics. Unlike the EXECTRACE system (which targets architectural trace records), DEBUG_LOG...",
hmPrevLink:"21_3-exectrace-instrumentation.html",
hmNextLink:"21_5-tracing-by-subsystem.html",
hmParentLink:"chapter-21---debugging_-tracin.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-21---debugging_-tracin.html\">Chapter 21 – Debugging, Tracing, and Determinism<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 21 – Debugging, Tracing, and Determinism > 21.4 Subsystem Logging (DEBUG_LOG)",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">21.4 Subsystem Logging (DEBUG_LOG)<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">Every major subsystem includes <span class=\"f_CodeExample\">DEBUG_LOG<\/span> instrumentation for operational diagnostics. Unlike the EXECTRACE system (which targets architectural trace records), DEBUG_LOG provides human-readable diagnostic output for development and troubleshooting.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Key rule:<\/span> Every DEBUG_LOG statement includes the CPU identifier when relevant. This is mandatory for SMP debugging — without CPU identification, cross-CPU event correlation is impossible. Examples from the codebase:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">DEBUG_LOG(QString(&quot;CPU%1:&nbsp;TLB&nbsp;shootdown&nbsp;VA=0x%2&nbsp;ASN=%3&nbsp;realm=%4&quot;)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;.arg(m_cpuId).arg(va,&nbsp;16,&nbsp;16,&nbsp;QChar(\'0\')).arg(asn).arg(realm));<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">DEBUG_LOG(QString(&quot;CPU%1:&nbsp;MTPR_SIRR&nbsp;IPL=%2&quot;).arg(m_cpuId).arg(ipl));<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">DEBUG_LOG(QString(&quot;PAL&nbsp;INTERRUPT:&nbsp;vector=0x%1,&nbsp;IPL=%2&quot;)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;.arg(vector,&nbsp;4,&nbsp;16,&nbsp;QChar(\'0\')).arg(ipl));<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The <span class=\"f_CodeExample\">DEBUG_LOG_CONTEXT<\/span> variant adds component tagging for filtering: <span class=\"f_CodeExample\">DEBUG_LOG_CONTEXT(&quot;CSERVE 0x01 called&quot;, &quot;PAL&quot;)<\/span>, <span class=\"f_CodeExample\">DEBUG_LOG_CONTEXT(&quot;Instruction fetched&quot;, &quot;IBox&quot;)<\/span>. The logging system supports the <span class=\"f_CodeExample\">logWithContext(LogLevel, component, message)<\/span> interface for structured log records with severity levels.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Subsystem-specific logging covers: CBox barrier stall and release events, FaultDispatcher event queueing, IPIManager send\/receive with command type and target CPU, MemoryBarrierCoordinator initiation\/acknowledgment\/timeout, ReservationManager reservation creation and invalidation with cache line addresses and CPU IDs, IRQPendingState interrupt assertion and delivery, SPAM TLB cache hit\/miss\/eviction statistics, and device MMIO reads\/writes.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-11---architectural-inv.html\" class=\"topiclink\">Chapter 11 - Architectural Invariants<\/a> (debugging invariants and recommended diagnostics).<\/span><\/p>\n\r"
})
