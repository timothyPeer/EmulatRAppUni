hmLoadTopic({
hmKeywords:"",
hmTitle:"Minimal Pal checklist",
hmDescription:"Excellent instinct — this is exactly the *right* pivot point.",
hmPrevLink:"",
hmNextLink:"",
hmParentLink:"appendix---trait-examples.html",
hmBreadCrumbs:"",
hmTitlePath:"Introduction > Appendix > Appendix I – Global Singletons",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">Minimal Pal checklist<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">Excellent instinct — this is exactly the *right* pivot point.<\/p>\n\r<p class=\"p_Normal\">To get from “architecture-complete” to **SRM prompt**, you need a **concrete, ordered boot contract**, not more abstractions.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Below is a **clean, final, actionable deliverable** you can drop straight into your developer guide.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"># Minimal PAL RESET → SRM Boot Checklist<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">*(Alpha AXP Emulator – EmulatR)*<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This section defines the **minimum operational steps** required for an Alpha CPU to transition from power-on\/reset into a functioning SRM console environment (`&gt;&gt;&gt;`). It is intentionally concrete and implementation-oriented.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This checklist is divided into **must-work**, **must-exist**, and **can-stub** phases so you can progress incrementally.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 1. Power-On \/ CPU Reset Entry<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 1.1 Reset Entry Conditions (Architectural Truths)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">On reset, the Alpha CPU enters **PAL mode** with tightly defined state:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Processor mode: **PAL**<\/p>\n\r<p class=\"p_Normal\">* Interrupts: **disabled**<\/p>\n\r<p class=\"p_Normal\">* Pipeline: **empty \/ flushed**<\/p>\n\r<p class=\"p_Normal\">* LL\/SC reservations: **cleared**<\/p>\n\r<p class=\"p_Normal\">* Write buffers: **drained**<\/p>\n\r<p class=\"p_Normal\">* TLBs: **invalid**<\/p>\n\r<p class=\"p_Normal\">* Caches: **invalid or disabled**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**EmulatR requirement**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* `AlphaCPU::reset()` must:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Flush pipeline<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Clear FaultDispatcher queues<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Clear LL\/SC reservations<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Clear pending IPIs<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Enter PAL mode explicitly<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 2. PAL RESET Vector Dispatch (MANDATORY)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 2.1 RESET Vector Resolution<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Alpha RESET does **not** jump to SRM directly.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">It jumps to a **PAL entry point**:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">PC = PAL_BASE + (PAL_RESET_VECTOR * 64)<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**EmulatR requirement**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* `PalVectorResolver` must:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Resolve RESET vector<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Redirect execution into `PalService::executeRESET()`<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 2.2 Minimal RESET PAL Handler Responsibilities<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Your RESET handler does **not** need full EV6 semantics initially.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">It must perform **only these steps**:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">#### REQUIRED<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Establish a **known-good stack**<\/p>\n\r<p class=\"p_Normal\">* Initialize **HWPCB** fields needed for PAL execution<\/p>\n\r<p class=\"p_Normal\">* Initialize **PAL shadow state**<\/p>\n\r<p class=\"p_Normal\">* Initialize exception vectors (even stubbed)<\/p>\n\r<p class=\"p_Normal\">* Transition into **CSERVE-based console loop**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">#### NOT REQUIRED (initially)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Full cache init<\/p>\n\r<p class=\"p_Normal\">* Full memory sizing<\/p>\n\r<p class=\"p_Normal\">* Full device discovery<\/p>\n\r<p class=\"p_Normal\">* Full TLB population<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 3. Stack &amp; Context Bring-Up (CRITICAL)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 3.1 Stack Pointer Initialization<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SRM assumes a valid stack **before** it calls anything.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**EmulatR requirement**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Allocate a **PAL stack region**<\/p>\n\r<p class=\"p_Normal\">* Set:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `R30` (SP)<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Any PAL shadow SP register you model<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If this is wrong → silent failure.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 3.2 HWPCB Initialization (Minimal)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">HWPCB does *not* need full correctness initially.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Minimum fields:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Saved PC<\/p>\n\r<p class=\"p_Normal\">* Saved PS<\/p>\n\r<p class=\"p_Normal\">* PAL scratch \/ shadow registers<\/p>\n\r<p class=\"p_Normal\">* Current ASN (can be 0)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 4. Transition to Console Environment (SRM Expectations)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SRM firmware expects **PAL to provide services**, not firmware logic.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 4.1 The CSERVE Contract (THIS IS THE KEY)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SRM does **not** directly poke devices.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">It calls:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">CALL_PAL CSERVE<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Everything flows through CSERVE.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 5. Minimal CSERVE Conformance Table (MVP)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You do **not** need full CSERVE.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You need **just enough** to get `&gt;&gt;&gt;`.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 5.1 REQUIRED CSERVE Functions (Minimal Set)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">| CSERVE Function | Purpose &nbsp; &nbsp; &nbsp; &nbsp;| Required Behavior &nbsp; &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| --------------- | -------------- | ------------------------ |<\/p>\n\r<p class=\"p_Normal\">| GETC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Console input &nbsp;| Block or poll host input |<\/p>\n\r<p class=\"p_Normal\">| PUTC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Console output | Write char to console &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| PUTS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| String output &nbsp;| Loop PUTC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| RESET_TERM &nbsp; &nbsp; &nbsp;| Terminal init &nbsp;| Can be no-op &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| SETMODE &nbsp; &nbsp; &nbsp; &nbsp; | Console mode &nbsp; | Can be ignored &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| GETENV &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Read env var &nbsp; | Read from SRMEnvStore &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| SETENV &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Write env var &nbsp;| Write to SRMEnvStore &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Everything else may return **UNIMPLEMENTED**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 5.2 EmulatR Mapping<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**PalService**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Decodes CSERVE selector<\/p>\n\r<p class=\"p_Normal\">* Dispatches to ConsoleManager<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**ConsoleManager**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Routes to `OPA0:` device<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**ConsoleOPA0Device**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Implements:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `getc()`<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `putc()`<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `puts()`<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is sufficient to print:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">SRM Console Vx.x<\/p>\n\r<p class=\"p_Normal\">&gt;&gt;&gt;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 6. SRM Environment Store (REQUIRED)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SRM expects environment variables to exist.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 6.1 Minimal Environment Variables<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You must support at least:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">| Variable &nbsp; &nbsp; &nbsp; | Purpose &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| -------------- | ------------------- |<\/p>\n\r<p class=\"p_Normal\">| `bootdef_dev` &nbsp;| Default boot device |<\/p>\n\r<p class=\"p_Normal\">| `boot_file` &nbsp; &nbsp;| Boot file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| `boot_osflags` | Flags &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| `auto_action` &nbsp;| Boot policy &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**EmulatR requirement**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* `SRMEnvStore` must:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Store key\/value pairs<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Return defaults if missing<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Persist optionally (later)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 7. PAL Mode Exit Rules (CRITICAL)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### 7.1 HW_REI Is the ONLY Exit<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SRM expects:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* PAL code never “falls through”<\/p>\n\r<p class=\"p_Normal\">* PAL returns via `HW_REI`<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**EmulatR requirement**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* `HW_REI` must:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Restore PC<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Restore PS<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Restore IPL<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Exit PAL mode<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Resume pipeline cleanly<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If HW_REI is wrong → *nothing works*.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 8. Interrupt Model (MINIMAL)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Initially, interrupts may be **disabled forever**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">That is acceptable.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SRM console polling works without interrupts.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 9. What You Can Stub (Safely)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You can reach `&gt;&gt;&gt;` **without**:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* DMA<\/p>\n\r<p class=\"p_Normal\">* Disk I\/O<\/p>\n\r<p class=\"p_Normal\">* Network<\/p>\n\r<p class=\"p_Normal\">* Full TLB shootdown<\/p>\n\r<p class=\"p_Normal\">* SMP<\/p>\n\r<p class=\"p_Normal\">* Cache coherency<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SRM prompt ≠ booting an OS.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 10. Boot Progression Milestones<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Use these checkpoints:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### Milestone 1<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* RESET enters PAL<\/p>\n\r<p class=\"p_Normal\">* CSERVE PUTS prints text<\/p>\n\r<p class=\"p_Normal\">* You see **any output**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### Milestone 2<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* GETC works<\/p>\n\r<p class=\"p_Normal\">* `&gt;&gt;&gt;` accepts keystrokes<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### Milestone 3<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* SRM variables readable<\/p>\n\r<p class=\"p_Normal\">* `SHOW` commands work (even stubbed)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### Milestone 4<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Disk device stub visible<\/p>\n\r<p class=\"p_Normal\">* `BOOT` command parsed (may fail)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 11. Common Failure Modes (Watch These)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">| Symptom &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Likely Cause &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| ----------------- | -------------------------- |<\/p>\n\r<p class=\"p_Normal\">| Silent hang &nbsp; &nbsp; &nbsp; | Stack not initialized &nbsp; &nbsp; &nbsp;|<\/p>\n\r<p class=\"p_Normal\">| No output &nbsp; &nbsp; &nbsp; &nbsp; | CSERVE PUTS\/PUTC missing &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| Immediate trap &nbsp; &nbsp;| HW_REI incorrect &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">| Random behavior &nbsp; | LL\/SC not cleared on RESET |<\/p>\n\r<p class=\"p_Normal\">| SRM loops forever | GETC returns garbage &nbsp; &nbsp; &nbsp; |<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 12. Recommended Next Two Tasks (Concrete)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### Task A — Implement Minimal RESET + CSERVE<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Hardcode RESET → CSERVE loop<\/p>\n\r<p class=\"p_Normal\">* Ignore everything else<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">### Task B — Lock Down Console Path<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* PalService → ConsoleManager → OPA0<\/p>\n\r<p class=\"p_Normal\">* No abstraction leaks<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## Final Reality Check<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If you implement **only** what is above, you will reach:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">Alpha SRM Console<\/p>\n\r<p class=\"p_Normal\">&gt;&gt;&gt;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">At that point, the emulator crosses from *architectural simulator* into *firmware-capable machine*.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Everything after that is incremental.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If you want next:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* I can produce a **CSERVE selector table based on SRM behavior**<\/p>\n\r<p class=\"p_Normal\">* Or a **minimal PAL RESET pseudocode listing**<\/p>\n\r<p class=\"p_Normal\">* Or a **step-by-step bring-up plan with TODO checkboxes**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Just tell me which one you want first.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r"
})
