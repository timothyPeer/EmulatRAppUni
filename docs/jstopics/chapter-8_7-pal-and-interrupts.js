hmLoadTopic({
hmKeywords:"",
hmTitle:"8.7 PAL and Exceptions\/Interrupts",
hmDescription:"8.7.1 Exception Entry  All architecturally visible exceptions ultimately enter PAL. The delivery sequence: fault detected in EX → FaultDispatcher queues event → faulting...",
hmPrevLink:"chapter-8_6-pal-and-exceptions.html",
hmNextLink:"chapter-8_8-pal-and-memory-ord.html",
hmParentLink:"chapter-8---pal-and-privleged-.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-8---pal-and-privleged-.html\">Chapter 8 - PAL and Privileged Boundary<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 8 - PAL and Privileged Boundary > 8.7 PAL and Exceptions\/Interrupts",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">8.7 PAL and Exceptions\/Interrupts<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">8.7.1 Exception Entry<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">All architecturally visible exceptions ultimately enter PAL. The delivery sequence: fault detected in EX → FaultDispatcher queues event → faulting instruction reaches WB → pipeline is flushed → state is saved via saveContext() → PAL vector is selected (from PalVectorId_EV6) → execution transfers to PAL handler via enterPal().<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">PAL is responsible for deciding whether to handle the exception internally, reflect it to the OS (via a second-level dispatch), or terminate execution.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">On entry, EXC_ADDR contains the faulting PC, EXC_SUM contains the exception summary, and PS reflects the pre-exception state. PAL code consumes and interprets this state.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">8.7.2 Interrupt Dispatch<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Interrupts are delivered through PAL in the same manner as faults. Interrupts are masked on entry (IPL raised to 7), PAL interrupt handlers run at elevated IPL, PAL acknowledges device sources, and PAL determines the return path.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">8.7.3 SMP and IPIs<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Inter-processor interrupts enter PAL mode on the target CPU, are dispatched via PAL vectors (PalVectorId_EV6::IPI_INTERRUPT = 0x0600), and may trigger TLB shootdowns or synchronize barrier completion. PAL is the only safe place to coordinate SMP state because it provides the serialized, privileged context needed for cross-CPU operations.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-7---interrupt-and-ipi-.html\" class=\"topiclink\">Chapter 7 - Exceptions, Faults, and Interrupts (detection and deliver mechanics)<\/a>.<\/span><\/p>\n\r"
})
