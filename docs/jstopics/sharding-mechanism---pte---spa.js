hmLoadTopic({
hmKeywords:"address space partitioning,address space sharding,broadcast invalidation,bucket,bucket index,bucketed lookup,cache consistency,cache flush sharding,cache invalidation sharding,cache isolation,cache locality,cache parallelism,cache partitioning,cache scalability,cache sharding,cache subset,fine-grained sharding,hash bucket,IPI-based invalidation,lock-free sharding,mini-cache,multicore sharding,parallel cache,partitioned cache,partitioned data structure,per-CPU invalidation,per-CPU shard,per-CPU TLB,per-realm shard,per-size-class shard,shard,shard dimensioning,shard index,sharded cache benefits,sharded cache requirements,sharding,sharding concurrency,sharding consistency,sharding implementation,sharding isolation,sharding locality,sharding mechanism,sharding parallelism,sharding scalability,shards,SMP sharding,SPAM manager shards,SPAM sharding,SPAMShardManager sharding,system-wide sharding,thread sharding,TLB isolation,TLB parallelism,TLB sharding",
hmTitle:"Sharding Mechanism - PTE - SPAMShardManager",
hmDescription:"What is Sharding? ----------------- Sharding is the process of partitioning a large set of cache (TLB\/PTE) entries into smaller, semi-independent subsets called \"shards.\"  Each...",
hmPrevLink:"",
hmNextLink:"",
hmParentLink:"appendix---trait-examples.html",
hmBreadCrumbs:"",
hmTitlePath:"Introduction > Appendix > Appendix I â€“ Global Singletons",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">Sharding Mechanism - PTE - SPAMShardManager<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\"><span style=\"font-style: italic;\">What is Sharding?<\/span><\/p>\n\r<p class=\"p_Normal\">-----------------<\/p>\n\r<p class=\"p_Normal\">Sharding is the process of partitioning a large set of cache (TLB\/PTE) entries into smaller, semi-independent subsets called &quot;shards.&quot; &nbsp;Each shard operates like a mini-cache, responsible for a subset of addresses, CPUs, realms, or size classes.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">In the Alpha PTE subsystem, the SPAMShardManager implements sharding along several axes:<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>**By CPU**: Each logical CPU (core\/thread) receives its own slice of the TLB cache.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>**By Realm**: Separate shards are maintained for instruction (ITB) and data (DTB) translation.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>**By Size Class**: If enabled (ShardBySize=true), entries can be grouped by page size (e.g., 8K, 64K).<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>**By Bucket Index**: Each shard subdivides its set into hash buckets for fast lookup.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">How Sharding Works<\/span><\/p>\n\r<p class=\"p_Normal\">------------------<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>The system allocates a multidimensional array of shards (e.g., [CPU][Realm][SizeClass][BucketIndex]).<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Each CPU\/thread works primarily with its own shard(s), reducing contention.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>When a translation (TLB) operation occurs, SPAMShardManager computes which shard\/bucket should handle the VA+ASN based on the CPU, realm (I\/D), and size class.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Entries are inserted, looked up, and invalidated only within their target shard, making operations more scalable and cache-efficient.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Configuration Example:<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;\/\/&nbsp;4&nbsp;CPUs,&nbsp;2&nbsp;realms&nbsp;(ITB\/DTB),&nbsp;2&nbsp;size&nbsp;classes,&nbsp;1024&nbsp;buckets:<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;m_buckets.resize(4);&nbsp;\/\/&nbsp;CPUs<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;c&nbsp;=&nbsp;0;&nbsp;c&nbsp;&lt;&nbsp;4;&nbsp;++c)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;r&nbsp;=&nbsp;0;&nbsp;r&nbsp;&lt;&nbsp;2;&nbsp;++r)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;s&nbsp;=&nbsp;0;&nbsp;s&nbsp;&lt;&nbsp;2;&nbsp;++s)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_buckets[c][r][s].resize(1024);<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">Benefits of Sharding<\/span><\/h3>\n\r<p class=\"p_Normal\">--------------------<\/p>\n\r<p class=\"p_Normal\">1. **Scalability**: Each CPU or thread has its own subset of entries, minimizing contention and lock overhead in multicore (SMP) systems.<\/p>\n\r<p class=\"p_Normal\">2. **Parallelism**: TLB fills, lookups, and invalidations can occur in parallel on different CPUs without interference.<\/p>\n\r<p class=\"p_Normal\">3. **Cache Locality**: Per-CPU shards improve CPU cache usage, as each thread tends to access its own recently used entries.<\/p>\n\r<p class=\"p_Normal\">4. **Lock-Free or Fine-Grained Locking**: With per-shard or per-bucket synchronization, global locks are not needed.<\/p>\n\r<p class=\"p_Normal\">5. **Isolation**: One CPU or realm\'s flush or invalidation affects only its shard, reducing unnecessary global invalidations.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">Requirements and Design Considerations<\/span><\/h3>\n\r<p class=\"p_Normal\">--------------------------------------<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>**Shard Dimensioning**: Must allocate enough shards to match the CPU count, realms (usually 2: ITB and DTB), and size classes required by the hardware and OS.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>**Bucket Count**: Each shard subdivides into hash buckets for fast lookup; bucket count should be a power of two for efficient hashing.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>**ASN Management**: Each shard maintains its own Address Space Number (ASN) epochs for efficient per-ASN invalidation.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>**Concurrency**: If CPUs\/threads operate in parallel, per-shard or per-bucket data must be thread-safe (e.g., atomic counters, QAtomicInteger, per-bucket locks).<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>**Consistency**: Broadcast invalidation (e.g., TBIA, TBIAP) may need to coordinate across all shards, such as via IPI messages in SMP.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">Notes on Implementation<\/span><\/h3>\n\r<p class=\"p_Normal\">-----------------------<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>The SPAMShardManager uses Qt containers (QVector, etc.) and static arrays for fast access.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Bucket index calculation is typically based on VA, realm, and size class (hashing).<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Per-CPU ASN epochs enable instant invalidation of all entries for a given ASN (no scanning required).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Example (Index Calculation):<\/span><\/p>\n\r<p class=\"p_CodeExample\">&nbsp;&nbsp;&nbsp;<span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;Tag&nbsp;struct&nbsp;contains&nbsp;vpn,&nbsp;realm,&nbsp;sizeClass.<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;\/\/&nbsp;Hash&nbsp;tag&nbsp;to&nbsp;pick&nbsp;a&nbsp;bucket&nbsp;inside&nbsp;a&nbsp;CPU\/realm\/size&nbsp;shard.<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;inline&nbsp;unsigned&nbsp;bucketIndex(const&nbsp;Tag&amp;&nbsp;t)&nbsp;noexcept&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quint64&nbsp;x&nbsp;=&nbsp;t.vpn&nbsp;^&nbsp;(quint64(t.realm)&nbsp;&lt;&lt;&nbsp;1)&nbsp;^&nbsp;(quint64(t.sizeClass)&nbsp;&lt;&lt;&nbsp;2);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;^=&nbsp;x&nbsp;&gt;&gt;&nbsp;33;&nbsp;x&nbsp;*=&nbsp;0xff51afd7ed558ccdULL;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;^=&nbsp;x&nbsp;&gt;&gt;&nbsp;33;&nbsp;x&nbsp;*=&nbsp;0xc4ceb9fe1a85ec53ULL;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;^=&nbsp;x&nbsp;&gt;&gt;&nbsp;33;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;unsigned(x)&nbsp;&amp;&nbsp;(BucketCount&nbsp;-&nbsp;1);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;&nbsp;&nbsp;&nbsp;}<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">Caveats and Best Practices<\/span><\/h3>\n\r<p class=\"p_Normal\">--------------------------<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Make sure all CPUs and realms have correctly dimensioned shards on initialization.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Sharding should match the parallelism and address space requirements of your target hardware.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Fine-grained sharding is more important as CPU count increases (e.g., &gt;2 CPUs).<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>For uniprocessor simulation, sharding can be simplified, but keeping the structure aids future SMP support.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">Summary<\/span><\/h3>\n\r<p class=\"p_Normal\">-------<\/p>\n\r<p class=\"p_Normal\">Sharding is a core scalability and efficiency feature in the PTE\/TLB subsystem, enabling per-CPU, per-realm, and per-size class caches that work in parallel and with minimal contention.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">References<\/span><\/h3>\n\r<p class=\"p_Normal\">----------<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>SPAMShardManager class (alpha_spam_manager.h)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Alpha AXP System Reference Manual: MMU\/TLB implementation notes<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>ASA-EmulatR Project Documentation<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Generated for ASA-EmulatR Project, 2025-11-14.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r"
})
