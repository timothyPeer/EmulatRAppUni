hmLoadTopic({
hmKeywords:"",
hmTitle:"Appendix H – Endianness Rules",
hmDescription:"Alpha is always little-endian. There is no big-endian mode. This is an architectural constant across all Alpha generations (21064, 21164, 21264\/EV6).",
hmPrevLink:"appendix-g---decodedinstructio.html",
hmNextLink:"appendix-i---global-singletons.html",
hmParentLink:"appendix---trait-examples.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"appendix---trait-examples.html\">Appendix<\/a>",
hmTitlePath:"Introduction > Appendix > Appendix H – Endianness Rules",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">Appendix H – Endianness Rules<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">Alpha is always little-endian. There is no big-endian mode. This is an architectural constant across all Alpha generations (21064, 21164, 21264\/EV6).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Instructions:<\/span> 32-bit instructions are stored in little-endian format in memory. Opcode extraction works on little-endian values. No byte-swapping is needed for instruction fetch.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Data accesses:<\/span> LDQ, LDL, LDWU, LDBU all read little-endian memory. STQ, STL, STW, STB all write little-endian. No automatic byte-swapping occurs in hardware.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Byte manipulation:<\/span> Alpha provides byte manipulation instructions (INSWL, EXTQH, INSBL, EXTBL, etc.) for software-controlled byte operations. Big-endian data must be explicitly converted by software. OSF\/1, Tru64 UNIX, and Linux\/Alpha all assume little-endian memory layout.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">MMIO:<\/span> Some Alpha systems (AlphaServer) have I\/O controllers that support per-device endianness configuration. This is handled by the I\/O bridge\/chipset, not the CPU. The CPU always operates in little-endian mode.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">EmulatR implementation rule:<\/span> SafeMemory stores all data in host-native format (little-endian on x86-64 hosts). No byte-swapping layer exists in the memory path. If running on a big-endian host (not a current target), a byte-swap layer would need to be added at the SafeMemory boundary.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: Alpha Architecture Reference Manual – Data Types; <a href=\"chapter-15---memory-system-imp.html\" class=\"topiclink\">Chapter 15 – Memory System Implementation Details<\/a> (SafeMemory).<\/span><\/p>\n\r"
})
