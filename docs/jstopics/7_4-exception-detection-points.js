hmLoadTopic({
hmKeywords:"AccessViolation,AlignmentFault,AlphaCPU,ArithmeticException,Barrier,checkInterrupts,ClaimedInterrupt,claimNext,ControlLogic,deliverInterrupt,Detection,DivideByZero,DTBMiss,EBox,Enable,ExecuteStage,Fault,FaultOnExecute,FaultOnRead,FaultOnWrite,FaultPending,FaultVA,FBox,FloatingPointException,FPCR,Grain,handleFPTrap,hasDeliverable,IllegalInstruction,Inexact,InstructionBoundary,Interrupt,InvalidOperation,IPL,IRQPendingState,ITBMiss,MBox,Overflow,PALMode,PalService,Pipeline,PipelineSlot,Precision,PrivilegeViolation,RunLoop,Sampling,Source,Speculation,TranslationFault,TrapCode,TrapEnable,Underflow,Vector",
hmTitle:"7.4 Exception Detection Points",
hmDescription:"7.4.1 Where Faults Are Detected  Faults are detected primarily in the Execute (EX) stage, during grain->execute(). Detection sources include: MBox — translation faults (DTB miss",
hmPrevLink:"chapter-7_3-exception-detectio.html",
hmNextLink:"chapter-7_4-faultdispatcher.html",
hmParentLink:"chapter-7---interrupt-and-ipi-.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-7---interrupt-and-ipi-.html\">Chapter 7 - Exceptions, Faults, and Interrupts<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 7 - Exceptions, Faults, and Interrupts > 7.4 Exception Detection Points",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">7.4 Exception Detection Points<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">7.4.1 Where Faults Are Detected<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Faults are detected primarily in the Execute (EX) stage, during grain-&gt;execute(). Detection sources include:<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>MBox — translation faults (DTB miss, ITB miss), alignment faults, access violations, fault-on-read\/write\/execute<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>EBox — integer arithmetic exceptions (overflow, divide by zero)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>FBox — floating-point exceptions (overflow, underflow, inexact, invalid, divide by zero), detected via handleFPTrap() and FPCR trap-enable checks<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Pipeline control logic — illegal instruction (null grain in EX), privileged instruction violation (PAL-mode-only instruction executed in user mode)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">When a fault is detected, the detecting code sets slot.faultPending = true, slot.trapCode, and slot.faultVA in the PipelineSlot. Faults are never speculative — a fault detected in EX is guaranteed to be delivered precisely.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">7.4.2 Where Interrupts Are Sampled<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Interrupts are sampled during the pre-cycle phase of the run loop, via AlphaCPU::checkInterrupts(). This occurs before pipeline advancement, after barrier release checks, and only when interrupts are enabled.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The check is fast: IRQPendingState::hasDeliverable(currentIPL) tests whether any pending interrupt level exceeds the current IPL. If deliverable, claimNext() atomically claims the highest-priority pending interrupt and returns a ClaimedInterrupt with the source, IPL, and vector. The interrupt is then delivered via PalService::deliverInterrupt().<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Interrupts are not taken mid-instruction.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: cpuCoreLib\/AlphaCPU.h (checkInterrupts); coreLib\/IRQPendingState.h.<\/span><\/p>\n\r"
})
