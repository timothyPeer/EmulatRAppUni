hmLoadTopic({
hmKeywords:"AlphaCPU,AlphaPipeline,Barriers,Boxes,CBox,Coherency,Control,Controllers,CPUId,Devices,DMA,Domains,DTB,EBox,Execution,ExecutionCoordinator,FaultDispatcher,FBox,Grains,GuestMemory,IBox,IDeviceEmulator,IPIs,IPRs,ITB,Layers,MBox,Memory,MMIO,mmio_DMACoherencyManager,mmio_Manager,PAL,PalBox,PCI,PipelineSlot,Privilege,PTE,Reservations,SafeMemory,SCSI,SMP,SMPManager,SPAM,Storage,TLB,Translation",
hmTitle:"1.4 Major Architectural Layers",
hmDescription:"EMulatR is structured into six conceptual layers. Each layer has a clearly defined responsibility and communicates with adjacent layers through explicit interfaces. No layer...",
hmPrevLink:"chapter-1_3---major-architectu.html",
hmNextLink:"1_5-non-goalschapter1.html",
hmParentLink:"chapter-1_.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-1_.html\">Chapter 1 - System Overview<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 1 - System Overview > 1.4 Major Architectural Layers",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">1.4 Major Architectural Layers<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">EMulatR is structured into six conceptual layers. Each layer has a clearly defined responsibility and communicates with adjacent layers through explicit interfaces. No layer bypasses another\'s authority.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">1.4.1 Execution Layer<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The execution layer owns the per-CPU run loop and instruction lifecycle. It consists of AlphaCPU (the unit of execution), AlphaPipeline (the six-stage pipeline), PipelineSlot (per-stage instruction state), and instruction grains (the decoded instruction abstraction). Each AlphaCPU instance represents one physical Alpha processor with its own independent run loop, register files, and pipeline state.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">1.4.2 Execution Domains (Boxes)<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Execution is partitioned into six functional domains called Boxes. Each Box groups related architectural behavior and is invoked by grains during the Execute (EX) stage. Boxes are capability boundaries, not control boundaries — they do not own time, do not schedule instructions, and do not advance the pipeline.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>IBox – Instruction frontend (fetch, decode, grain resolution)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>EBox – Integer and address execution (ALU, conditional moves)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>FBox – Floating-point execution (IEEE 754, VAX compatibility)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>MBox – Memory operations (load\/store, DTB translation)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>CBox – Coherency and serialization (barriers, write buffer, LL\/SC)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>PalBox – Privileged execution (CALL_PAL, MFPR\/MTPR, mode transitions)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">1.4.3 Memory and Coherency Layer<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The memory layer models Alpha\'s weakly ordered memory architecture. GuestMemory represents the shared physical address space and is the sole authority for physical memory visibility, LL\/SC reservation invalidation, and SMP coherency effects. SafeMemory provides the backing store with bounds checking. The PTE\/TLB subsystem handles virtual-to-physical translation with per-CPU ITB and DTB instances using SPAM (Set-Partitioned Address Mapping) structures.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">1.4.4 Privilege and Control Layer<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The privilege layer enforces Alpha\'s hardware-defined privileged execution environment. PAL (Privileged Architecture Library) is the sole authority for exception dispatch, interrupt dispatch, privileged register access (IPRs), context switching, and low-level SMP coordination. The FaultDispatcher queues and prioritizes all exceptional conditions. IPR storage provides dedicated registers for processor control state.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">1.4.5 SMP Coordination Layer<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The SMP layer manages multi-processor coordination. CPUs are created and identified by the SMP Manager within the ExecutionCoordinator. Each CPU has a unique CPUId with independent pipeline, registers, TLBs, write buffers, and LL\/SC reservation state. Cross-CPU coordination occurs exclusively through GuestMemory (visibility and LL\/SC invalidation), barriers (ordering enforcement), and IPIs (explicit signaling including TLB shootdown).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">1.4.6 Device and MMIO Layer<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The device layer models external hardware agents that participate in the memory system. Devices are memory-mapped, asynchronous, interrupt-driven, and strongly ordered at the MMIO boundary. The mmio_Manager routes accesses to registered IDeviceEmulator instances. DMA transfers are coordinated by the mmio_DMACoherencyManager. The controller stack implements a PCI bus model with SCSI host adapters and virtual storage devices.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-4---functionexecution-.html\" class=\"topiclink\">Chapter 4 - Functional Execution Domains (&quot;Boxes)<\/a>; <a href=\"chapter-5---memory-system-arch.html\" class=\"topiclink\">Chapter 5 - Memory System Architecture<\/a>; <a href=\"chapter-8---pal-and-privleged-.html\" class=\"topiclink\">Chapter 8 - PAL and Privileged Boundary<\/a>; <a href=\"chapter9-smparchitecture.html\" class=\"topiclink\">Chapter 9 - SMP Architecture<\/a>; <a href=\"chapter-10---devices-and-mmio.html\" class=\"topiclink\">Chapter 10 – Devices and Memory-Mapped I\/O (MMIO)<\/a>.<\/span><\/p>\n\r"
})
