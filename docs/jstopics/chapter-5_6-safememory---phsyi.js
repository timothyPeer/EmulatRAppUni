hmLoadTopic({
hmKeywords:"",
hmTitle:"5.6 SafeMemory - Physical RAM Backend",
hmDescription:"5.6.1 Role  SafeMemory implements actual physical RAM storage. It is the \"dumb backend\" — intentionally simple, with no architectural knowledge.  Characteristics: byte-addressa",
hmPrevLink:"chapter-5_5-guestmemory---shar.html",
hmNextLink:"chapter-5_7-mmio-regions.html",
hmParentLink:"chapter-5---memory-system-arch.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-5---memory-system-arch.html\">Chapter 5 - Memory System Architecture<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 5 - Memory System Architecture > 5.6 SafeMemory - Phsyical RAM Backend",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">5.6 SafeMemory - Physical RAM Backend<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">5.6.1 Role<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SafeMemory implements actual physical RAM storage. It is the &quot;dumb backend&quot; — intentionally simple, with no architectural knowledge.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Characteristics: byte-addressable, bounds-checked, thread-safe, deterministic, no ordering semantics. SafeMemory does not perform translation, enforce barriers, track reservations, or understand CPUs.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">5.6.2 Internal Layout<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SafeMemory is discontinuous in PA space but contiguous internally. Two PA regions map into a single contiguous buffer:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SafeMemory offset 0x0000_0000 — PA range 0x0000_0000–0x0001_0000 — Low 64 KB (includes HWRPB at +0x2000)<\/p>\n\r<p class=\"p_Normal\">SafeMemory offset 0x0001_0000 — PA range 0x8000_0000–0x8_8000_0000 — Main RAM (32 GB)<\/p>\n\r<p class=\"p_Normal\">Total size: 64 KB + 32 GB = 0x8_0001_0000 bytes<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The PA→offset translation is:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;Region&nbsp;1:&nbsp;Low&nbsp;64&nbsp;KB&nbsp;(PA&nbsp;0x0&nbsp;-&nbsp;0x10000)&nbsp;→&nbsp;offset&nbsp;=&nbsp;PA&nbsp;directly<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;Region&nbsp;2:&nbsp;Main&nbsp;RAM&nbsp;(PA&nbsp;0x80000000&nbsp;-&nbsp;0x880000000)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">\/\/&nbsp;→&nbsp;offset&nbsp;=&nbsp;(pa&nbsp;-&nbsp;0x80000000)&nbsp;+&nbsp;0x00010000<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">5.6.3 Sparse Memory Backing<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SafeMemory uses SparseMemoryBacking (SparseMemoryBacking.h, 507 lines) for on-demand page allocation. Physical pages are allocated only when first accessed via ensurePage(pageIdx), using atomic page pointers (std::atomic&lt;quint8*&gt;) for thread safety. This avoids pre-allocating the full 32 GB address space. The allocatedBytes() method reports actual memory consumption versus the total addressable range.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">5.6.4 API<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SafeMemory provides typed load\/store methods at all standard widths (load8\/store8 through load64\/store64) plus a generic load(offset, size, &amp;out) and store(offset, size, value). All methods return MEM_STATUS. getSpan(offset, requestedLen, intent) returns a MemorySpan for direct pointer access, truncated at 64 KB page boundaries.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Implementation: SafeMemory.h (253 lines) + SafeMemory.cpp.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Key design point: No AlphaMemorySystem — HWRPB lives in SafeMemory at PA 0x2000, written directly via GuestMemory spans during initialization. PAL is C++ code, not a memory region. This eliminates data duplication and synchronization issues.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: memoryLib\/SafeMemory.h; memoryLib\/SparseMemoryBacking.h.<\/span><\/p>\n\r"
})
