hmLoadTopic({
hmKeywords:"",
hmTitle:"16.8 IRQ Integration Architecture",
hmDescription:"16.8.1 IRQ System Migration  The device interrupt architecture in ASA-EmulatR has been migrated away from the legacy IRQController class. Device IRQ interfaces are now handled...",
hmPrevLink:"16_7-network-and-fibre-channel.html",
hmNextLink:"16_9-dma-implementation.html",
hmParentLink:"chapter-16---device-model--dma.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-16---device-model--dma.html\">Chapter 16 – Device Model &amp; DMA<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 16 – Device Model & DMA > 16.8 IRQ Integration Architecture",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">16.8 IRQ Integration Architecture<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">16.8.1 IRQ System Migration<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The device interrupt architecture in ASA-EmulatR has been migrated away from the legacy <span class=\"f_CodeExample\">IRQController<\/span> class. Device IRQ interfaces are now handled by the newer IRQ system located in <span class=\"f_CodeExample\">coreLib\/<\/span>, which provides a more modular, lock-free hot path and cleaner separation between device interrupt assertion, CPU polling, and PAL delivery.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The current IRQ architecture is organized around the following components in <span class=\"f_CodeExample\">coreLib\/<\/span>:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span><span class=\"f_CodeExample\">IRQPendingState<\/span> — Per-CPU interrupt state using atomic bitmask operations. Provides the lock-free hot path: <span class=\"f_CodeExample\">hasPendingInterrupt()<\/span> reads an <span class=\"f_CodeExample\">atomic&lt;quint32&gt;<\/span> pendingIPLMask with no locking. Interrupt assertion sets bits in the mask; acknowledgment clears them.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span><span class=\"f_CodeExample\">IPI_core.h<\/span> — Inter-processor interrupt definitions: <span class=\"f_CodeExample\">IPICommand<\/span> enum (TLB shootdown, barrier synchronization, custom messages), IPI delivery through the per-CPU pending state.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span><span class=\"f_CodeExample\">onIPLChanged_inl.h<\/span> — Inline handler invoked when the current IPL changes (via MTPR SIRR or PAL exit), re-evaluating which pending interrupts are now deliverable.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">16.8.2 Device Interrupt Flow (Current Architecture)<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The device-to-PAL interrupt delivery path using the current <span class=\"f_CodeExample\">coreLib\/<\/span> IRQ system:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Device&nbsp;completes&nbsp;operation&nbsp;(in&nbsp;device&nbsp;I\/O&nbsp;thread)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;▼<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Assert&nbsp;IRQ:&nbsp;set&nbsp;bit&nbsp;in&nbsp;target&nbsp;CPU\'s&nbsp;IRQPendingState<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;pendingIPLMask&nbsp;|=&nbsp;(1&nbsp;&lt;&lt;&nbsp;deviceIPL)&nbsp;[atomic,&nbsp;lock-free]<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;▼<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">CPU&nbsp;run&nbsp;loop:&nbsp;AlphaCPU::runOneInstruction()<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;if&nbsp;(!inPalMode)&nbsp;poll&nbsp;IRQPendingState&nbsp;[lock-free&nbsp;read]<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;▼<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">hasPendingInterrupt(currentIPL)&nbsp;→&nbsp;true<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;(pending&nbsp;IPL&nbsp;&gt;&nbsp;current&nbsp;IPL,&nbsp;not&nbsp;in&nbsp;PAL&nbsp;mode)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;▼<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Deliver&nbsp;to&nbsp;FaultDispatcher&nbsp;→&nbsp;PendingEvent<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;▼<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">PAL&nbsp;INTERRUPT&nbsp;handler&nbsp;entry<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;▼<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">PAL&nbsp;identifies&nbsp;source,&nbsp;acknowledges&nbsp;(MMIO&nbsp;write&nbsp;to&nbsp;device)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;▼<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Device&nbsp;clears&nbsp;interrupt&nbsp;condition<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;▼<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">HW_REI&nbsp;returns&nbsp;to&nbsp;interrupted&nbsp;code<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The hot path — polling for pending interrupts during the CPU run loop — is entirely lock-free. The <span class=\"f_CodeExample\">pendingIPLMask<\/span> is an atomic bitmask where each bit corresponds to an IPL level. Reading this mask costs approximately 5 cycles (single atomic load), making per-instruction interrupt polling practical without performance impact.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">16.8.3 IRQ Routing and Affinity<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Device interrupts are routed to specific CPUs based on routing policy. The supported policies are:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Policy<\/span><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Behavior<\/span><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">FIXED_CPU<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Always delivered to a specific CPU (affinity-pinned). Used for boot devices and primary console.<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">ROUND_ROBIN<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Rotates across available CPUs for load distribution.<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">LOWEST_IPL<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Delivered to the CPU currently running at the lowest IPL (most likely to accept the interrupt promptly).<\/p>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Routing policy is configured per device vector in the <span class=\"f_CodeExample\">IrqTemplate<\/span> structure within <span class=\"f_CodeExample\">DeviceTemplate<\/span>. The default for most devices is <span class=\"f_CodeExample\">FIXED_CPU<\/span> with affinity to CPU 0, matching typical Alpha firmware behavior where the primary CPU handles all device interrupts until the OS reconfigures routing.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">16.8.4 Level-Triggered vs Edge-Triggered Semantics<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The IRQ system supports both trigger modes via the <span class=\"f_CodeExample\">IRQTrigger<\/span> enumeration. <span style=\"font-weight: bold;\">Level-triggered<\/span> interrupts remain asserted until the device explicitly clears the condition (typically via an MMIO register write from PAL). The <span class=\"f_CodeExample\">inServiceMask<\/span> in <span class=\"f_CodeExample\">IRQPendingState<\/span> tracks level-triggered sources to prevent re-delivery while the interrupt is being serviced. <span style=\"font-weight: bold;\">Edge-triggered<\/span> interrupts are one-shot: the pending bit is set on assertion and consumed on delivery, with no in-service tracking needed.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Most Alpha device interrupts are level-triggered. Edge-triggered mode is used for specific IPI types and timer interrupts.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: coreLib\/IRQPendingState.h – Per-CPU interrupt state; coreLib\/IPI_core.h – IPI definitions; <a href=\"chapter-7_9-interrupt-handling.html\" class=\"topiclink\">7.10 Interrupt Handling<\/a>; <a href=\"chapter-9_6-write-buffers-in-s.html\" class=\"topiclink\">9.6 Inter-Processor Interrupts (IPIs)<\/a> .<\/span><\/p>\n\r"
})
