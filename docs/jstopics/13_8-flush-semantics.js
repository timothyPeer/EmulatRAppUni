hmLoadTopic({
hmKeywords:"BoxResult,BranchMisprediction,CALL_PAL,Caller,clear,clearIPRStaging,clearMissStaging,Corrected,Deterministic,Exception,EXECTRACE_PIPELINE_FLUSH,executeREI,Fatal,Fault,Fetch,flush,Flush,flushPipeline,flushYoungerSlots,FullFlush,handleInterrupt,HW_REI,Interrupt,Invalidate,IPRStaging,MBox,MissStaging,PAL_CALL,PartialFlush,PC,PendingCommit,Pipeline,Precise,Restart,runOneInstruction,Slot,STAGE_COUNT,stage_EX,stage_WB,TLBFill,valid",
hmTitle:"13.8 Flush Semantics",
hmDescription:"13.8.1 Flush Triggers  Pipeline flush occurs on: branch misprediction (slot.flushPipeline from EX), exception delivery (from runOneInstruction after BoxResult), interrupt...",
hmPrevLink:"13_7-stall-mechanics.html",
hmNextLink:"13_9-serialization-and-barrier.html",
hmParentLink:"alphapipeline-implementation.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"alphapipeline-implementation.html\">Chapter 13 – AlphaPipeline Implementation<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 13 – AlphaPipeline Implementation > 13.8 Flush Semantics",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">13.8 Flush Semantics<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.8.1 Flush Triggers<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Pipeline flush occurs on: branch misprediction (slot.flushPipeline from EX), exception delivery (from runOneInstruction after BoxResult), interrupt delivery (handleInterrupt()), CALL_PAL (from stage_WB PAL_CALL path), HW_REI (executeREI()), and fatal fault.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.8.2 Full Flush<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The flush() implementation:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">void&nbsp;flush(const&nbsp;char*&nbsp;caller)&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;stage(m_head).m_pending&nbsp;=&nbsp;PendingCommit{};&nbsp;\/\/&nbsp;Clear&nbsp;pending&nbsp;commit<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;STAGE_COUNT;&nbsp;i++)&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;stage(i).clear();<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;stage(i).valid&nbsp;=&nbsp;false;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;}<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;if&nbsp;(m_mBox)&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;m_mBox-&gt;clearMissStaging();<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;m_mBox-&gt;clearIPRStaging();<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;}<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">}<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">All slots are invalidated, pending commits are discarded, and MBox staging state is cleared. The <span class=\"f_CodeExample\">clearMissStaging()<\/span> call discards any in-progress TLB fill that has not yet been committed to the TLB — without this, a speculative TLB fill from a flushed instruction could corrupt the translation buffer. The <span class=\"f_CodeExample\">clearIPRStaging()<\/span> call discards any staged IPR write that has not yet been committed — without this, a flushed HW_MTPR could silently modify privileged state.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Flush is logged via EXECTRACE_PIPELINE_FLUSH with the caller name and current PC. The caller parameter identifies the flush source for debugging (e.g., &quot;stage_WB:FAULT&quot;, &quot;handleInterrupt&quot;, &quot;executeREI&quot;). After flush, fetch restarts at the corrected PC. Flushes are precise and deterministic — identical inputs always produce identical flush behavior.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.8.3 Partial Flush<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Partial flush (flushYoungerSlots()) occurs when EX sets slot.flushPipeline — execute() invalidates stages 0 through STAGEEX−1 (IF, DE, IS) while preserving EX, MEM, and WB. This is the branch misprediction path: the mispredicted instruction in EX has already produced its result, and older instructions in MEM and WB must still retire. Only the younger speculatively-fetched instructions are discarded.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">After partial flush, IBox refetches from the corrected branch target on the next cycle. The EX slot advances normally through MEM and WB.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: Section 3.15 – Flush Mechanics; <a href=\"chapter-22---testing_-validati.html\" class=\"topiclink\">Chapter 22 – Testing, Validation, and Architectural Compliance<\/a> (flushYoungerSlots verification).<\/span><\/p>\n\r"
})
