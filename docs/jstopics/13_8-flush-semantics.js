hmLoadTopic({
hmKeywords:"",
hmTitle:"13.8 Flush Semantics",
hmDescription:"Pipeline flush occurs on: branch misprediction (slot.flushPipeline from EX), exception delivery (from runOneInstruction after BoxResult), interrupt delivery...",
hmPrevLink:"13_7-stall-mechanics.html",
hmNextLink:"13_9-serialization-and-barrier.html",
hmParentLink:"alphapipeline-implementation.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"alphapipeline-implementation.html\">Chapter 13 – AlphaPipeline Implementation<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 13 – AlphaPipeline Implementation > 13.8 Flush Semantics",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">13.8 Flush Semantics<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">Pipeline flush occurs on: branch misprediction (slot.flushPipeline from EX), exception delivery (from runOneInstruction after BoxResult), interrupt delivery (handleInterrupt()), CALL_PAL (from stage_WB PAL_CALL path), HW_REI (executeREI()), and fatal fault.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The flush() implementation:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">void&nbsp;flush(const&nbsp;char*&nbsp;caller)&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;stage(m_head).m_pending&nbsp;=&nbsp;PendingCommit{};&nbsp;\/\/&nbsp;Clear&nbsp;pending&nbsp;commit<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;STAGE_COUNT;&nbsp;i++)&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;stage(i).clear();<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;stage(i).valid&nbsp;=&nbsp;false;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;}<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;if&nbsp;(m_mBox)&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;m_mBox-&gt;clearMissStaging();<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;m_mBox-&gt;clearIPRStaging();<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;}<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">}<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">All slots are invalidated, pending commits are discarded, MBox staging state is cleared. Flush is logged via EXECTRACE_PIPELINE_FLUSH with the caller name and current PC. After flush, fetch restarts at the corrected PC. Flushes are precise and deterministic.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Partial flush (younger stages only) occurs when EX sets slot.flushPipeline — execute() invalidates stages 0 through STAGEEX-1 (IF, DE, IS) while preserving EX, MEM, and WB.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: Section 3.15 – Flush Mechanics.<\/span><\/p>\n\r"
})
