hmLoadTopic({
hmKeywords:"",
hmTitle:"9.7 Memory Barrier Coordination",
hmDescription:"9.7.1 MemoryBarrierCoordinator  MemoryBarrierCoordinator (MemoryBarrierCoordinator.h, 278 lines) is a singleton that manages global memory barrier synchronization across all...",
hmPrevLink:"chapter-9_6-write-buffers-in-s.html",
hmNextLink:"chapter-9_8-inter-processor-in.html",
hmParentLink:"chapter9-smparchitecture.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter9-smparchitecture.html\">Chapter 9 - SMP Architecture<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 9 - SMP Architecture > 9.7 Memory Barrier Coordination",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">9.7 Memory Barrier Coordination<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">9.7.1 MemoryBarrierCoordinator<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">MemoryBarrierCoordinator (MemoryBarrierCoordinator.h, 278 lines) is a singleton that manages global memory barrier synchronization across all CPUs. It is accessed via global_MemoryBarrierCoordinator().<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Barrier state tracks: barrierInProgress (atomic bool), initiatingCpu, participatingCpus count, waitingCpus count (atomic), acknowledgedCpus count (atomic), and a QWaitCondition (barrierComplete) for blocking the initiating CPU until all acknowledgments arrive.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">9.7.2 Global Barrier Sequence<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">When CPU N executes MB in SMP, the following sequence occurs:<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">1.<\/span>CBox::executeMB() drains the local write buffer<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">2.<\/span>CBox::RequestMemoryBarrier() calls ExecutionCoordinator::requestMemoryBarrier(cpuId)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">3.<\/span>ExecutionCoordinator calls MemoryBarrierCoordinator::initiateGlobalMemoryBarrier(cpuId, activeCpuCount). If only one CPU is active, the barrier completes immediately (returns false). If a barrier is already in progress, the CPU joins the existing barrier (returns false).<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">4.<\/span>The coordinator initializes barrier state and the initiating CPU self-acknowledges immediately<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">5.<\/span>ExecutionCoordinator sends MEMORY_BARRIER_FULL IPIs to all other active CPUs via encodeIPIData(IPICommand::MEMORY_BARRIER_FULL, 0)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">6.<\/span>Initiating CPU calls waitForBarrierAcknowledge(cpuId) — blocks on QWaitCondition with a 2-second timeout<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">7.<\/span>Target CPUs receive the IPI, enter PAL, drain their write buffers, and call acknowledgeMemoryBarrier(cpuId)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">8.<\/span>When all CPUs have acknowledged, the QWaitCondition is signaled, barrierInProgress is cleared, and the initiating CPU resumes<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">9.7.3 Barrier Timeout and Machine Check<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If the 2-second timeout expires before all CPUs acknowledge, the coordinator raises a machine check event (MachineCheckReason::SMP_BARRIER_TIMEOUT) via the FaultDispatcher. The MCES register\'s MME bit determines whether this is a fatal error or suppressed. This prevents a hung CPU from deadlocking the system.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">9.7.4 Local vs Global Barriers<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">WMB is local-only — drains the local write buffer, no global coordination, no IPIs. This makes WMB significantly cheaper than MB in SMP configurations. MB requires global coordination when activeCpuCount &gt; 1. PAL barriers (MemoryBarrierKind::PAL) use the same global coordination path as MB.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: memoryLib\/MemoryBarrierCoordinator.h; emulatrLib\/ExecutionCoordinator.h (requestMemoryBarrier).<\/span><\/p>\n\r"
})
