hmLoadTopic({
hmKeywords:"AlphaCPU,AlphaPipeline,Architectural,BoxResult,BranchPredictor,branchTaken,breakReservationsOnCacheLine,CALL_PAL,clearDirty,clearIPRStaging,clearMissStaging,Commit,commitInstruction,commitPending,commitPrevious,computeCallPalEntry,Correctness,Cycle,Deferred,deferWriteback,Discard,EBox,enterPal,EX,EXC_ADDR,Exception,EXECTRACE_WB_RETIRE,Fault,faultDispatched,faultPC,faultPending,faultVA,FBox,Flush,flushYoungerSlots,fpClearDirty,fpReg,fpValid,fpValue,GuestMemory,HW_REI,ILLEGAL_INSTRUCTION,InOrder,intClearDirty,intReg,intValid,intValue,Invariant,Irreversible,LLSC,m_instructionsRetired,m_pending,m_totalCycles,MBox,MEM,Ordering,PAL_CALL,palFunction,palVector,payLoad,PendingCommit,Pipeline,PipelineAction,PipelineSlot,PipelineStepResult,Precise,Register,Reservation,Retire,Retirement,S_Store,SafeMemory,Scoreboard,Serialization,slotSequence,SMP,Squash,stage_EX,stage_MEM,stage_WB,Store,trapCode,updatePrediction,valid,WB,Writeback",
hmTitle:"Appendix K – Pipeline Retirement Mechanics",
hmDescription:"Pipeline retirement is the architectural commit point — the moment an instruction\'s effects become permanently visible to all observers. This appendix provides the...",
hmPrevLink:"b_1---pipeline-cycle-mechanics.html",
hmNextLink:"appendix-c---glossary-and-acro.html",
hmParentLink:"appendixh-alphapipeline.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"appendix---trait-examples.html\">Appendix<\/a> &gt; <a href=\"appendixh-alphapipeline.html\">Appendix H - Alpha Pipeline&nbsp;<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Appendix > Appendix H - Alpha Pipeline  > H.2 - Pipeline Retirement Mechanics",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">Appendix K – Pipeline Retirement Mechanics<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">Pipeline retirement is the architectural commit point — the moment an instruction\'s effects become permanently visible to all observers. This appendix provides the authoritative reference for the retirement contract, the deferred writeback mechanism, and the three retirement outcomes (normal commit, fault delivery, PAL transfer). Chapter 13.6.6 describes the stage_WB() execution order; this appendix explains why each step exists and what invariants it preserves.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">K.1 What &quot;Architecturally Committed&quot; Means<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">An instruction is architecturally committed when all three conditions hold:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Visible<\/strong> — the instruction\'s register writes are in the architectural register file, and its store (if any) is in SafeMemory. Any subsequent instruction reading the same register or memory address will observe the committed value.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Irreversible<\/strong> — the instruction\'s effects cannot be undone by any future pipeline event (flush, fault, interrupt). Once committed, the instruction is part of the permanent execution history.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Precise<\/strong> — all instructions older than this one have already committed (in program order). No instruction younger than this one has committed. The PC reflects the committed instruction stream exactly.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Retirement is the only point where these three conditions become true simultaneously. Prior to retirement, an instruction\'s results are speculative — they may be discarded on flush.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">K.2 Deferred Writeback — The PendingCommit Mechanism<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">The problem:<\/strong> When a grain executes in stage_EX(), it produces a result (slot.payLoad). That result must eventually reach the architectural register file. But writing immediately in EX would violate precise exceptions — if the instruction later faults (or a younger instruction faults first), the register write cannot be undone.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">The solution:<\/strong> Deferred writeback. The result is captured in a PendingCommit structure and written to the register file one stage later, in stage_MEM(), via commitPending(). This separates result production (EX) from result publication (MEM), allowing faults to discard uncommitted results.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">K.2.1 PendingCommit Structure<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">struct&nbsp;PendingCommit&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;bool&nbsp;intValid{false};&nbsp;\/\/&nbsp;Integer&nbsp;result&nbsp;pending<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;quint8&nbsp;intReg{0};&nbsp;\/\/&nbsp;Destination&nbsp;register&nbsp;index<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;quint64&nbsp;intValue{0};&nbsp;\/\/&nbsp;Result&nbsp;value<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;bool&nbsp;intClearDirty{false};&nbsp;\/\/&nbsp;Clear&nbsp;EBox&nbsp;scoreboard&nbsp;on&nbsp;commit<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;bool&nbsp;fpValid{false};&nbsp;\/\/&nbsp;FP&nbsp;result&nbsp;pending<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;quint8&nbsp;fpReg{0};&nbsp;\/\/&nbsp;Destination&nbsp;register&nbsp;index<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;quint64&nbsp;fpValue{0};&nbsp;\/\/&nbsp;Result&nbsp;value<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;bool&nbsp;fpClearDirty{false};&nbsp;\/\/&nbsp;Clear&nbsp;FBox&nbsp;scoreboard&nbsp;on&nbsp;commit<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">};<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">PendingCommit holds at most one integer result and one FP result. The intClearDirty\/fpClearDirty flags trigger scoreboard cleanup on commit — when the register file is written, the corresponding box\'s dirty bit is cleared, signaling that the register is no longer in-flight.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">K.2.2 Deferred Writeback Lifecycle<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Cycle&nbsp;N:<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;stage_EX&nbsp;executes&nbsp;instruction&nbsp;A&nbsp;→&nbsp;grain&nbsp;produces&nbsp;result<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;deferWriteback()&nbsp;captures&nbsp;result&nbsp;into&nbsp;m_pending<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;m_pending.intValid&nbsp;=&nbsp;true<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;m_pending.intReg&nbsp;=&nbsp;destReg<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;m_pending.intValue&nbsp;=&nbsp;slot.payLoad<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Cycle&nbsp;N+1:<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;commitPending()&nbsp;writes&nbsp;A\'s&nbsp;result&nbsp;→&nbsp;register&nbsp;file&nbsp;updated<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;m_intRegs-&gt;write(intReg,&nbsp;intValue)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;m_eBox-&gt;clearDirty(intReg)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;m_pending.intValid&nbsp;=&nbsp;false<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;stage_EX&nbsp;executes&nbsp;instruction&nbsp;B&nbsp;→&nbsp;reads&nbsp;correct&nbsp;value&nbsp;from&nbsp;A<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;deferWriteback()&nbsp;captures&nbsp;B\'s&nbsp;result&nbsp;into&nbsp;m_pending<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Critical ordering invariant:<\/strong> commitPending() runs at the top of stage_WB(), which executes before stage_EX() in the same cycle (reverse stage order: WB→MEM→EX→IS→DE→IF). This guarantees that the previous cycle\'s deferred result is visible in the register file before the current cycle\'s instruction reads registers. No forwarding logic is needed. No pipeline stalls for RAW hazards.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">K.2.3 Writeback Paths<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">deferWriteback() handles three distinct writeback paths:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Link register (BSR\/JSR)<\/strong> — Ra = PC + 4. The return address is computed from the slot\'s instruction PC and written to the link register.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Integer\/FP result<\/strong> — slot.payLoad written to the destination register identified by the decoded instruction. The destination type (integer vs FP) is determined by <span class=\"f_CodeExample\">destIsFloat(slot.di)<\/span>.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">No writeback<\/strong> — stores, branches (without link), barriers, and instructions writing to R31\/F31 produce no register result. deferWriteback() is a no-op for these.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">PAL instructions<\/strong> bypass the deferred writeback mechanism entirely. CALL_PAL is detected in stage_WB() before commitPrevious() would apply — the pending result from a younger instruction is discarded. PAL functions that modify registers do so directly through PalBox, which writes architectural state as part of the PAL function execution.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">K.3 The stage_WB() Retirement Sequence<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">stage_WB() executes a strict seven-step sequence. The ordering is architecturally significant — reordering any step would break correctness.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Step 0 — commitPending().<\/strong> Writes the deferred register result from the previous cycle to the architectural register file. This runs unconditionally, before the slot validity check. The pending result is from a different (older) instruction that already passed its own fault checks in EX. That instruction\'s result is architecturally valid regardless of what happens to the instruction currently in WB.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Step 1 — Slot validity check.<\/strong> If (!slot.valid), return. An empty slot produces no retirement.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Step 2 — Fault check (highest priority).<\/strong> If slot.faultPending is true: discard m_pending (the younger instruction in MEM is squashed — its deferred result must never reach the register file), set PipelineAction::FAULT with trapCode\/faultVA\/faultPC, invalidate the slot, return immediately. The fault propagates to AlphaCPU via BoxResult::faultDispatched(), which triggers enterPal().<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Step 3 — CALL_PAL check (before store commit).<\/strong> If isCallPal(slot.di): discard m_pending (pipeline serializes — all younger instructions will be flushed), compute PAL entry vector via <span class=\"f_CodeExample\">computeCallPalEntry(m_cpuId, palFunction)<\/span>, set PipelineAction::PAL_CALL with palFunction\/callPC\/palVector, invalidate the slot, return. AlphaCPU flushes the entire pipeline and enters PAL mode.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Step 4 — Store commit.<\/strong> If the instruction has store semantics (S_Store): <span class=\"f_CodeExample\">m_guestMemory→write64(slot.pa, slot.payLoad)<\/span>, then <span class=\"f_CodeExample\">m_reservationManager→breakReservationsOnCacheLine(slot.pa)<\/span>. This is the only point where store data reaches SafeMemory. Stores that faulted (Step 2) or were superseded by CALL_PAL (Step 3) never reach this step.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Step 5 — Branch predictor update.<\/strong> If slot.branchTaken: <span class=\"f_CodeExample\">m_cBox→updatePrediction(slot.di.pc, slot.branchTaken, slot.branchTarget)<\/span>. Predictor training occurs at retirement to ensure only committed branch outcomes update the predictor. Speculative branches that were flushed never train the predictor.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Step 6 — Retirement.<\/strong> commitInstruction(slot): increment m_instructionsRetired, update m_totalCycles, emit EXECTRACE_WB_RETIRE. This is the permanent record of the instruction\'s execution.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Step 7 — Cleanup.<\/strong> slot.valid = false, slot.clear(). The slot is recycled for the next instruction entering the pipeline.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">K.4 The Three Retirement Outcomes<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Every instruction that reaches stage_WB() with slot.valid = true produces exactly one of three outcomes. There is no fourth case.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Outcome<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">PipelineAction<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">PendingCommit<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Pipeline Effect<\/strong><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Fault<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">FAULT<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Discarded (younger squashed)<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Full flush, enter PAL at fault vector<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">PAL Transfer<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">PAL_CALL<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Discarded (pipeline serializes)<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Full flush, enter PAL at CALL_PAL vector<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Normal Commit<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">ADVANCE<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Committed (safe — older instruction passed)<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Store written, predictor trained, instruction retired<\/p>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">PendingCommit disposition is the critical distinction:<\/strong> On fault or PAL transfer, m_pending is discarded because it contains a result from a younger instruction that must be squashed. On normal commit, m_pending is safe to commit because the producing instruction already passed its own fault checks. The pending result and the retiring instruction are from different instructions — the pending is always one instruction older.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">K.5 Fault Handling at Retirement<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Faults are detected in stage_EX() but delivered in stage_WB(). The delay ensures all older instructions have retired before the fault is delivered (precise exception guarantee). The fault handling sequence at retirement:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1. slot.faultPending is true — set in stage_EX() when a box detected an exception (TLB miss, access violation, arithmetic trap, alignment fault, illegal instruction).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">2. m_pending is discarded. The pending result is from the instruction that was in EX when the faulting instruction was in MEM — one stage younger. That younger instruction\'s result must not reach the register file.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">3. PipelineAction::FAULT is set with three fields: trapCode (identifies the exception class — DTBM_SINGLE, ITB_MISS, DFAULT, ACCESS_VIOLATION, ARITH, ILLEGAL_INSTRUCTION, etc.), faultVA (the virtual address that triggered the fault, for TLB\/memory faults), faultPC (the PC of the faulting instruction, saved to EXC_ADDR for restart).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">4. The slot is invalidated. No store commit, no predictor update, no retirement counter increment.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">5. BoxResult::faultDispatched() propagates to AlphaCPU. AlphaCPU calls flushYoungerSlots() (discarding IF\/DE\/IS\/EX\/MEM), then enterPal() with the fault vector. EXC_ADDR is set to faultPC. PAL mode begins at the fault handler entry point.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Fault precedence:<\/strong> If multiple slots have faultPending set, the oldest instruction (lowest slotSequence) faults first. Because stage_WB() processes only the oldest slot each cycle, and fault delivery flushes all younger slots, at most one fault is delivered per cycle. Younger faulting instructions are discarded — their faults are artifacts of speculative execution past the true fault point.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Store isolation:<\/strong> The fault check (Step 2) executes before the store commit (Step 4). A faulting store instruction never writes to SafeMemory. A faulting load instruction\'s result never reaches the register file (its deferWriteback() populated m_pending, but the pending is discarded in the next cycle when the fault reaches WB). This two-phase isolation — stores blocked by step ordering, loads blocked by pending discard — is the mechanism that makes exceptions precise.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">K.6 PAL Instructions at Retirement<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">K.6.1 CALL_PAL<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">CALL_PAL is detected in stage_WB() after the fault check but before store commit. The retirement sequence for CALL_PAL:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1. m_pending is discarded. Any younger instruction\'s deferred result is squashed — CALL_PAL serializes the pipeline.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">2. The PAL function code is extracted from the instruction bits: <span class=\"f_CodeExample\">palFunction(slot.di.rawBits())<\/span>.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">3. The PAL entry vector is computed: <span class=\"f_CodeExample\">computeCallPalEntry(m_cpuId, palFunction)<\/span>. This uses PAL_BASE from the IPR storage and the architectural vector calculation: PAL_BASE[63:15] | function encoding | PAL mode bit. Privileged functions (0x00–0x3F) and unprivileged functions (0x80–0xBF) use different vector offsets.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">4. PipelineAction::PAL_CALL is set with palFunction, callPC (slot.di.pc), and palVector.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">5. The slot is invalidated. CALL_PAL is not &quot;retired&quot; in the normal sense — it does not increment m_instructionsRetired or emit EXECTRACE_WB_RETIRE. It is a control transfer, not a completed computation.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">6. AlphaCPU receives PAL_CALL, flushes the entire pipeline (flush()), and calls PalBox::enterPal() with PalEntryReason::CALL_PAL_INSTRUCTION. PalBox sets PC to the vector address (with bit 0 set for PAL mode), activates shadow registers, saves the return address (callPC + 4) to EXC_ADDR, and begins PAL execution.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Critical invariant:<\/strong> CALL_PAL is not a pending event. There is no &quot;pending PAL transfer&quot; flag that survives between steps. CALL_PAL is an instruction outcome handled immediately in stage_WB() — detection, vector computation, and action are atomic within the same step.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">K.6.2 HW_REI<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">HW_REI (Return from PAL) is the exit serialization point. When HW_REI retires in stage_WB():<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1. The pipeline is fully flushed — all slots invalidated, MBox staging cleared, pending commits discarded.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">2. PC is restored from EXC_ADDR (the return address saved on PAL entry).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">3. PAL mode is cleared — PC bit 0 is set to 0, restoring normal execution mode.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">4. LL\/SC reservations are cleared for the executing CPU.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">5. Shadow registers are deactivated — subsequent register references use the standard register file.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Together, CALL_PAL and HW_REI form a hard serialization boundary. No instruction from before the boundary survives into PAL mode, and no PAL-mode instruction survives into normal execution. Shadow register state, privileged IPR modifications, and PAL-mode memory access semantics are fully contained within the boundary.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">K.6.3 PAL Functions That Modify Registers<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">PAL functions (MFPR, MTPR, SWPCTX, etc.) modify architectural registers directly through PalBox, not through the deferred writeback mechanism. PalBox writes to the register file, IPR storage, and HWPCB as part of the PAL function execution. These writes occur within PAL mode and are not subject to pipeline speculation — PAL mode is fully serialized (one instruction at a time, no speculative execution). The deferred writeback mechanism (m_pending \/ commitPending \/ deferWriteback) is not used for any PAL register modification.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">K.7 Store Commit at Retirement<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Store data reaches SafeMemory only at retirement (Step 4 of stage_WB). The store commit sequence:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1. The instruction must have store semantics: <span class=\"f_CodeExample\">(slot.di.semantics &amp; S_Store)<\/span>.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">2. <span class=\"f_CodeExample\">m_guestMemory→write64(slot.pa, slot.payLoad)<\/span> writes the store data to the physical address computed during stage_EX(). This is an atomic write to SafeMemory.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">3. <span class=\"f_CodeExample\">m_reservationManager→breakReservationsOnCacheLine(slot.pa)<\/span> clears any LL\/SC reservations held by any CPU on the affected cache line. This ensures that a store between a LD_L and ST_C on another CPU will cause the ST_C to fail, preserving the atomicity contract.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Store ordering guarantee:<\/strong> Because only one instruction retires per cycle and retirement is in program order, stores are committed in program order. The memory model\'s weak ordering applies to visibility (when other CPUs see the store), not to the commit order. SafeMemory sees stores in strict program order; memory barriers (MB, WMB) control when those stores become globally visible.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Store-conditional (ST_C):<\/strong> ST_C checks the LL\/SC reservation before writing. If the reservation is invalid (broken by another CPU\'s store or by an intervening exception), ST_C writes 0 to the destination register (indicating failure) and does not write to SafeMemory. If the reservation is valid, ST_C writes to SafeMemory and writes 1 to the destination register (indicating success). The reservation check occurs in stage_EX(); the store commit at retirement is conditional on the check result.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">K.8 Retirement and Flush Interaction<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Pipeline flush discards all in-flight instructions. The interaction between flush and the deferred writeback mechanism is architecturally critical:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Flush on fault\/PAL:<\/strong> When stage_WB() detects a fault or CALL_PAL, it discards m_pending before returning. AlphaCPU then calls flush(), which clears all slots, clears MBox staging (clearMissStaging \/ clearIPRStaging), and resets the pipeline. The discarded pending result is from a younger instruction that would have been committed on the next cycle — discarding it ensures no speculative result survives the fault boundary.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Flush on misprediction:<\/strong> flushYoungerSlots() invalidates IF, DE, and IS. The EX and MEM slots are preserved — the mispredicting instruction in EX has already produced its result, and the instruction in MEM must still retire. m_pending is not discarded because it contains a valid result from the instruction currently in MEM.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Flush on interrupt:<\/strong> handleInterrupt() performs a full flush identical to the fault path. m_pending is discarded, all slots are cleared, and execution resumes at the interrupt vector in PAL mode.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Flush safety rule:<\/strong> commitPending() runs at the top of stage_WB(), before any flush decision is made. This ensures that the older instruction\'s deferred result is committed to the register file before the current cycle determines whether to flush. The committed result is architecturally valid — the producing instruction passed all checks. Even if the current WB instruction faults, the older instruction\'s result is correctly preserved.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">K.9 Retirement Invariants<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The following invariants hold for every retirement and are verified by the testing framework (Chapter 22):<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Single-instruction retirement.<\/strong> Exactly one instruction retires per cycle (or zero if WB slot is empty). Never two. This is guaranteed by the ring buffer — only one slot occupies the WB position at any time.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">In-order retirement.<\/strong> Instructions retire in strict program order. An instruction at slotSequence N always retires before slotSequence N+1. The ring buffer advancement and single-issue design enforce this without additional logic.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Fault-before-commit.<\/strong> The fault check (Step 2) always executes before the store commit (Step 4). A faulting instruction never writes to SafeMemory.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">PAL-before-commit.<\/strong> The CALL_PAL check (Step 3) always executes before the store commit (Step 4). CALL_PAL serializes without side effects.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Pending-from-older.<\/strong> The m_pending result committed by commitPending() (Step 0) is always from an instruction older than the instruction in WB. The producing instruction already passed its own fault and retirement checks.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">commitPending-before-EX.<\/strong> commitPending() runs before stage_EX() in every cycle (WB executes first in the reverse stage order). The register file is always current before any new instruction reads it.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">No speculative store.<\/strong> Store data never reaches SafeMemory until the instruction retires successfully in stage_WB(). A faulting or flushed store leaves no trace in SafeMemory.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Reservation break on store.<\/strong> Every store that commits to SafeMemory breaks LL\/SC reservations on the affected cache line. No store bypasses the reservation manager.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">SMP independence.<\/strong> Retirement is per-CPU. Each CPU retires its own instructions independently. Store visibility to other CPUs is governed by the memory model and barrier semantics, not by retirement order across CPUs.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"13_6-stage-implementations.html\" class=\"topiclink\">13.6.6 Stage Implementations<\/a> - stage_WB(); <a href=\"13_10-exception-precision.html\" class=\"topiclink\">13.10 Exception Precision<\/a> ; <a href=\"chapter-18---fault-dispatcher-.html\" class=\"topiclink\">Chapter 18 – Fault Dispatcher &amp; Precise Exceptions<\/a> ; <a href=\"chapter-20---boot-sequence_-pa.html\" class=\"topiclink\">Chapter 20 – Boot Sequence, PAL, and SRM Integration<\/a> (CALL_PAL\/HW_REI); <a href=\"chapter-11---architectural-inv.html\" class=\"topiclink\">Chapter 11 - Architectural Invariants<\/a> ; cpuCoreLib\/AlphaPipeline.h (stage_WB implementation).<\/span><\/p>\n\r"
})
