hmLoadTopic({
hmKeywords:"",
hmTitle:"4.4 IBox - Instruction Box",
hmDescription:"The IBox is the front-end intelligence of the processor. It is responsible for instruction fetch and decode, and nothing else. Once a grain is produced, IBox is no longer...",
hmPrevLink:"chapter-4_3-relationship-betwe.html",
hmNextLink:"chapter-4_5-ebox---execution-b.html",
hmParentLink:"chapter-4---functionexecution-.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-4---functionexecution-.html\">Chapter 4 - Functional Execution Domains (&quot;Boxes)<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 4 - Functional Execution Domains (\"Boxes) > 4.4 IBox - Instruction Box",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">4.4 IBox - Instruction Box<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">The IBox is the front-end intelligence of the processor. It is responsible for instruction fetch and decode, and nothing else. Once a grain is produced, IBox is no longer involved in that instruction\'s lifecycle.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">Responsibilities<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Instruction fetch coordination — reads the current PC, performs virtual-to-physical translation via the Ev6Translator, and fetches the 32-bit instruction word from GuestMemory<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Instruction decode — passes raw bits to GrainResolver::ResolveGrain() which extracts the opcode and function code, then looks up the cached grain in the InstructionGrainRegistry<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Decode cache management — maintains two levels of decode cache: PcDecodeCache (indexed by virtual PC, 64 entries) and PaDecodeCache (indexed by physical address, 64 entries). Cache hits bypass GuestMemory entirely.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>FetchResult generation — packages the DecodedInstruction, grain pointer, CALL_PAL detection, and prediction metadata into a FetchResult for pipeline consumption<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Branch target calculation — computes static branch targets for unconditional branches during fetch<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>CALL_PAL detection — identifies PAL instructions early and extracts the function code for PalBox routing<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">What IBox Does Not Do<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Does not execute instructions — all execution occurs in EX via Box dispatch<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Does not update registers — register writes are deferred to MEM\/WB<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Does not change PC architecturally — PC commit occurs only in WB<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Does not handle memory translation for data — data translation is MBox\'s responsibility<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Does not handle faults beyond signaling decode failures (ILLEGAL_INSTRUCTION)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">Implementation Detail<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">IBox is implemented as a final class (IBoxBase.h, 842 lines) with a two-phase fetch path: fetchNext() is the hot-path entry point that calls fetchAndDecode(). The fetch pipeline is: (1) try PC-based decode cache, (2) on miss try PA-based decode cache, (3) on miss fetch from GuestMemory, decode via GrainResolver, and populate both caches.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Dependencies: MBox (for instruction address translation), GuestMemory (physical memory fetch), GrainResolver (decode), CBox (branch prediction — not done in IBox directly).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Invariant: IBox never mutates architectural state.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-3_4-fetch-stage-(if).html\" class=\"topiclink\">3.4 Fetch Stage (IF)<\/a>; IBoxLib\/IBoxBase.h; grainFactoryLib\/GrainResolver.h.<\/span><\/p>\n\r"
})
