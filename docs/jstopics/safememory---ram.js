hmLoadTopic({
hmKeywords:"",
hmTitle:"SafeMemory - RAM",
hmDescription:"1. Scope and Responsibilities  **SafeMemory’s role**  * Provide a **safe, bounded, byte-addressable backing store** for guest *physical* memory. * Internally store data in a",
hmPrevLink:"",
hmNextLink:"",
hmParentLink:"appendix---trait-examples.html",
hmBreadCrumbs:"",
hmTitlePath:"Introduction > Appendix > Appendix I – Global Singletons",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">SafeMemory - RAM<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\"> 1. Scope and Responsibilities<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**SafeMemory’s role**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Provide a **safe, bounded, byte-addressable backing store** for guest *physical* memory.<\/p>\n\r<p class=\"p_Normal\">* Internally store data in a **QByteArray of fixed size N** (the configured RAM size).<\/p>\n\r<p class=\"p_Normal\">* Offer **inline helpers** for typed loads\/stores of 8\/16\/32\/64-bit values (and possibly 128-bit later).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Enforce:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Bounds checks (no read\/write outside [0, size)).<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Alignment rules (caller chooses policy; SafeMemory can enforce if requested).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Be **agnostic** with respect to:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* CPU count<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Regions (0–3) and their caching policies<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* PALcode and MB\/WMB\/TRAPB<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* TLB \/ SPAM \/ PTEs<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* MMIO \/ devices<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Out of scope (handled above SafeMemory)**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Virtual address translation (VA → PA).<\/p>\n\r<p class=\"p_Normal\"> &nbsp;→ Implemented by TLB \/ PTESPAM \/ PTE logic.<\/p>\n\r<p class=\"p_Normal\">* Region policies (cacheability, write-back vs write-through vs uncached).<\/p>\n\r<p class=\"p_Normal\"> &nbsp;→ Implemented by AlphaMemorySystem \/ MemoryFacade using physical address + region tables (ASA memory regions).<\/p>\n\r<p class=\"p_Normal\">* Memory ordering and coherency semantics (MB, WMB, TRAPB).<\/p>\n\r<p class=\"p_Normal\"> &nbsp;→ Implemented by AlphaCPU \/ ControlExecutor using barriers and reservation logic.<\/p>\n\r<p class=\"p_Normal\">* MMIO dispatch and device side effects.<\/p>\n\r<p class=\"p_Normal\"> &nbsp;→ AlphaMemorySystem decides “this PA is MMIO” and routes to MMIOManager instead of calling SafeMemory.<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> 2. Class Identity and Lifetime<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Type**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* `class SafeMemory final`<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Final to emphasize it is a concrete primitive, not a polymorphic base.<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Non-copyable (copy would imply duplicating guest RAM, which is not intended).<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Movable optional (but typically created once and held by EmulatorManager \/ AlphaMemorySystem).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Ownership**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Owned by a higher-level component, e.g.:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `AlphaMemorySystem`, `MemoryFacade`. or a QGlobalStatic<\/p>\n\r<p class=\"p_Normal\">* Constructed early in emulator initialization, before CPUs start.<\/p>\n\r<p class=\"p_Normal\">* Destroyed when emulator shuts down or snapshot\/restore manager resets the memory.<\/p>\n\r<p class=\"p_Normal\">* SafeMemory should provide a one-time initialization function which initializes the RAM size for the life of the class. Memory is initialized scaled as gigabytes of memory. &nbsp;::initializeMemory(32); \/\/ is 32 GigaBytes of memory. &nbsp;This is the maximum we will support at this time. &nbsp; A MAX_RAM_SIZE will be defined in the SafeMemory_core_inl.h helper that will load for SafeMemory operations. <\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Lifetime guarantees**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* After initialization, the size is fixed (no reallocations) for the “normal” lifetime.<\/p>\n\r<p class=\"p_Normal\">* If resizes are allowed at all (optional), they are:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Rare administrative actions.<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Performed with global synchronization at a higher layer (quiesce CPUs, etc.).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> 3. Internal Data Model<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Storage**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* One **QByteArray m_bytes**:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Length = configured RAM size (N bytes).<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Represents guest *physical* addresses 0 .. N-1.<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Indexed directly by guest physical offset (PA) once AlphaMemorySystem has mapped PA into this RAM.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Metadata**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* `quint64 m_sizeBytes`:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* The total number of bytes of RAM exposed through this SafeMemory instance.<\/p>\n\r<p class=\"p_Normal\">* Optional:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* A lightweight **mutex** for admin operations (resize, clear, snapshot), but *not* for every single load\/store.<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* A debug flag or structure for tracing (e.g., enable\/disable access logging), controlled by higher layers.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**No region information**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* SafeMemory does **not** track Region 0\/1\/2\/3 or MMIO windows.<\/p>\n\r<p class=\"p_Normal\">* It accepts *only* offsets that AlphaMemorySystem has already validated as “this is RAM”.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> 4. Public API – Conceptual<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">All methods are expected to be **inline** for performance. No code here, just signatures and semantics.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"># 4.1 Initialization<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* `bool initialize(quint64 sizeBytes);`<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Allocates `m_bytes` to `sizeBytes` and zero-fills.<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Returns false if allocation fails (out-of-memory).<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Called once at startup (or during configuration change) before CPUs run.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* `quint64 size() const;`<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Returns `m_sizeBytes`.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"># 4.2 Raw access (for snapshot \/ DMA copying)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* `quint8* data();`<\/p>\n\r<p class=\"p_Normal\">* `const quint8* data() const;`<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Semantics:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* These return direct pointers into the internal buffer.<\/p>\n\r<p class=\"p_Normal\">* Intended for **bulk operations** only (snapshots, diagnostic dumps, offline copy).<\/p>\n\r<p class=\"p_Normal\">* Callers must **not** use these for normal CPU load\/store paths.<\/p>\n\r<p class=\"p_Normal\">* Callers must manage concurrency externally if multiple CPUs or devices might use this pointer.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"># 4.3 Typed loads and stores<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Provide a small set of canonical helpers:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* `Status load8(quint64 paddr, quint8&amp; out) const;`<\/p>\n\r<p class=\"p_Normal\">* `Status load16(quint64 paddr, quint16&amp; out) const;`<\/p>\n\r<p class=\"p_Normal\">* `Status load32(quint64 paddr, quint32&amp; out) const;`<\/p>\n\r<p class=\"p_Normal\">* `Status load64(quint64 paddr, quint64&amp; out) const;`<\/p>\n\r<p class=\"p_Normal\">* `Status store8(quint64 paddr, quint8 value);`<\/p>\n\r<p class=\"p_Normal\">* `Status store16(quint64 paddr, quint16 value);`<\/p>\n\r<p class=\"p_Normal\">* `Status store32(quint64 paddr, quint32 value);`<\/p>\n\r<p class=\"p_Normal\">* `Status store64(quint64 paddr, quint64 value);`<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Endianness:**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Alpha physical memory is **little-endian**.<\/p>\n\r<p class=\"p_Normal\">* Helpers interpret and assemble\/disassemble multi-byte values accordingly.<\/p>\n\r<p class=\"p_Normal\">* Higher-level code (e.g., VAX emulation) deals with alternate byte orders as needed.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Alignment behavior:**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* SafeMemory can be configured with one of two policies (decided at design time):<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;1. **Strict alignment mode**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; * Enforces natural alignment for 16\/32\/64-bit accesses.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; * Returns `Misaligned` status if `paddr` is not aligned.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; * Higher layers map `Misaligned` → Alpha alignment trap (PAL\/OS defined behavior).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;2. **Tolerant mode (optional)**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; * Implements misaligned access by performing multiple byte\/word loads\/stores.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; * This is *not* architecturally correct unless PAL\/OS expects emulation above.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; * Recommended only if you explicitly want to emulate OS misalignment fixup.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Reference: Alpha Architecture Reference Manual, load\/store instruction descriptions and alignment rules.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Bounds behavior:**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* If `paddr + access_size &gt; m_sizeBytes`, return `OutOfRange`.<\/p>\n\r<p class=\"p_Normal\">* Higher layers map `OutOfRange` to:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Access violation \/ machine check, depending on the use-case.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> 5. Status and Error Model<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Define a small enum `Status` returned by all typed operations:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* `Ok` — operation succeeded, value is valid.<\/p>\n\r<p class=\"p_Normal\">* `OutOfRange` — physical address + size is outside RAM bounds.<\/p>\n\r<p class=\"p_Normal\">* `Misaligned` — address violates alignment rules in strict mode.<\/p>\n\r<p class=\"p_Normal\">* Optional extension:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* `Unmapped` — reserved for future if SafeMemory is ever used for sparse mapping.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Higher layers (AlphaMemorySystem\/AlphaCPU) interpret these:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* `Ok` → normal execution.<\/p>\n\r<p class=\"p_Normal\">* `OutOfRange` or `Unmapped` → physical address error → likely machine check or access violation.<\/p>\n\r<p class=\"p_Normal\">* `Misaligned` → alignment fault → PAL or OS may emulate or signal SIGBUS-like condition.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SafeMemory **does not throw exceptions** for these conditions; all error conditions are expected and represented by `Status`.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> 6. Concurrency and SMP Considerations<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Assumptions**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Multiple CPUs (threads) can access SafeMemory concurrently.<\/p>\n\r<p class=\"p_Normal\">* SafeMemory must not be a bottleneck but must maintain functional correctness.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Concurrency model**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Standard aligned loads\/stores of POD types are treated as **host-atomic** at the granularity of the type, assuming the host platform guarantees atomic aligned loads\/stores of 64-bit values (true on x86-64).<\/p>\n\r<p class=\"p_Normal\">* SafeMemory does **not** implement its own caching or coherency; it simply reflects writes into the single backing array.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Memory ordering**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* SafeMemory does *not* implement memory fences or barriers.<\/p>\n\r<p class=\"p_Normal\">* Emulated instructions `MB`, `WMB`, `TRAPB`, etc., are modeled in higher layers:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* AlphaCPU \/ ControlExecutor will perform appropriate host memory fences (e.g., std::atomic_thread_fence) and enforce ordering semantics.<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* SafeMemory just provides consistent storage.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Administrative operations**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Rare operations like `initialize()` or `resize()` (if allowed) should be protected by **internal mutex** or performed only when CPUs are not running.<\/p>\n\r<p class=\"p_Normal\">* In many designs, RAM size is immutable during runtime → no dynamic resize needed → minimal need for locking.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> 7. Relationship to Regions and Regions’ Policies<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Even though ASA defines Region 0–3 with different caching\/coherency rules, **SafeMemory itself is region-agnostic**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**How regions are applied:**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* AlphaMemorySystem (or similar) knows:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* For a given PA, which **region** it falls into.<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Whether the region:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;* Allows byte\/word\/longword\/quadword accesses.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;* Is write-back, write-through, or uncached.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;* Has any special atomicity\/ordering rules.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* AlphaMemorySystem checks:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Region’s allowed access size.<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Region’s alignment requirements.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Only after those rules pass does it call SafeMemory’s typed load\/store.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">So the layering is:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1. **CPU\/VM subsystem**: VA → PA (via PTESPAM, TLB, etc.).<\/p>\n\r<p class=\"p_Normal\">2. **AlphaMemorySystem**:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * Determine region (0–3).<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * Apply region policies (caching\/atomicity\/access-size semantics).<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * Decide RAM vs MMIO vs ROM.<\/p>\n\r<p class=\"p_Normal\">3. **SafeMemory**:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; * If this PA is mapped to RAM, perform the actual byte operation.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> 8. Interaction with Reservations (LDx_L \/ STx_C)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Reservations and “coherency points” are explicitly **not SafeMemory’s job**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Each CPU has reservation state:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Reserved PA (the address of the last LDx_L).<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* A token or version (for STx_C success\/failure).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* A separate **ReservationManager** (or per-CPU state) monitors writes:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* When STx_C is attempted, it checks that:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;* The PA matches the reserved address.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;* No conflicting write has occurred since reservation.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* SafeMemory:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Just performs the actual store when requested.<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Does not know about reservations, tokens, or STx_C.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This matches the architecture described in the ASA and leaves SafeMemory purely as a storage primitive.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> 9. Planned QObject Wrapper (High-Level)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Later, you can wrap `SafeMemory` in a QObject-based class:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* `class SafeMemoryAdapter : public QObject`<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Holds a `SafeMemory` instance.<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Exposes slots for administrative operations (`initialize`, `snapshot`, `clear`, etc.).<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Emits signals for high-level events (e.g., `memoryResized`, `snapshotCompleted`).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Important:<\/p>\n\r<p class=\"p_Normal\">This wrapper **does not** sit on the hot path for per-instruction loads\/stores:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Normal CPU memory accesses go directly through `SafeMemory` (or via AlphaMemorySystem which holds a pointer\/reference to it).<\/p>\n\r<p class=\"p_Normal\">* QObject wrapper is only for configuration\/UI\/instrumentation.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> 10. Summary of Design Decisions<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* **SafeMemory is final, header-only, and minimal.**<\/p>\n\r<p class=\"p_Normal\">* It stores RAM in a **QByteArray**; no awareness of regions, MMIO, or PAL.<\/p>\n\r<p class=\"p_Normal\">* It provides **inline typed load\/store helpers** with:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Bounds checks.<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Optional strict alignment enforcement.<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Little-endian assembly\/disassembly.<\/p>\n\r<p class=\"p_Normal\">* It returns a small **Status** code instead of throwing.<\/p>\n\r<p class=\"p_Normal\">* **Arbitration, regions, reservations, and PAL interfaces** are:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Implemented in AlphaMemorySystem, ReservationManager, and AlphaCPU.<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Represented as *side-effect helpers above SafeMemory*.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r"
})
