hmLoadTopic({
hmKeywords:"BEQ,BR,Branch,BranchPredictor,branchTaken,branchTarget,BSR,CBox,Conditional,COROUTINE,EX,execute,Fetch,Flush,flushPipeline,flushYoungerSlots,Grain,IBox,IF,JMP,JSR,Jump,Misprediction,nextPC,PC,pcReason,predictionTarget,predictionValid,predTaken,predTarget,queryPrediction,recordBranchResolution,Resolution,RET,Retirement,Speculative,stage_EX,stage_IF,stage_WB,Unconditional,updatePrediction,WB",
hmTitle:"13.11 Branch Handling",
hmDescription:"13.11.1 Prediction at Fetch  IBox predicts the branch target during fetch. For each decoded branch, IBox calls CBox::queryPrediction(branchPC, outPredictedTarget) and stores the",
hmPrevLink:"13_10-exception-precision.html",
hmNextLink:"13_12-ll_sc-and-determinism.html",
hmParentLink:"alphapipeline-implementation.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"alphapipeline-implementation.html\">Chapter 13 – AlphaPipeline Implementation<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 13 – AlphaPipeline Implementation > 13.11 Branch Handling",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">13.11 Branch Handling<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.11.1 Prediction at Fetch<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">IBox predicts the branch target during fetch. For each decoded branch, IBox calls <span class=\"f_CodeExample\">CBox::queryPrediction(branchPC, outPredictedTarget)<\/span> and stores the result in slot.predTaken, slot.predTarget, slot.predictionTarget, and slot.predictionValid. If the predictor returns taken with a valid target, IBox speculatively fetches from the predicted target. Otherwise, IBox fetches sequentially from PC+4.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Unconditional branches (BR, BSR) have their target known at decode — prediction is always correct. Conditional branches (BEQ, BNE, BGT, BLE, etc.) rely on the CBox branch predictor. Register-indirect jumps (JMP, JSR, RET, COROUTINE) use the Branch Target Buffer for the last known target.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.11.2 Resolution in EX<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Branches are resolved in stage_EX(). The grain evaluates the actual branch condition and sets slot.branchTaken and slot.branchTarget. The pipeline then compares the actual outcome against the prediction:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Correct prediction:<\/strong> slot.branchTaken matches the predicted direction and slot.branchTarget matches slot.predictionTarget. No pipeline disruption — speculatively fetched instructions continue flowing normally. This is the common case.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Misprediction:<\/strong> actual outcome differs from prediction (wrong direction or wrong target). slot.flushPipeline is set to true. The execute() method detects this after stage_EX() and calls flushYoungerSlots() — stages IF, DE, and IS are invalidated. The corrected PC (slot.branchTarget for taken, slot.nextPC for not-taken) is used for the next fetch cycle. Misprediction cost is the depth of the invalidated pipeline stages (up to 3 cycles of wasted work).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.11.3 Predictor Training in WB<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Branch predictor tables are updated at retirement in stage_WB() via <span class=\"f_CodeExample\">CBox::recordBranchResolution(pc, actualTarget, wasTaken, wasPredicted, predictedCorrectly)<\/span>. Training occurs for every branch — correct and mispredicted alike — so the predictor learns from all outcomes. Training at WB (not EX) ensures that only architecturally committed branch outcomes update the predictor; speculative branches that are flushed never corrupt predictor state.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.11.4 PC Contract<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The architectural PC is updated only in WB via retirement — no earlier stage modifies the committed PC. During speculative execution, IBox maintains a speculative fetch PC that advances ahead of the architectural PC. On misprediction, the speculative PC is corrected to the resolved target, but the architectural PC remains unchanged until the correcting instruction retires.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: Section 3.9 – Branch Resolution; <a href=\"appendixb-branchpredictionmechanics.html\" class=\"topiclink\">Appendix J - Branch Prediction Mechanics<\/a> (predictor structures, strategies, hit rates, and CBox interface).<\/span><\/p>\n\r"
})
