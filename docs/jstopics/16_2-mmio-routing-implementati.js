hmLoadTopic({
hmKeywords:"",
hmTitle:"16.2 MMIO Routing Implementation",
hmDescription:"16.2.1 Routing Path: VA to Device Handler  When a guest load or store instruction targets a device register, the access follows a multi-stage routing path:  Guest Instruction (",
hmPrevLink:"16_1-device-differentiation-an.html",
hmNextLink:"16_3-endianness-and-device-reg.html",
hmParentLink:"chapter-16---device-model--dma.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-16---device-model--dma.html\">Chapter 16 – Device Model &amp; DMA<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 16 – Device Model & DMA > 16.2 MMIO Routing Implementation",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">16.2 MMIO Routing Implementation<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">16.2.1 Routing Path: VA to Device Handler<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">When a guest load or store instruction targets a device register, the access follows a multi-stage routing path:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Guest&nbsp;Instruction&nbsp;(LDQ\/STQ&nbsp;at&nbsp;VA)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;▼<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">MBox:&nbsp;VA&nbsp;→&nbsp;PA&nbsp;Translation&nbsp;(Ev6SiliconTLB)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;▼<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">GuestMemory::findRoute(PA)&nbsp;→&nbsp;RouteTarget::MMIOManager<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;▼<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">MMIOManager::handleRead\/handleWrite(PA,&nbsp;width)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;▼<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Region&nbsp;lookup&nbsp;→&nbsp;RegionDescriptor&nbsp;match<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;▼<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">PA&nbsp;→&nbsp;BAR-relative&nbsp;offset&nbsp;conversion<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;▼<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Device&nbsp;handler:&nbsp;ReadFn(ctx,&nbsp;offset,&nbsp;width)&nbsp;\/&nbsp;WriteFn(ctx,&nbsp;offset,&nbsp;value,&nbsp;width)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;▼<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">MMIOStatus&nbsp;returned&nbsp;to&nbsp;memory&nbsp;system<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The critical routing decision occurs at <span class=\"f_CodeExample\">GuestMemory::findRoute()<\/span>. When the PA falls within the MMIO aperture (default <span class=\"f_CodeExample\">0x10_0000_0000<\/span> – <span class=\"f_CodeExample\">0x20_0000_0000<\/span>, 64 GB), GuestMemory dispatches to <span class=\"f_CodeExample\">MMIOManager<\/span> rather than <span class=\"f_CodeExample\">SafeMemory<\/span>. This routing is established at initialization via the PA routing table (see 15.3) and is immutable at runtime.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">16.2.2 MMIOManager Region Table<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">MMIOManager<\/span> (<span class=\"f_CodeExample\">mmio_Manager.h<\/span>, 114 lines) maintains a flat table of registered MMIO regions. Each region is described by a <span class=\"f_CodeExample\">RegionDescriptor<\/span>:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">struct&nbsp;RegionDescriptor&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;quint64&nbsp;basePA;&nbsp;\/\/&nbsp;Start&nbsp;physical&nbsp;address<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;quint64&nbsp;sizeBytes;&nbsp;\/\/&nbsp;Region&nbsp;size<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;quint32&nbsp;flags;&nbsp;\/\/&nbsp;RegionFlags&nbsp;(access&nbsp;policy)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;quint32&nbsp;deviceUid;&nbsp;\/\/&nbsp;Owning&nbsp;device&nbsp;UID<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;quint32&nbsp;hoseId;&nbsp;\/\/&nbsp;PCI&nbsp;hose&nbsp;(interrupt&nbsp;domain)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">};<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">RegionFlags<\/span> encode per-region access policy: <span class=\"f_CodeExample\">WIDTH_8<\/span>, <span class=\"f_CodeExample\">WIDTH_16<\/span>, <span class=\"f_CodeExample\">WIDTH_32<\/span>, <span class=\"f_CodeExample\">WIDTH_64<\/span> (allowed access widths), <span class=\"f_CodeExample\">REQUIRE_NATURAL_ALIGNMENT<\/span> or <span class=\"f_CodeExample\">ALLOW_UNALIGNED<\/span>, and <span class=\"f_CodeExample\">HAS_SIDE_EFFECTS<\/span>. When an access arrives, MMIOManager performs a linear scan of the region table, matches the PA to a region, validates the access width against the region\'s allowed widths, converts the PA to a BAR-relative offset via <span class=\"f_CodeExample\">offset = PA - region.basePA<\/span>, and dispatches to the device handler via function pointer.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Handler registration uses raw function pointers for maximum dispatch performance:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">typedef&nbsp;quint64&nbsp;(*ReadFn)(void*&nbsp;ctx,&nbsp;quint64&nbsp;offset,&nbsp;quint8&nbsp;width)&nbsp;noexcept;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">typedef&nbsp;void&nbsp;(*WriteFn)(void*&nbsp;ctx,&nbsp;quint64&nbsp;offset,&nbsp;quint64&nbsp;value,&nbsp;quint8&nbsp;width)&nbsp;noexcept;<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">After all regions are registered during initialization, <span class=\"f_CodeExample\">finalize()<\/span> locks the region table for runtime. No regions can be added or removed after finalization. This guarantees that the dispatch path is read-only during execution, eliminating synchronization overhead on the hot path.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">16.2.3 MMIO Write Buffer Bypass<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">MMIO writes bypass the <span class=\"f_CodeExample\">WriteBufferManager<\/span> entirely. When MBox detects that the target PA routes to <span class=\"f_CodeExample\">RouteTarget::MMIOManager<\/span>, it commits the write synchronously through GuestMemory → MMIOManager → device handler. The write is never queued in the CPU\'s write buffer. This ensures the strong ordering guarantee: every MMIO write is visible to the device at the point of execution, with no deferred commit.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">MMIO reads similarly bypass speculation — the pipeline may stall for the duration of the MMIO access, and the result is available immediately upon return from the device handler.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: mmioLib\/mmio_Manager.h (~114 lines) – MMIOManager class; <a href=\"15_3-guestmemory-region-suppor.html\" class=\"topiclink\">15.3 GuestMemory Region Support and PA Routing<\/a> ; <a href=\"15_7-mmio-access-semantics.html\" class=\"topiclink\">15.7 MMIO Access Semantics<\/a>.<\/span><\/p>\n\r"
})
