hmLoadTopic({
hmKeywords:"",
hmTitle:"5.8 Loads and Stores",
hmDescription:"5.8.1 Load Semantics  Loads execute synchronously in the EX stage. MBox performs address calculation, alignment checking, VA→PA translation via Ev6Translator, and then reads...",
hmPrevLink:"chapter-5_7-mmio-regions.html",
hmNextLink:"chapter-5_9-write-buffers.html",
hmParentLink:"chapter-5---memory-system-arch.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-5---memory-system-arch.html\">Chapter 5 - Memory System Architecture<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 5 - Memory System Architecture > 5.8 Loads and Stores",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">5.8 Loads and Stores<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">5.8.1 Load Semantics<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Loads execute synchronously in the EX stage. MBox performs address calculation, alignment checking, VA→PA translation via Ev6Translator, and then reads from GuestMemory. The data is placed immediately into slot.payLoad and marked for writeback (slot.needsWriteback = true). The register file update occurs via the deferred writeback path in MEM stage.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Loads do not stall by default, do not imply ordering, and do not serialize execution. They advance normally through the pipeline.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">5.8.2 Store Semantics<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Stores follow a two-phase model:<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">1.<\/span>EX stage — MBox computes the effective address, performs alignment checks and VA→PA translation, and places the address (slot.va, slot.pa) and data (slot.payLoad) into the pipeline slot. The store is not yet visible.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 1.2500rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"display:inline-block;width:1.2500rem;margin-left:-1.2500rem\">2.<\/span>WB stage — the pipeline commits the store by calling m_guestMemory-&gt;write64(slot.pa, slot.payLoad), then breaks LL\/SC reservations on the affected cache line via m_reservationManager-&gt;breakReservationsOnCacheLine(slot.pa).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Between EX and WB, the store data may enter a write buffer managed by CBox. Stores in the write buffer are not guaranteed to be visible to other CPUs, devices, or subsequent loads unless a barrier is used.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Stores may be reordered relative to other stores (in the write buffer) and relative to loads. This is the Alpha AXP weak ordering model. Only MB and WMB barriers enforce store visibility.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-5_9-write-buffers.html\" class=\"topiclink\">5.9 Write Buffers<\/a>; <a href=\"5_10-memory-barriers-(preview).html\" class=\"topiclink\">5.10 Memory Barriers (preview)<\/a>; <a href=\"chapter-4_7---mbox---memory-bo.html\" class=\"topiclink\">4.7 MBox - Memory Box<\/a>.<\/span><\/p>\n\r"
})
