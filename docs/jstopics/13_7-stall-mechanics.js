hmLoadTopic({
hmKeywords:"Backpressure,Barrier,BoxResult,Bubble,CBox,Completion,Device,Drain,EX,EXCB,execute,FloatingPoint,ForwardProgress,Freeze,isPipelineStalled,MB,MEM,memoryBarrierCompleted,MemoryBarrierCoordinator,MultiCycle,needsMemoryBarrier,needsWriteBufferDrain,Pipeline,Propagation,Retry,RingBuffer,Serialization,Stall,stalled,stallPipeline,tick,TLBMiss,TRAPB,WMB,WriteBuffer,writeBufferDrained",
hmTitle:"13.7 Stall Mechanics",
hmDescription:"13.7.1 Stall Conditions  A PipelineSlot may stall (slot.stalled = true) under the following conditions:  Memory barrier pending — needsMemoryBarrier && !memoryBarrierCompleted.",
hmPrevLink:"13_6-stage-implementations.html",
hmNextLink:"13_8-flush-semantics.html",
hmParentLink:"alphapipeline-implementation.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"alphapipeline-implementation.html\">Chapter 13 – AlphaPipeline Implementation<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 13 – AlphaPipeline Implementation > 13.7 Stall Mechanics",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">13.7 Stall Mechanics<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.7.1 Stall Conditions<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">A PipelineSlot may stall (slot.stalled = true) under the following conditions:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Memory barrier pending<\/strong> — needsMemoryBarrier &amp;&amp; !memoryBarrierCompleted. Detected in stage_MEM(). The slot holds in MEM until CBox signals completion via MemoryBarrierCoordinator. Applies to MB (global visibility) and EXCB (pending exception resolution).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Write buffer drain pending<\/strong> — needsWriteBufferDrain &amp;&amp; !writeBufferDrained. Detected in stage_MEM(). The slot holds in MEM until the write buffer confirms all prior stores are committed. Applies to WMB (local write ordering).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Multi-cycle FP execution<\/strong> — the grain blocks the slot in stage_EX() until the floating-point operation completes. The slot remains in EX for the duration of the operation; stage_EX() re-evaluates completion on each tick.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">TRAPB\/EXCB serialization<\/strong> — the instruction must wait for all prior instructions that may generate traps or exceptions to complete before proceeding. Enforced through the barrier stall mechanism in stage_MEM().<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Device backpressure<\/strong> — an MMIO access to a device that cannot accept the operation immediately. The slot stalls in EX until the device signals readiness.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.7.2 Stall Detection and Enforcement<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Stalls are detected at two stages: stage_EX() detects multi-cycle operation stalls and device backpressure. stage_MEM() detects barrier and write-buffer-drain stalls. In both cases, the detecting stage sets slot.stalled = true and returns without advancing the slot.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Stall clearing:<\/strong> The stall condition is re-evaluated on every subsequent tick. For barrier stalls, CBox sets memoryBarrierCompleted = true via the MemoryBarrierCoordinator when the barrier is satisfied. For write buffer drains, CBox sets writeBufferDrained = true when all prior stores are flushed. For multi-cycle FP, the FBox signals completion and the grain updates the slot. The clearing agent is always the subsystem that owns the completion condition — never the pipeline itself.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Critical detail:<\/strong> When a barrier stall clears in stage_MEM(), the grain does not re-execute. Execution already completed in stage_EX() on a prior tick — the result sits in slot.payLoad and slot.m_pending. The stall only delayed the register writeback (commitPending) and progression to WB. On clearing, stage_MEM() performs commitPending() normally and the slot advances to WB on the next tick.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.7.3 Stall Propagation<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Stalls propagate forward only (toward younger instructions). If stage N stalls, stage N−1 cannot advance, and all earlier stages remain frozen. Later stages (toward WB) continue draining. This guarantees forward progress — older instructions always retire before younger ones can proceed.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Bubbles vs stalls:<\/strong> A bubble is an empty slot (slot.valid = false) flowing through the pipeline — it occupies a position but performs no work. A stall is a live slot frozen in place — it contains a valid instruction that cannot advance. Bubbles pass through harmlessly. Stalls block all upstream stages until the stall condition clears.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The stall is checked in execute() after all stages run: if isPipelineStalled() returns true, the ring buffer does not advance (advanceRing() is skipped), and BoxResult::stallPipeline() is returned to AlphaCPU. The stalled stage will be re-evaluated on the next tick.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: Section 6.5 – Pipeline Behavior (barrier stalls); <a href=\"chapter-15---memory-system-imp.html\" class=\"topiclink\">Chapter 15 – Memory System Implementation Details<\/a> (MemoryBarrierCoordinator).<\/span><\/p>\n\r"
})
