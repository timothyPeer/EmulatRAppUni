hmLoadTopic({
hmKeywords:"",
hmTitle:"22.6 PAL and Privilege Boundary Validation",
hmDescription:"PAL validation ensures that the privileged boundary is absolute and that no violation escapes detection.",
hmPrevLink:"22_5-memory-ordering-and-ll_sc.html",
hmNextLink:"22_7-device-and-dma-validation.html",
hmParentLink:"chapter-22---testing_-validati.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-22---testing_-validati.html\">Chapter 22 – Testing, Validation, and Architectural Compliance<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 22 – Testing, Validation, and Architectural Compliance > 22.6 PAL and Privilege Boundary Validation",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">22.6 PAL and Privilege Boundary Validation<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">PAL validation ensures that the privileged boundary is absolute and that no violation escapes detection.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Positive tests<\/span> (correct behavior verified): CALL_PAL from kernel mode enters PAL correctly, CALL_PAL from user mode (unprivileged functions 0x80–0xBF) enters PAL correctly, HW_REI restores context exactly (full register comparison), pipeline serialization occurs on PAL entry (no speculative instruction survives), shadow registers are active during PAL execution and inactive after HW_REI, and IPL = 7\/CM = KERNEL on entry for all PalEntryReason values.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Negative tests<\/span> (violations detected correctly): privileged instruction (HW_MFPR, HW_MTPR, HW_LD, HW_ST, HW_REI) executed outside PAL mode must trap with OPCDEC, privileged CALL_PAL (0x00–0x3F) from user mode must trap, direct jump to a PAL address must trap, manual modification of PAL mode bits must fail, and HW_REI outside PAL mode must trap. All violations must produce precise, architecturally correct exceptions.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Serialization tests:<\/span> CALL_PAL drains write buffers (stores before CALL_PAL visible after PAL entry), LL\/SC reservations cleared on PAL entry and HW_REI exit, no speculative instruction crosses the PAL boundary in either direction.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-8---pal-and-privleged-.html\" class=\"topiclink\">Chapter 8 - PAL and Privileged Boundary<\/a> ; <a href=\"chapter-20---boot-sequence_-pa.html\" class=\"topiclink\">Chapter 20 – Boot Sequence, PAL, and SRM Integration<\/a> (implementation under test).<\/span><\/p>\n\r"
})
