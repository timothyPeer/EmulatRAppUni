hmLoadTopic({
hmKeywords:"",
hmTitle:"12.5 The AlphaCPU Run Loop",
hmDescription:"12.5.1 executeLoop()  The run loop (executeLoop() in AlphaCPU.cpp) is the clocked execution engine. Each iteration represents one hardware cycle. The loop structure:  void Alph",
hmPrevLink:"12_4-cpu-lifecycle.html",
hmNextLink:"12_6-pipeline-integration.html",
hmParentLink:"alphacpu-core.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"alphacpu-core.html\">Chapter 12 – AlphaCPU Core<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 12 – AlphaCPU Core > 12.5 The AlphaCPU Run Loop",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">12.5 The AlphaCPU Run Loop<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">12.5.1 executeLoop()<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The run loop (executeLoop() in AlphaCPU.cpp) is the clocked execution engine. Each iteration represents one hardware cycle. The loop structure:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">void&nbsp;AlphaCPU::executeLoop()&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;m_running.store(true);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;m_alphaPipeline-&gt;injectOtherBoxes(m_eBox,&nbsp;m_fBox,&nbsp;m_mBox,&nbsp;m_pBox,&nbsp;m_cBox);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;while&nbsp;(!m_stopRequested.load())&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;if&nbsp;(m_paused.load())&nbsp;{&nbsp;QThread::msleep(1);&nbsp;continue;&nbsp;}<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;if&nbsp;(m_halted.load())&nbsp;{&nbsp;QThread::msleep(10);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;if&nbsp;(checkForWakeup())&nbsp;m_halted.store(false);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;continue;&nbsp;}<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;runOneInstruction();&nbsp;\/\/&nbsp;HOT&nbsp;PATH<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;++m_localInstrCount;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;}<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;shutdownGracefully();<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;m_running.store(false);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">}<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Thread control uses three atomic flags: m_stopRequested (external shutdown), m_paused (pause\/resume), m_halted (HALT instruction, wakes on interrupt). The halted state sleeps for 10ms between wakeup checks; the paused state sleeps for 1ms.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">12.5.2 runOneInstruction()<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The hot-path method that executes one complete instruction cycle:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">void&nbsp;runOneInstruction()&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;1.&nbsp;Check&nbsp;for&nbsp;external&nbsp;events&nbsp;(interrupts)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;if&nbsp;(m_pending-&gt;hasDeliverable(currentIPL))&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;handleInterrupt();<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;return;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;}<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;2.&nbsp;Fetch&nbsp;and&nbsp;decode<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;FetchResult&nbsp;fetchResult&nbsp;=&nbsp;m_iBox-&gt;fetchNext();<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;3.&nbsp;Supply&nbsp;to&nbsp;pipeline<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;BoxResult&nbsp;boxResult&nbsp;=&nbsp;m_alphaPipeline-&gt;tick(fetchResult);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;4.&nbsp;Handle&nbsp;BoxResult&nbsp;flags<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;if&nbsp;(boxResult.hasFault()&nbsp;&amp;&amp;&nbsp;boxResult.faultWasDispatched())&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;m_alphaPipeline-&gt;flush(&quot;flush::Box-faultWasDispatched&quot;);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;m_pBox-&gt;enterPal(getFaultReason(...),&nbsp;vector,&nbsp;faultPC);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;if&nbsp;(boxResult.needsWriteDrain())&nbsp;m_cBox-&gt;drainWriteBuffers();<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;if&nbsp;(boxResult.needsMemoryBarrier())&nbsp;m_cBox-&gt;issueMemoryBarrier(PAL);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;if&nbsp;(boxResult.needsHalted())&nbsp;haltCPU();<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;}<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">}<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The four-step sequence: (1) check interrupts, (2) IBox fetch, (3) pipeline tick (advances all stages, returns BoxResult from EX), (4) handle result flags (faults → enterPal, drains, halts). Faults are only handled if faultWasDispatched() is true — meaning the faulting instruction reached WB stage retirement, preserving precise exception semantics.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">12.5.3 Run Loop Invariants<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The run loop enforces: one cycle per iteration, deterministic ordering (interrupt check → fetch → tick → handle), no mid-instruction interruption (interrupt check is before fetch, not during execution), no speculative privilege leakage, and precise exception semantics (faults dispatched only from WB). The run loop is the only place where execution advances.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: cpuCoreLib\/AlphaCPU.cpp (executeLoop); cpuCoreLib\/AlphaCPU.h (runOneInstruction).<\/span><\/p>\n\r"
})
