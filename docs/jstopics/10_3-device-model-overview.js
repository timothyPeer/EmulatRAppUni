hmLoadTopic({
hmKeywords:"",
hmTitle:"10.3 Device Model Overview",
hmDescription:"10.3.1 What a Device Is  In EMulatR, a device is an object that owns one or more MMIO address ranges, exposes registers via MMIO, executes operations asynchronously, signals...",
hmPrevLink:"10_2-design-philosophy.html",
hmNextLink:"10_3_2-device-attachment.html",
hmParentLink:"chapter-10---devices-and-mmio.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-10---devices-and-mmio.html\">Chapter 10 – Devices and Memory-Mapped I\/O (MMIO)<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 10 – Devices and Memory-Mapped I\/O (MMIO) > 10.3 Device Model Overview",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">10.3 Device Model Overview<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">10.3.1 What a Device Is<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">In EMulatR, a device is an object that owns one or more MMIO address ranges, exposes registers via MMIO, executes operations asynchronously, signals completion via interrupts, and may perform DMA into GuestMemory. Devices do not execute in the CPU pipeline.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">All device emulators implement the IDeviceEmulator interface (IDeviceEmulator.h, 266 lines), which defines the contract between devices and the MMIO subsystem.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">10.3.2 IDeviceEmulator Interface<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The interface defines five lifecycle and MMIO methods:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">initialize(hoseId, basePA, irqVector, ipl) — Phase 3 initialization. Device stores allocated resources, resets registers to power-on defaults. Called from init thread (not concurrent).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">onRead(offset, width, &amp;outValue) → MMIOStatus — Handle MMIO read. MMIOManager has already validated PA, access width, and converted offset to BAR-relative. Device reads from internal register, returns immediately (no blocking I\/O). May have side effects (clear-on-read ISR, FIFO pop). May be called concurrently from multiple vCPU threads.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">onWrite(offset, width, value) → MMIOStatus — Handle MMIO write. Device writes to internal register, triggers side effects (doorbell writes, command start, interrupt mask update). Returns immediately; long operations deferred to worker thread. May be called concurrently.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">onReset() — Reset device to power-on state. Clears registers, pending interrupts, aborts in-flight DMA. Called from init\/reset thread.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">onFence(kind) — Handle global MMIO fence (MB\/WMB). Device may need to drain posted write buffers or complete pending DMA. Default implementation is a no-op.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Plus metadata: deviceUid() and deviceName() for routing and diagnostics.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">10.3.3 Device Classes<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The mmio_DeviceClass enumeration categorizes all device types:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">enum&nbsp;class&nbsp;mmio_DeviceClass&nbsp;:&nbsp;quint8&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;INVALID&nbsp;=&nbsp;0,&nbsp;UNKNOWN,<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;Controllers<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;SCSI_HBA,&nbsp;IDE_CONTROLLER,&nbsp;NIC,<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;Child&nbsp;devices<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;SCSI_DISK,&nbsp;SCSI_TAPE,&nbsp;SCSI_CDROM,&nbsp;SCSI_CONTROLLER,<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;IDE_DISK,&nbsp;IDE_CDROM,<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;UART_CONSOLE,&nbsp;UART,<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;Infrastructure<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;HOST_BRIDGE_NODE,&nbsp;BRIDGE<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">};<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: mmioLib\/IDeviceEmulator.h; coreLib\/mmio_core.h.<\/span><\/p>\n\r"
})
