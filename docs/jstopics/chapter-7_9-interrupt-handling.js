hmLoadTopic({
hmKeywords:"",
hmTitle:"7.10 Interrupt Handling",
hmDescription:"7.10.1 Interrupt Masking  Interrupt delivery depends on the current processor state. An interrupt is deliverable only when its IPL exceeds the current IPL (PS.IPL), interrupts...",
hmPrevLink:"chapter-7_8-pal-mode-entry.html",
hmNextLink:"chapter-7_10-traps-and-trapb.html",
hmParentLink:"chapter-7---interrupt-and-ipi-.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-7---interrupt-and-ipi-.html\">Chapter 7 - Exceptions, Faults, and Interrupts<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 7 - Exceptions, Faults, and Interrupts > 7.10 Interrupt Handling",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">7.10 Interrupt Handling<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">7.10.1 Interrupt Masking<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Interrupt delivery depends on the current processor state. An interrupt is deliverable only when its IPL exceeds the current IPL (PS.IPL), interrupts are enabled, the CPU is not in the middle of a serialized barrier, and the CPU is not in a PAL entry sequence. Masked interrupts remain pending in the IRQPendingState until they become deliverable.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">7.10.2 IRQPendingState<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">IRQPendingState (IRQPendingState.h, 378 lines) is the per-CPU interrupt tracking structure. It is designed for cross-thread safety: device threads may raise interrupts at any time, while the CPU thread checks for deliverable interrupts every cycle.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Key data structures:<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>pendingLevelsMask (atomic&lt;quint32&gt;) — summary bitset: bit L set means at least one pending source at IPL L. Single fast check for &quot;what needs attention&quot;.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>pendingSourcesByLevel (array of atomic&lt;quint64&gt;) — per-level source bitmask for up to 64 interrupt sources per level<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>highestPendingLevel (atomic&lt;quint8&gt;) — cached highest pending IPL for ultra-fast per-instruction checking. 0xFF means &quot;nothing pending.&quot; Updated atomically by raise\/clear\/claim.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>inServiceMask — CPU-thread-only mask tracking claimed (in-service) level-triggered interrupts<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Per-source static configuration — trigger mode (edge\/level), SCB vector index, IPL assignment<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">7.10.3 Interrupt Delivery<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">AlphaCPU::checkInterrupts() is called each cycle. It reads the current IPL, tests hasDeliverable(currentIPL), claims the next interrupt via claimNext(), clears the SISR bit for software interrupts, and dispatches via PalService::deliverInterrupt(claimed). The interrupt handler saves PC and PS, selects the interrupt vector, and transfers control to the PAL interrupt handler.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">7.10.4 Inter-Processor Interrupts (IPIs)<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">IPIs are used for TLB shootdowns, cache invalidation, SMP coordination, and cross-CPU signaling. IPIs enter the system as interrupts and follow the same delivery rules. On receipt, handleTLBShootdownIPI() decodes the IPI command and performs the requested action (TLB invalidation by VA for ITB or DTB, TLB flush all, or global barrier acknowledgment).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Implementation: InterruptRouter.h (505 lines) handles interrupt routing and IPI dispatch.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: coreLib\/IRQPendingState.h; coreLib\/InterruptRouter.h; cpuCoreLib\/AlphaCPU.h (checkInterrupts, handleTLBShootdownIPI).<\/span><\/p>\n\r"
})
