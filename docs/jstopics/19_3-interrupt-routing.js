hmLoadTopic({
hmKeywords:"",
hmTitle:"19.3 Interrupt Routing",
hmDescription:"19.3.1 InterruptRouter  InterruptRouter (coreLib\/InterruptRouter.h, ~505 lines) handles interrupt routing policy — determining which CPU receives a given interrupt in SMP...",
hmPrevLink:"19_2-irqpendingstate-implement.html",
hmNextLink:"19_4-interrupt-sampling-and-de.html",
hmParentLink:"chapter-19---debugging_-tracin.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-19---debugging_-tracin.html\">Chapter 19 – Interrupt Architecture &amp; IPI<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 19 – Interrupt Architecture & IPI > 19.3 Interrupt Routing",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">19.3 Interrupt Routing<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">19.3.1 InterruptRouter<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">InterruptRouter<\/span> (<span class=\"f_CodeExample\">coreLib\/InterruptRouter.h<\/span>, ~505 lines) handles interrupt routing policy — determining which CPU receives a given interrupt in SMP configurations. It provides per-vector routing configuration and supports four routing policies:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Policy<\/span><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Behavior<\/span><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">FIXED_CPU<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Affinity-pinned — interrupt always delivered to a specific CPU. Default policy, routes to CPU 0.<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">ROUND_ROBIN<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Load distribution — interrupts rotate across CPUs for balanced handling.<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">LOWEST_IPL<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Target the CPU currently at the lowest IPL — interrupt is most likely to be immediately deliverable.<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">BROADCAST<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Deliver to all CPUs simultaneously — used for system-wide notifications.<\/p>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The routing policy is configured per device in the <span class=\"f_CodeExample\">IrqTemplate<\/span> within <span class=\"f_CodeExample\">DeviceTemplate<\/span> (see Chapter 16). The default is <span class=\"f_CodeExample\">FIXED_CPU<\/span> targeting CPU 0, which matches typical Alpha system configurations. InterruptRouter also handles IPI dispatch — routing IPI messages from the source CPU to the target CPU\'s <span class=\"f_CodeExample\">IRQPendingState<\/span>.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">19.3.2 Priority and Masking Rules<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Interrupt delivery is gated by several conditions. An interrupt is deliverable only when: its IPL exceeds the current processor IPL (<span class=\"f_CodeExample\">PS.IPL<\/span>), interrupts are enabled in the processor state, the CPU is not in the middle of a serialized barrier, and the CPU is not in a PAL entry sequence (except for machine checks, which override PAL mode).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Higher IPL masks lower-priority interrupts. Machine checks override all masking. IPIs respect IPL. Software interrupts at IPL 1–15 follow the same masking rules as hardware interrupts. ASTs are gated at IPL 2 and additionally by the AST enable mask and current processor mode.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Masked interrupts remain pending in <span class=\"f_CodeExample\">IRQPendingState<\/span> until they become deliverable. They are not lost — the pending state persists until claimed or cleared.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: coreLib\/InterruptRouter.h (~505 lines); <a href=\"mplatedefault-modified2026-02-.html\" class=\"topiclink\">16.10 Device Registration and Template System<\/a> (IrqTemplate routing policy).<\/span><\/p>\n\r"
})
