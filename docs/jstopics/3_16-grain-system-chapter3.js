hmLoadTopic({
hmKeywords:"",
hmTitle:"3.16 Grain System",
hmDescription:"The grain system provides the instruction abstraction layer that bridges raw 32-bit instruction words to executable behavior.",
hmPrevLink:"3_15-ll_sc-interaction-with-th.html",
hmNextLink:"chapter-3-key-takeaways.html",
hmParentLink:"chapter-3---pipeline-architect.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-3---pipeline-architect.html\">Chapter 3 - Pipeline Architecture<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 3 - Pipeline Architecture > 3.16 Grain System ",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">3.16 Grain System<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">The grain system provides the instruction abstraction layer that bridges raw 32-bit instruction words to executable behavior.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">Grain Resolution<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The GrainResolver is a singleton that decodes raw instructions and resolves them to InstructionGrain objects. Resolution extracts the 6-bit opcode and the function code (format-dependent), then looks up the corresponding grain in the InstructionGrainRegistry. For PAL hardware opcodes (0x19, 0x1B, 0x1D, 0x1E, 0x1F), the function code is treated as an operand (IPR index), not a grain selector — these instructions share a single grain per opcode.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">inline&nbsp;InstructionGrain*&nbsp;ResolveGrain(quint32&nbsp;rawBits)&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;const&nbsp;quint8&nbsp;opcode&nbsp;=&nbsp;(rawBits&nbsp;&gt;&gt;&nbsp;26)&nbsp;&amp;&nbsp;0x3F;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;quint16&nbsp;func;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;if&nbsp;(isPalHardwareOpcode(opcode))<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;func&nbsp;=&nbsp;0x0000;&nbsp;\/\/&nbsp;IPR&nbsp;index&nbsp;is&nbsp;operand,&nbsp;not&nbsp;grain&nbsp;selector<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;else<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;func&nbsp;=&nbsp;extractFunctionCode(rawBits,&nbsp;opcode);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;return&nbsp;InstructionGrainRegistry::instance().lookup(opcode,&nbsp;func);<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">}<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">Grain Caching<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Decoding occurs once per unique instruction pattern (opcode + function code). The resolved grain is cached in the InstructionGrainRegistry and reused on subsequent fetches of the same pattern. This avoids redundant decode work — execution may occur thousands of times from a single decode operation.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">Grain Structure<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Each InstructionGrain carries:<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>flags (GrainFlags) — format classification: OperateFormat, MemoryFormat, BranchFormat, PALFormat, CanDualIssue, NeedsStall<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>latency and throughput — cycle counts for scheduling<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Virtual methods: execute(PipelineSlot&amp;), mnemonic(), opcode(), functionCode(), grainType()<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The execute() method is the single dispatch point — it is called by stage_EX() and contains the instruction\'s complete architectural behavior.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">GrainMaster.tsv<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The GrainMaster.tsv file is the master opcode table (616 entries) that defines every instruction the emulator supports. Each row specifies the opcode, function code, mnemonic, description, instruction type, and target Box. The Python tooling (generate_all_grains.py) reads this TSV and generates C++ registration code that populates the InstructionGrainRegistry at startup.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">Instruction Format Classification<\/span><\/h3>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The GrainResolver classifies instructions into formats for pipeline routing:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Operate — integer operate (non-barrier)<\/p>\n\r<p class=\"p_Normal\">Memory — normal LD\/ST\/LDA\/LDAH<\/p>\n\r<p class=\"p_Normal\">Branch — BR\/BSR\/BEQ and conditional branches<\/p>\n\r<p class=\"p_Normal\">Pal — CALL_PAL instructions<\/p>\n\r<p class=\"p_Normal\">Float — FP arithmetic and FP compare<\/p>\n\r<p class=\"p_Normal\">MemoryMB — memory-with-function: FETCH\/FETCH_M\/WH64\/MB\/WMB<\/p>\n\r<p class=\"p_Normal\">JMP_JSR_Format — JMP, JSR, RET, JSR_COROUTINE<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: grainFactoryLib\/GrainResolver.h; grainFactoryLib\/InstructionGrain.h; grainFactoryLib\/GrainMaster.tsv; Python\/generate_all_grains.py.<\/span><\/p>\n\r"
})
