hmLoadTopic({
hmKeywords:"",
hmTitle:"17.4 SPAM TLB Cache Architecture",
hmDescription:"17.4.1 What SPAM Is  SPAM (Set Prediction and Access Memory) is the name for the per-CPU PTE cache in EMulatR. It models the Alpha EV6 Translation Lookaside Buffer as a sharded,",
hmPrevLink:"17_3-translation-path.html",
hmNextLink:"17_5-ev6silicontlb-and-layer-a.html",
hmParentLink:"chapter-17---tlb_-pte_-and-add.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-17---tlb_-pte_-and-add.html\">Chapter 17 – Address Translation, TLB, and PTE<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 17 – Address Translation, TLB, and PTE > 17.4 SPAM TLB Cache Architecture",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">17.4 SPAM TLB Cache Architecture<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">17.4.1 What SPAM Is<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SPAM (Set Prediction and Access Memory) is the name for the per-CPU PTE cache in EMulatR. It models the Alpha EV6 Translation Lookaside Buffer as a sharded, set-associative cache with per-CPU isolation. The SPAM cache acts like a 4-dimensional associative array indexed by CPU, Realm (ITB\/DTB), SizeClass, and BucketIndex.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">17.4.2 Sharding Architecture<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">SPAMShardManager<\/span> (<span class=\"f_CodeExample\">pteLib\/alpha_spam_manager.h<\/span>) implements sharding along four axes:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">By CPU:<\/strong> Each logical CPU receives its own slice of the TLB cache. CPU 0\'s SPAM shard is fully independent of CPU 1\'s shard. This eliminates cross-CPU contention on the translation hot path.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">By Realm:<\/strong> Separate shards are maintained for Instruction translation (ITB) and Data translation (DTB). This reflects the EV6 hardware, which has physically separate ITB and DTB structures.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">By Size Class:<\/strong> When <span class=\"f_CodeExample\">ShardBySize=true<\/span>, entries are grouped by page size (e.g., 8K, 64K). This supports granularity hint (GH) superpages without polluting the base-page-size buckets.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">By Bucket Index:<\/strong> Each shard subdivides its set into hash buckets for fast lookup. The VPN and ASN are hashed to select a bucket, and within the bucket, a set-associative search finds the matching entry.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Per-CPU&nbsp;SPAM&nbsp;Layout:<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;┌────────────────────────────┐<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│&nbsp;CPU&nbsp;0&nbsp;CPU&nbsp;1&nbsp;CPU&nbsp;2&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│&nbsp;┌──────┐&nbsp;┌──────┐&nbsp;┌──────┐&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│&nbsp;│&nbsp;ITB&nbsp;&nbsp;│&nbsp;│&nbsp;ITB&nbsp;&nbsp;│&nbsp;│&nbsp;ITB&nbsp;&nbsp;│&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│&nbsp;│&nbsp;DTB&nbsp;&nbsp;│&nbsp;│&nbsp;DTB&nbsp;&nbsp;│&nbsp;│&nbsp;DTB&nbsp;&nbsp;│&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;│&nbsp;└──────┘&nbsp;└──────┘&nbsp;└──────┘&nbsp;│<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;└────────────────────────────┘<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">17.4.3 SPAMBucket – Per-Bucket Storage<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">SPAMBucket<\/span> (<span class=\"f_CodeExample\">pteLib\/alpha_spam_bucket.h<\/span>) is the storage unit within each shard. It holds a fixed-associativity set of PTE entries and provides lookup, insert, and invalidate operations within that set. Each bucket entry stores an <span class=\"f_CodeExample\">Ev6TLBTag<\/span> (VPN, realm, sizeClass, matchAllASNs flag), the ASN, the validity state, and the PTE content (<span class=\"f_CodeExample\">AlphaPTE<\/span> via traits).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">On lookup, the bucket performs a linear scan of its entries, matching VPN, ASN (or global flag), realm, and size class. On insert, the bucket uses the configured replacement policy to select a victim entry if the set is full.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">17.4.4 SPAMShardManager Operations<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The primary operations exposed by <span class=\"f_CodeExample\">SPAMShardManager<\/span>:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Operation<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Description<\/strong><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">tlbLookup(cpuId, tag, asn)<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Search per-CPU shard for matching TLB entry; returns pointer to entry or null<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">tlbInsert(cpuId, tag, asn, pte)<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Insert PTE into per-CPU shard; uses replacement policy for victim selection<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">invalidateASN(cpuId, asn)<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Invalidate all entries for a specific ASN on one CPU<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">invalidateASN_AllShards(asn)<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Invalidate ASN across all CPUs (SMP-wide)<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">tbis(cpuId, va, asn)<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Invalidate single VA entry (TBIS — TLB Invalidate Single)<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">tbia(cpuId)<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Invalidate all entries on one CPU (TBIA — TLB Invalidate All)<\/p>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Configuration parameters include number of buckets, associativity (entries per bucket), maximum ASNs, and replacement policy selection. The <span class=\"f_CodeExample\">maintenanceTick()<\/span> method performs periodic cache sweeps and telemetry collection.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: pteLib\/alpha_spam_manager.h – SPAMShardManager template; pteLib\/alpha_spam_bucket.h – SPAMBucket template; <a href=\"chapter-9_4-per-cpu-vs-shared-.html\" class=\"topiclink\">9.4 Per-CPU vs Shared State<\/a> .<\/span><\/p>\n\r"
})
