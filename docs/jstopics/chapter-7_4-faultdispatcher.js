hmLoadTopic({
hmKeywords:"",
hmTitle:"7.5 FaultDispatcher",
hmDescription:"7.5.1 Role  The FaultDispatcher is the central authority for managing exceptional events. There is one FaultDispatcher per CPU, accessed via globalFaultDispatcher(cpuId). It...",
hmPrevLink:"7_4-exception-detection-points.html",
hmNextLink:"chapter-7_5-priority-ordering.html",
hmParentLink:"chapter-7---interrupt-and-ipi-.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-7---interrupt-and-ipi-.html\">Chapter 7 - Exceptions, Faults, and Interrupts<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 7 - Exceptions, Faults, and Interrupts > 7.5 FaultDispatcher",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">7.5 FaultDispatcher<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">7.5.1 Role<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The FaultDispatcher is the central authority for managing exceptional events. There is one FaultDispatcher per CPU, accessed via globalFaultDispatcher(cpuId). It decouples detection from delivery: faults are queued when detected and delivered when the pipeline reaches a safe state.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Responsibilities: queue faults and traps, track pending interrupts, enforce priority ordering, control delivery timing, and prevent imprecise state exposure.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">7.5.2 Event Queueing<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">When a fault is detected, the detector creates a PendingEvent and passes it to FaultDispatcher::setPendingEvent(). The event is classified by kind, exception class, priority, and associated data (faultVA, faultPC, trapCode, etc.). Instruction execution halts and pipeline advancement is constrained until the event is delivered.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">7.5.3 Fast-Path Query Interface<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The FaultDispatcher\'s eventPending() method is the hottest path in the emulator â€” it is called every cycle by the run loop. The implementation uses a simple bitfield check with no atomics (per-CPU only):<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">bool&nbsp;eventPending()&nbsp;const&nbsp;noexcept&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;return&nbsp;m_pendingFlags&nbsp;!=&nbsp;0;&nbsp;\/\/&nbsp;~1&nbsp;cycle,&nbsp;no&nbsp;atomic<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">}<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The pending flags are a bitmask tracking event categories:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">FLAG_NONE&nbsp;=&nbsp;0x00<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">FLAG_EXCEPTION&nbsp;=&nbsp;0x01&nbsp;\/\/&nbsp;Generic&nbsp;exception<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">FLAG_ARITHMETIC_TRAP&nbsp;=&nbsp;0x02&nbsp;\/\/&nbsp;Arithmetic&nbsp;trap&nbsp;(for&nbsp;TRAPB)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">FLAG_DTB_MISS&nbsp;=&nbsp;0x04&nbsp;\/\/&nbsp;Data&nbsp;TLB&nbsp;miss<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">FLAG_ITB_MISS&nbsp;=&nbsp;0x08&nbsp;\/\/&nbsp;Instruction&nbsp;TLB&nbsp;miss<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">FLAG_INTERRUPT&nbsp;=&nbsp;0x10&nbsp;\/\/&nbsp;Interrupt&nbsp;pending<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">FLAG_MACHINE_CHECK&nbsp;=&nbsp;0x20&nbsp;\/\/&nbsp;Machine&nbsp;check&nbsp;(highest&nbsp;priority)<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Specialized query methods test individual flags: hasPendingArithmeticTraps() (for TRAPB release), hasPendingTLBFaults() (DTB\/ITB), hasPendingInterrupt(), hasPendingMachineCheck().<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">7.5.4 Event Clearing<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">clearPendingEvents() resets both the PendingEvent structure and the flag bitmask to zero. clearArithmeticTrap() clears only the arithmetic trap flag and, if the pending event is an Arithmetic class, clears the event as well. This allows TRAPB to selectively clear arithmetic traps while leaving other events pending.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Implementation: FaultDispatcher.h, 449 lines.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: faultLib\/FaultDispatcher.h; faultLib\/PendingEvent_Refined.h.<\/span><\/p>\n\r"
})
