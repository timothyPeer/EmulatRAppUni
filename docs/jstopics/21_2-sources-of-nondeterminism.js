hmLoadTopic({
hmKeywords:"",
hmTitle:"21.2 Sources of Nondeterminism",
hmDescription:"EMulatR explicitly identifies potential nondeterminism sources and applies control strategies to each:",
hmPrevLink:"21_1-determinism-as-a-design-g.html",
hmNextLink:"21_3-exectrace-instrumentation.html",
hmParentLink:"chapter-21---debugging_-tracin.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-21---debugging_-tracin.html\">Chapter 21 – Debugging, Tracing, and Determinism<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 21 – Debugging, Tracing, and Determinism > 21.2 Sources of Nondeterminism",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">21.2 Sources of Nondeterminism<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">EMulatR explicitly identifies potential nondeterminism sources and applies control strategies to each:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Source<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Risk<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Control Strategy<\/strong><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Device timing<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Devices execute asynchronously and may signal completion at host-dependent times<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Optional deterministic scheduling mode — device progress advances only when CPU cycles advance, eliminating host timing variance<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Interrupt arrival<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Asynchronous interrupts could arrive at unpredictable points<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Sampled at fixed run-loop points only — <span class=\"f_CodeExample\">checkInterrupts()<\/span> executes at instruction boundaries, never mid-instruction<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">DMA completion<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">DMA transfers complete asynchronously on host threads<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Explicit completion events delivered through the interrupt system — visible only at sampling points<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">SMP race windows<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Cross-CPU memory accesses may interleave differently<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Architectural serialization via explicit barriers, atomic operations, and MemoryBarrierCoordinator synchronization<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Host thread timing<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">QThread scheduling on the host OS is nondeterministic<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Emulator-controlled ordering — CPU run loops are synchronized via <span class=\"f_CodeExample\">ExecutionCoordinator<\/span>, device I\/O threads communicate only through atomic state<\/p>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Devices are the primary source of nondeterminism. The deterministic scheduling mode (when enabled) forces all device state transitions to occur in lockstep with CPU cycles, converting asynchronous behavior into synchronous behavior at the cost of reduced host performance. In non-deterministic mode, device timing reflects host system behavior, which may be acceptable for interactive use but unsuitable for regression testing.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Host-specific optimizations that compromise determinism — such as JIT compilation or host SIMD acceleration — are excluded from the design by policy.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-16---device-model--dma.html\" class=\"topiclink\">Chapter 16 – Device Model &amp; DMA<\/a> (device timing model); <a href=\"chapter-19---debugging_-tracin.html\" class=\"topiclink\">Chapter 19 – Interrupt Architecture &amp; IPI<\/a> (interrupt sampling semantics).<\/span><\/p>\n\r"
})
