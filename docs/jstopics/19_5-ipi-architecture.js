hmLoadTopic({
hmKeywords:"",
hmTitle:"19.5 IPI Architecture",
hmDescription:"19.5.1 Design Decision: Unified Interrupt Path  EMulatR intentionally does not create a second interrupt system for IPIs. Instead, IPIs are injected into the same interrupt...",
hmPrevLink:"19_4-interrupt-sampling-and-de.html",
hmNextLink:"19_6-memory-barrier-coordinati.html",
hmParentLink:"chapter-19---debugging_-tracin.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-19---debugging_-tracin.html\">Chapter 19 – Interrupt Architecture &amp; IPI<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 19 – Interrupt Architecture & IPI > 19.5 IPI Architecture",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">19.5 IPI Architecture<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">19.5.1 Design Decision: Unified Interrupt Path<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">EMulatR intentionally does not create a second interrupt system for IPIs. Instead, IPIs are injected into the same interrupt infrastructure as device and software interrupts. They use the same prioritization, masking, and PAL delivery rules. They differ only in source (another CPU) and payload (an <span class=\"f_CodeExample\">IPICommand<\/span> with encoded parameters). This avoids duplicated logic and preserves architectural clarity.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">19.5.2 IPIManager<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">IPIManager<\/span> (<span class=\"f_CodeExample\">emulatrLib\/IPIManager.h<\/span>, ~192 lines) provides lock-free IPI message routing. Each CPU has an atomic IPI data slot (<span class=\"f_CodeExample\">std::atomic&lt;quint64&gt;<\/span>). The design uses latest-IPI-wins semantics, which matches Alpha hardware behavior — posting a new IPI overwrites any pending IPI that has not yet been read.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Key API:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">postIPI(cpuId, ipiData)<\/span> — stores atomically with <span class=\"f_CodeExample\">memory_order_release<\/span>. The source CPU writes the encoded IPI data into the target CPU\'s slot.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">fetchIPI(cpuId)<\/span> — atomically exchanges to zero with <span class=\"f_CodeExample\">memory_order_acq_rel<\/span> (read and clear). The target CPU reads and clears its IPI slot in a single atomic operation.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">peekIPI(cpuId)<\/span> — reads without clearing. Used for diagnostic inspection.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">hasIPIPending(cpuId)<\/span> — checks for non-zero data. Used by the CPU run loop to determine if IPI processing is needed.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">19.5.3 IPICommand Encoding<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">IPI data is encoded as a <span class=\"f_CodeExample\">quint64<\/span>: the command byte occupies bits [63:56], and the parameter occupies bits [55:0]. The <span class=\"f_CodeExample\">IPICommand<\/span> enumeration (<span class=\"f_CodeExample\">coreLib\/IPI_core.h<\/span>, ~245 lines) defines the complete command set:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Category<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Commands<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Range<\/strong><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_CodeExample\"><span class=\"f_CodeExample\">TLB&nbsp;Invalidation<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">TLB_INVALIDATE_ALL<\/span> (TBIA), <span class=\"f_CodeExample\">TLB_INVALIDATE_ASN<\/span> (TBIAP), <span class=\"f_CodeExample\">TLB_INVALIDATE_VA_BOTH<\/span> (TBIS), <span class=\"f_CodeExample\">TLB_INVALIDATE_VA_ITB<\/span>, <span class=\"f_CodeExample\">TLB_INVALIDATE_VA_DTB<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">0x01–0x07<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Cache&nbsp;Coherency<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">CACHE_INVALIDATE_LINE<\/span>, <span class=\"f_CodeExample\">CACHE_FLUSH_LINE<\/span>, <span class=\"f_CodeExample\">CACHE_EVICT_LINE<\/span>, <span class=\"f_CodeExample\">CACHE_INVALIDATE_ALL<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">0x10–0x13<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Memory&nbsp;Barriers<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">MEMORY_BARRIER_FULL<\/span> (MB), <span class=\"f_CodeExample\">MEMORY_BARRIER_WRITE<\/span> (WMB)<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">0x20–0x22<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Synchronization<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">SYNC_REQUEST<\/span>, <span class=\"f_CodeExample\">SYNC_ACKNOWLEDGE<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">0x30–0x31<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_CodeExample\"><span class=\"f_CodeExample\">System&nbsp;Control<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">HALT_CPU<\/span>, <span class=\"f_CodeExample\">WAKE_CPU<\/span>, <span class=\"f_CodeExample\">CONTEXT_SWITCH<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">0x40–0x42<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_CodeExample\"><span class=\"f_CodeExample\">Custom<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">CUSTOM_BASE<\/span>, <span class=\"f_CodeExample\">CUSTOM<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">0xF0–0xFF<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><br \/>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><br \/>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><br \/>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Helper functions <span class=\"f_CodeExample\">encodeIPIData()<\/span>, <span class=\"f_CodeExample\">encodeIPIWithVA()<\/span>, <span class=\"f_CodeExample\">encodeIPIWithASN()<\/span>, <span class=\"f_CodeExample\">decodeIPICommand()<\/span>, <span class=\"f_CodeExample\">decodeIPIVA()<\/span>, and <span class=\"f_CodeExample\">decodeIPIASN()<\/span> handle encoding and decoding of the 64-bit IPI data word.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">19.5.4 IPI Delivery Semantics<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">When an IPI is delivered to the target CPU:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">1.&nbsp;IRQPendingState&nbsp;signals&nbsp;the&nbsp;target&nbsp;CPU&nbsp;(IPI&nbsp;source&nbsp;asserted)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">2.&nbsp;CPU&nbsp;enters&nbsp;PAL&nbsp;interrupt&nbsp;handler&nbsp;via&nbsp;checkInterrupts()<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">3.&nbsp;PAL&nbsp;calls&nbsp;handleTLBShootdownIPI(cpuId,&nbsp;ipiData)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">4.&nbsp;decodeIPICommand(ipiData)&nbsp;extracts&nbsp;the&nbsp;command<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">5.&nbsp;Command-specific&nbsp;handler&nbsp;executes:<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;TLB_INVALIDATE_VA_ITB&nbsp;→&nbsp;m_tlb→invalidateTLBEntry(cpuId,&nbsp;Realm::I,&nbsp;va,&nbsp;asn)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;TLB_INVALIDATE_VA_DTB&nbsp;→&nbsp;m_tlb→invalidateTLBEntry(cpuId,&nbsp;Realm::D,&nbsp;va,&nbsp;asn)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;TLB_INVALIDATE_ALL&nbsp;→&nbsp;tbia(cpuId)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;MEMORY_BARRIER_FULL&nbsp;→&nbsp;drain&nbsp;write&nbsp;buffer,&nbsp;acknowledge&nbsp;barrier<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">6.&nbsp;Optional&nbsp;acknowledgment&nbsp;sent&nbsp;to&nbsp;initiating&nbsp;CPU<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">7.&nbsp;HW_REI&nbsp;returns&nbsp;to&nbsp;normal&nbsp;execution<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">IPIs are never handled inline in normal execution. They always enter PAL mode for processing.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: emulatrLib\/IPIManager.h (~192 lines); coreLib\/IPI_core.h (~245 lines); cpuCoreLib\/AlphaCPU.h – handleTLBShootdownIPI(); <a href=\"chapter-9_6-write-buffers-in-s.html\" class=\"topiclink\">9.6 Inter-Processor Interrupts (IPIs)<\/a>.<\/span><\/p>\n\r"
})
