hmLoadTopic({
hmKeywords:"",
hmTitle:"Lifecycle",
hmDescription:"A characterization aligned with EV6\/ASA semantics and the current EmulatR design.",
hmPrevLink:"",
hmNextLink:"",
hmParentLink:"appendix---trait-examples.html",
hmBreadCrumbs:"",
hmTitlePath:"Introduction > Appendix > Appendix I – Global Singletons",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">Lifecycle <\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">A characterization aligned with EV6\/ASA semantics and the current EmulatR design.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">## Short Answer (Verdict)<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1. **HW_MTPR (including MTPR_SIRR)** is responsible for **updating IPR state only**.<\/p>\n\r<p class=\"p_Normal\">2. **Interrupts (including ASTs)** are **scheduled**, not immediately executed.<\/p>\n\r<p class=\"p_Normal\">3. **Delivery occurs at a defined post-retirement boundary**, before the next PC+n fetch.<\/p>\n\r<p class=\"p_Normal\">4. **IRQController + FaultDispatcher** are the correct abstraction for delivery.<\/p>\n\r<p class=\"p_Normal\">5. Your current EmulatR model matches Alpha architectural intent.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You are **not missing a hidden side effect** in HW_MTPR.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">&nbsp;<\/span><\/h2>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">## 1. Architectural Rule to Anchor Everything<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">From the Alpha System Architecture (EV6 consistent):<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&gt; *Writing an IPR may cause an interrupt or exception to become pending, but delivery occurs only at architecturally defined recognition points.*<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">That sentence is the key.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">**Recognition ≠ write**<\/p>\n\r<p class=\"p_Normal\">**Pending ≠ delivered**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">## 2. Correct Lifecycle (Refined)<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Let’s restate the lifecycle using your components and the Alpha rules.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\"> A. Grain executes (e.g., HW_MTPR_SIRR)<\/span><\/h3>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">At grain execution:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* The grain:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Validates privilege<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Writes the architectural register (IPR)<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* Returns normally<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">For **MTPR_SIRR** specifically:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Bitwise effect:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* SIRR bit(s) set in the appropriate IPR<\/p>\n\r<p class=\"p_Normal\">* Semantic effect:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* “An interrupt is now *pending*”<\/p>\n\r<p class=\"p_Normal\">* **No control transfer**<\/p>\n\r<p class=\"p_Normal\">* **No PAL entry**<\/p>\n\r<p class=\"p_Normal\">* **No pipeline break**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is *exactly correct*.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&gt; HW_MTPR sets state; it does not deliver events.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\">&nbsp;<\/span><\/h3>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\"> B. Grain retirement (serialization point)<\/span><\/h3>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">At retirement:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* All side effects of the grain are complete<\/p>\n\r<p class=\"p_Normal\">* Ordering is guaranteed<\/p>\n\r<p class=\"p_Normal\">* PC+n is determined but **not yet fetched**<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is the **earliest legal point** at which an interrupt may be recognized.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\"> C. Interrupt recognition window (between grains)<\/span><\/h3>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Now — and only now — the emulator may ask:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Is there a pending interrupt?<\/p>\n\r<p class=\"p_Normal\">* Is delivery enabled?<\/p>\n\r<p class=\"p_Normal\">* Is IPL sufficient?<\/p>\n\r<p class=\"p_Normal\">* Are we not already in PALmode?<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This check belongs **outside the grain**, in:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* AlphaPipeline<\/p>\n\r<p class=\"p_Normal\">* or a post-retirement hook<\/p>\n\r<p class=\"p_Normal\">* or your existing “end of cycle” logic<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If eligible:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Schedule interrupt delivery via:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* IRQController<\/p>\n\r<p class=\"p_Normal\"> &nbsp;* FaultDispatcher<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This matches hardware: **interrupt delivery is asynchronous to instruction execution but synchronous to retirement boundaries**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\"> D. Interrupt delivery (before next fetch)<\/span><\/h3>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Before fetching PC+n:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">1. Pipeline drains (conceptually)<\/p>\n\r<p class=\"p_Normal\">2. EXC_ADDR set<\/p>\n\r<p class=\"p_Normal\">3. EXC_SUM updated<\/p>\n\r<p class=\"p_Normal\">4. PALmode entered<\/p>\n\r<p class=\"p_Normal\">5. PC redirected to PAL vector<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is handled by **FaultDispatcher**, not the grain that caused the interrupt to become pending.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 3. Why HW_MTPR Must NOT Deliver Side Effects<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is an important architectural correctness point.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If HW_MTPR did delivery directly, you would violate:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Precise exception rules<\/p>\n\r<p class=\"p_Normal\">* Interrupt deferral semantics<\/p>\n\r<p class=\"p_Normal\">* PAL nesting guarantees<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Examples of what must NOT happen inside HW_MTPR:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Jumping to PAL immediately<\/p>\n\r<p class=\"p_Normal\">* Forcing pipeline drain mid-grain<\/p>\n\r<p class=\"p_Normal\">* Overriding PC before retirement<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Alpha explicitly allows:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">MTPR SIRR<\/p>\n\r<p class=\"p_Normal\">(next instruction retires)<\/p>\n\r<p class=\"p_Normal\">&lt;interrupt is taken here&gt;<\/p>\n\r<p class=\"p_Normal\">```<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">So your separation is **required**, not optional.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">## 4. ASTs Are the Same (Just Lower Priority)<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">ASTs (Asynchronous System Traps):<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Are architecturally just another interrupt class<\/p>\n\r<p class=\"p_Normal\">* Differ in priority and masking rules<\/p>\n\r<p class=\"p_Normal\">* Use the same delivery mechanism<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">So:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* AST pending bit set (via IPR or OS-specific path)<\/p>\n\r<p class=\"p_Normal\">* AST scheduled<\/p>\n\r<p class=\"p_Normal\">* AST delivered at post-retirement recognition point<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Your model treating ASTs via IRQController + FaultDispatcher is **correct**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">&nbsp;<\/span><\/h2>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">## 5. Mapping Responsibilities (Clear Ownership)<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is how you should document ownership:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> HW_MTPR Grain<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Writes IPR<\/p>\n\r<p class=\"p_Normal\">* Updates pending bits<\/p>\n\r<p class=\"p_Normal\">* No delivery<\/p>\n\r<p class=\"p_Normal\">* No control transfer<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> IRQController<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Aggregates pending interrupt sources<\/p>\n\r<p class=\"p_Normal\">* Applies priority and masking rules<\/p>\n\r<p class=\"p_Normal\">* Answers “is an interrupt deliverable now?”<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h3 class=\"p_Heading3\" style=\"page-break-after: avoid;\"><span class=\"f_Heading3\"> FaultDispatcher<\/span><\/h3>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Performs architectural delivery<\/p>\n\r<p class=\"p_Normal\">* Updates EXC_ADDR \/ EXC_SUM<\/p>\n\r<p class=\"p_Normal\">* Enters PALmode<\/p>\n\r<p class=\"p_Normal\">* Redirects PC<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\"> AlphaPipeline<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">* Defines recognition points<\/p>\n\r<p class=\"p_Normal\">* Calls dispatcher before next PC fetch<\/p>\n\r<p class=\"p_Normal\">* Guarantees ordering<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is **clean**, **testable**, and **faithful**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">## 6. Your Model vs Hardware (Sanity Check)<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">|&nbsp;Aspect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Real&nbsp;EV6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;EmulatR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">|&nbsp;---------------------&nbsp;|&nbsp;----------------------------&nbsp;|&nbsp;-------------------------&nbsp;|<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">|&nbsp;MTPR&nbsp;causes&nbsp;interrupt&nbsp;|&nbsp;Sets&nbsp;pending&nbsp;latch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Sets&nbsp;IPR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">|&nbsp;Delivery&nbsp;timing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Between&nbsp;retired&nbsp;instructions&nbsp;|&nbsp;Between&nbsp;grains&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">|&nbsp;Interrupt&nbsp;nesting&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;PALmode-guarded&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;PALmode-guarded&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">|&nbsp;OoO&nbsp;effects&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Hidden&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Collapsed&nbsp;into&nbsp;retirement&nbsp;|<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">|&nbsp;AST&nbsp;handling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Deferred&nbsp;interrupt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Deferred&nbsp;interrupt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">✅ All aligned.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">## 7. One-Sentence Documentation You Can Use<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&gt; *In EmulatR, instructions such as MTPR_SIRR update interrupt-related IPR state but do not directly cause interrupt delivery. Pending interrupts are evaluated only at instruction retirement boundaries by the AlphaPipeline, and delivery is performed by the IRQController and FaultDispatcher prior to fetching the next PC.*<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">That sentence is **architecturally bulletproof**.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">---<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r"
})
