hmLoadTopic({
hmKeywords:"",
hmTitle:"PAL Module",
hmDescription:"COW is triggered by a write-fault ‚Üí PAL ‚Üí kernel trap handler",
hmPrevLink:"",
hmNextLink:"",
hmParentLink:"appendix---trait-examples.html",
hmBreadCrumbs:"",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Appendix > Appendix I ‚Äì Glossary and Acronyms",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">PAL Module<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">COW is triggered by a write-fault ‚Üí PAL ‚Üí kernel trap handler<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0;\">\n\r<tr>\n\r<td style=\"vertical-align:top; width:7.0625rem; padding:0; border:none\"><p class=\"p_Normal\">PAL Queues<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; width:141.6250rem; padding:0; border:none\"><p class=\"p_Normal\">Add to PAL Grains: &nbsp;TBIA, TBIAP, TBIS, Changing SCBB, Changing PTBR, HALT others, GLOBAL barrier (MB, WMB, MB2 operations)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">serveral types <\/p>\n\r<p class=\"p_Normal\">PALcode defines several queue-related concepts:<\/p>\n\r<p class=\"p_Normal\">Interrupt queues<\/p>\n\r<p class=\"p_Normal\">AST queues<\/p>\n\r<p class=\"p_Normal\">Soft interrupt \/ software trap queues<\/p>\n\r<p class=\"p_Normal\">Machine check logout queues<\/p>\n\r<p class=\"p_Normal\">Instruction restart queues (EV6 only)<\/p>\n\r<p class=\"p_Normal\">Memory barrier \/ IPI rendezvous queues<\/p>\n\r<p class=\"p_Normal\">Process control block \/ context queues<\/p>\n\r<p class=\"p_Normal\">But architecturally:<\/p>\n\r<p class=\"p_Normal\">üìå Each CPU has its own private PAL queue structures.<\/p>\n\r<p class=\"p_Normal\">This includes:<\/p>\n\r<p class=\"p_Normal\">‚úî Per-CPU Interrupt Queue<\/p>\n\r<p class=\"p_Normal\">The interrupt dispatch sequence is defined in PAL, and the vector logic is per CPU:<\/p>\n\r<p class=\"p_Normal\">Device IRQ ‚Üí delivered to target CPU<\/p>\n\r<p class=\"p_Normal\">CPU stores it in its PAL temp\/queue region<\/p>\n\r<p class=\"p_Normal\">PAL checks and drains that CPU‚Äôs queue<\/p>\n\r<p class=\"p_Normal\">‚úî Per-CPU AST Queue<\/p>\n\r<p class=\"p_Normal\">ASTs do not cross CPUs; the OS arranges delivery to a specific CPU.<\/p>\n\r<p class=\"p_Normal\">‚úî Per-CPU Machine Check Logout Frame Queue<\/p>\n\r<p class=\"p_Normal\">Each CPU maintains its own logout area (in memory) and PAL uses it during trap entry.<\/p>\n\r<p class=\"p_Normal\">‚úî Per-CPU IPR queue semantics<\/p>\n\r<p class=\"p_Normal\">Many PAL instructions access per-CPU IPR banks; no IPR queues are shared.<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; width:7.0625rem; padding:0; border:none\"><br \/>\n\r<\/td>\n\r<td style=\"vertical-align:top; width:141.6250rem; padding:0; border:none\"><p class=\"p_Normal\">DRIVERSCHED is OS-level, implemented using PAL + IPIs.<\/p>\n\r<p class=\"p_Normal\">This is not a hardware instruction.<\/p>\n\r<p class=\"p_Normal\">This is not a public PALcall.<\/p>\n\r<p class=\"p_Normal\">This is not a documented IPR.<\/p>\n\r<p class=\"p_Normal\">It is a process used by OSF\/1 and OpenVMS kernels.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">üü¶ 2. What is a Rendezvous Operation?<\/p>\n\r<p class=\"p_Normal\">Rendezvous in Alpha SMP means:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">‚ÄúForce all CPUs to enter a known PAL state, wait until all are present, perform a global action, then release them.‚Äù<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is used for operations that must be globally consistent, such as:<\/p>\n\r<p class=\"p_Normal\">‚úî TBIA \/ TBIAP (global TLB invalidation)<\/p>\n\r<p class=\"p_Normal\">‚úî SCB \/ vector table replacement<\/p>\n\r<p class=\"p_Normal\">‚úî ASN epoch rollover<\/p>\n\r<p class=\"p_Normal\">‚úî Global memory barriers<\/p>\n\r<p class=\"p_Normal\">‚úî Rebalancing AST queues<\/p>\n\r<p class=\"p_Normal\">‚úî Reprogramming clock sources<\/p>\n\r<p class=\"p_Normal\">‚úî Rescheduling the processor sets<\/p>\n\r<p class=\"p_Normal\">Rendezvous looks like a global lock, but at the PAL level.<\/p>\n\r<p class=\"p_Normal\">The OS essentially says:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">CPU0 broadcasts a special IPI (‚Äúenter rendezvous‚Äù).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Every CPU traps into PAL, executing the rendezvous entrypoint.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">CPU0 waits until all CPUs are in rendezvous.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">CPU0 performs the global action (such as TBIA).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">CPU0 signals ‚Äúexit rendezvous.‚Äù<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">All CPUs return back to the OS kernel.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This guarantees global consistency.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">üìå 3. DRIVERSCHED + Rendezvous together<\/p>\n\r<p class=\"p_Normal\">DRIVERSCHED is one of the subtypes of SMP rendezvous operations.<\/p>\n\r<p class=\"p_Normal\">It is used when the OS scheduler (e.g., on OpenVMS) must reconfigure:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Run queues<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Global scheduling parameters<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Quantum expiration models<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">System timebase interactions<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Process set redistribution<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">CPU affinity adjustments<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Because scheduling changes involve keeping all CPU run queues coherent, you cannot change scheduling policies or queue structure on one CPU without quiescing the others.<\/p>\n\r<p class=\"p_Normal\">Thus:<\/p>\n\r<p class=\"p_Normal\">‚úî DRIVERSCHED calls ‚Üí trigger a Rendezvous<\/p>\n\r<p class=\"p_Normal\">‚úî Rendezvous forces all CPUs into a known state<\/p>\n\r<p class=\"p_Normal\">‚úî PAL and OS coordinate the schedule change<\/p>\n\r<p class=\"p_Normal\">‚úî CPUs resume normal operation after synchronization<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">üìö 4. PAL‚Äôs Role in DRIVERSCHED \/ Rendezvous<\/p>\n\r<p class=\"p_Normal\">The PALcode provides:<\/p>\n\r<p class=\"p_Normal\">A. IPI delivery for rendezvous<\/p>\n\r<p class=\"p_Normal\">A standard ‚Äúrendezvous IPI vector‚Äù is delivered to all CPUs.<\/p>\n\r<p class=\"p_Normal\">B. PAL-level enter\/exit handlers<\/p>\n\r<p class=\"p_Normal\">PAL traps the CPU into a known state (mode, IPL, PC shadowing).<\/p>\n\r<p class=\"p_Normal\">C. Register shadowing<\/p>\n\r<p class=\"p_Normal\">PAL shadow registers preserve state while the CPU is quiesced.<\/p>\n\r<p class=\"p_Normal\">D. Synchronization flags<\/p>\n\r<p class=\"p_Normal\">PAL uses per-CPU flags to indicate:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">‚ÄúI have entered rendezvous‚Äù<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">‚ÄúI am ready to be released‚Äù<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">E. Micro-barriers<\/p>\n\r<p class=\"p_Normal\">PAL ensures no CPU continues until the global action is complete.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">üß© 5. Does DRIVERSCHED matter for your emulator?<\/p>\n\r<p class=\"p_Normal\">Mostly no, unless:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You want to emulate VMS or Tru64 kernel-level scheduling behavior, or<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You want to fully support OpenVMS SMP boot.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">But emulator-level consequences are useful:<\/p>\n\r<p class=\"p_Normal\">‚úî When an OS broadcasts TBIA, you must use IPI rendezvous<\/p>\n\r<p class=\"p_Normal\">‚úî When an OS changes scheduling parameters, CPUs must quiesce<\/p>\n\r<p class=\"p_Normal\">‚úî When an OS enters certain critical regions, all CPUs must sync<\/p>\n\r<p class=\"p_Normal\">‚úî Rendezvous is the mechanism for global TLB invalidation<\/p>\n\r<p class=\"p_Normal\">‚úî PAL TBIS\/TBIAP grains cooperate with it<\/p>\n\r<p class=\"p_Normal\">So while DRIVERSCHED itself does not need to be implemented as a separate command, rendezvous semantics absolutely do.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">üß± 6. For EMulatR, how to represent this?<\/p>\n\r<p class=\"p_Normal\">You don‚Äôt need to emulate the actual &quot;DRIVERSCHED&quot; function.<\/p>\n\r<p class=\"p_Normal\">But you must implement:<\/p>\n\r<p class=\"p_Normal\">üìå IPI-based SMP rendezvous API inside IRQController<\/p>\n\r<p class=\"p_Normal\">void sendRendezvousIPI(cpuId);<\/p>\n\r<p class=\"p_Normal\">void broadcastRendezvousIPI();<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">üìå Per-CPU rendezvous flags inside AlphaCPU<\/p>\n\r<p class=\"p_Normal\">std::atomic&lt;bool&gt; inRendezvous;<\/p>\n\r<p class=\"p_Normal\">std::atomic&lt;bool&gt; rendezvousAck;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">üìå Global synchronization barrier<\/p>\n\r<p class=\"p_Normal\">Inside IRQController:<\/p>\n\r<p class=\"p_Normal\">void waitForAllCPUsInRendezvous();<\/p>\n\r<p class=\"p_Normal\">void releaseRendezvous();<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">üìå Use case: TBIA \/ TBIAP<\/p>\n\r<p class=\"p_Normal\">This is the most common rendezvous action:<\/p>\n\r<p class=\"p_Normal\">broadcastIPI(REND_IPI);<\/p>\n\r<p class=\"p_Normal\">waitForAllCPUsInRendezvous();<\/p>\n\r<p class=\"p_Normal\">ev6PteCache.invalidateAll();<\/p>\n\r<p class=\"p_Normal\">releaseRendezvous();<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is how TBIA\/TBIAP really work at OS level.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">üß† 7. Clear one-liner definition<\/p>\n\r<p class=\"p_Normal\">DRIVERSCHED:<\/p>\n\r<p class=\"p_Normal\">A kernel-level rendezvous operation used by OpenVMS and OSF\/1 to synchronize all CPUs while reorganizing scheduling data structures.<\/p>\n\r<p class=\"p_Normal\">Rendezvous:<\/p>\n\r<p class=\"p_Normal\">A PAL-assisted SMP synchronization mechanism ensuring all CPUs enter a safe state before executing global actions like TLB invalidation or scheduling reconfiguration.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If you want next:<\/p>\n\r<p class=\"p_Normal\">I can generate:<\/p>\n\r<p class=\"p_Normal\">‚úî An SMP Rendezvous Layer for IRQController<\/p>\n\r<p class=\"p_Normal\">‚úî A ‚Äúglobal_rendezvous.h‚Äù header using Meyers singleton<\/p>\n\r<p class=\"p_Normal\">‚úî CPU-side logic for entering\/exiting PAL rendezvous<\/p>\n\r<p class=\"p_Normal\">‚úî How TBIA\/TBIAP grains should use rendezvous<\/p>\n\r<p class=\"p_Normal\">Just tell me.<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; width:7.0625rem; padding:0; border:none\"><p class=\"p_Normal\">ReservationManager<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; width:141.6250rem; padding:0; border:none\"><p class=\"p_Normal\">step 1. hostClearReservation(cpuState); \/\/ which calls -&gt; cpuState-&gt;clearReservationSet() -- PAL events like:<\/p>\n\r<p class=\"p_Normal\">HALT<\/p>\n\r<p class=\"p_Normal\">DRAINA<\/p>\n\r<p class=\"p_Normal\">CFLUSH<\/p>\n\r<p class=\"p_Normal\">BPT \/ BUGCHK<\/p>\n\r<p class=\"p_Normal\">EXCB, MB, WMB, MB2<\/p>\n\r<p class=\"p_Normal\">step 2. &nbsp;CPUStateIPRInterface calls clearreservation(cpuid)<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; width:7.0625rem; padding:0; border:none\"><br \/>\n\r<\/td>\n\r<td style=\"vertical-align:top; width:141.6250rem; padding:0; border:none\"><br \/>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; width:7.0625rem; padding:0; border:none\"><br \/>\n\r<\/td>\n\r<td style=\"vertical-align:top; width:141.6250rem; padding:0; border:none\"><br \/>\n\r<\/td>\n\r<\/tr>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Pal counters - when entering pal mode, suspend counter incrementing.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r"
})
