hmLoadTopic({
hmKeywords:"",
hmTitle:"16.4 Asynchronous Device Threading (QThread Model)",
hmDescription:"16.4.1 Threading Architecture  ASA-EmulatR uses Qt\'s QThread framework for all concurrent execution. Each AlphaCPU runs in its own QThread (managed by ExecutionCoordinator), and",
hmPrevLink:"16_3-endianness-and-device-reg.html",
hmNextLink:"16_5-scsi-subsystem.html",
hmParentLink:"chapter-16---device-model--dma.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-16---device-model--dma.html\">Chapter 16 – Device Model &amp; DMA<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 16 – Device Model & DMA > 16.4 Asynchronous Device Threading (QThread Model)",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">16.4 Asynchronous Device Threading (QThread Model)<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">16.4.1 Threading Architecture<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">ASA-EmulatR uses Qt\'s <span class=\"f_CodeExample\">QThread<\/span> framework for all concurrent execution. Each AlphaCPU runs in its own <span class=\"f_CodeExample\">QThread<\/span> (managed by <span class=\"f_CodeExample\">ExecutionCoordinator<\/span>), and device I\/O operations that cannot complete synchronously are dispatched to dedicated device worker threads.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The threading model enforces a strict separation between the CPU execution path and device I\/O:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span><span style=\"font-weight: bold;\">CPU threads<\/span> (one per vCPU) — Execute guest instructions, handle MMIO reads\/writes synchronously, poll for interrupts. MMIO handler calls (<span class=\"f_CodeExample\">onRead<\/span>, <span class=\"f_CodeExample\">onWrite<\/span>) execute in the calling CPU\'s thread and must return immediately.<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span><span style=\"font-weight: bold;\">Device I\/O threads<\/span> (per device or per manager) — Perform host-side disk I\/O, network packet transmission\/reception, DMA data movement, and long-running device operations. These threads are created by the device managers and communicate completion back to the CPU path via interrupt assertion.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The <span class=\"f_CodeExample\">IDeviceEmulator<\/span> contract explicitly specifies that <span class=\"f_CodeExample\">onRead()<\/span> and <span class=\"f_CodeExample\">onWrite()<\/span> must return immediately — they may not block on I\/O. If an MMIO write triggers a long-running operation (e.g., a SCSI command that involves host-side disk access), the device handler queues the work to its I\/O thread and returns <span class=\"f_CodeExample\">MMIOStatus::OK<\/span>. The I\/O thread performs the actual work and asserts an interrupt upon completion.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">16.4.2 I\/O Serialization Within a Device<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Within a single device emulator, I\/O operations must be serialized to preserve command ordering. When multiple vCPUs concurrently access the same device\'s MMIO registers, the device must ensure that:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Register reads and writes are atomic with respect to the device\'s internal state<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Command submission ordering is preserved when one CPU writes a command register that another CPU also targets<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>DMA descriptor reads occur after the CPU\'s writes are visible (enforced by the <span class=\"f_CodeExample\">drainPostedWrites()<\/span> pattern)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Device emulators typically use a <span class=\"f_CodeExample\">QMutex<\/span> to protect their internal register state and a command queue (<span class=\"f_CodeExample\">QQueue<\/span> or ring buffer) to serialize I\/O requests submitted to the worker thread. The worker thread drains the command queue sequentially, performing host-side I\/O for each request.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">16.4.3 Cross-Device Concurrency<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Different device managers operate independently. A SCSI disk I\/O operation does not serialize against a network packet transmission. This concurrency is both intentional and necessary — real Alpha systems execute multiple device operations simultaneously, and guest OS drivers expect this parallelism. The shared resources that require cross-device synchronization are limited to GuestMemory (for DMA), the IRQ system (for interrupt assertion), and the <span class=\"f_CodeExample\">DMACoherencyManager<\/span> (for cache coherency operations).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-9_3-cpu-instantiation-.html\" class=\"topiclink\">9.3 CPU Instantiation and Identity (QThread per CPU)<\/a>; mmioLib\/IDeviceEmulator.h – onRead\/onWrite threading contract.<\/span><\/p>\n\r"
})
