hmLoadTopic({
hmKeywords:"",
hmTitle:"15.4 SparseMemoryBacking – On-Demand Page Allocator",
hmDescription:"SparseMemoryBacking is the physical storage engine behind SafeMemory. It implements on-demand page allocation so that the emulator can declare a 32+ GB address space without...",
hmPrevLink:"15_3-guestmemory-region-suppor.html",
hmNextLink:"15_5-load-and-store-semantics.html",
hmParentLink:"chapter-15---memory-system-imp.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-15---memory-system-imp.html\">Chapter 15 – Memory System Implementation Details<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 15 – Memory System Implementation Details > 15.4 SparseMemoryBacking – On-Demand Page Allocator",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">15.4 SparseMemoryBacking – On-Demand Page Allocator<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\"><span class=\"f_CodeExample\">SparseMemoryBacking<\/span> is the physical storage engine behind SafeMemory. It implements on-demand page allocation so that the emulator can declare a 32+ GB address space without consuming host memory for unused regions.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">15.4.1 Design<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Page size: 64 KB (<span class=\"f_CodeExample\">kPageSize = 64 * 1024<\/span>)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Page table: array of <span class=\"f_CodeExample\">std::atomic&lt;quint8*&gt;<\/span> pointers, one per page<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Pages allocated on first write via <span class=\"f_CodeExample\">ensurePage()<\/span>, which uses <span class=\"f_CodeExample\">compare_exchange_strong<\/span> for thread-safe allocation<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Reads from unallocated pages return zero (no page fault)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>All multi-byte accesses use <span class=\"f_CodeExample\">qFromLittleEndian<\/span> \/ <span class=\"f_CodeExample\">qToLittleEndian<\/span> for correct byte ordering<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Cross-page accesses handled via <span class=\"f_CodeExample\">loadCrossing&lt;T&gt;<\/span> \/ <span class=\"f_CodeExample\">storeCrossing&lt;T&gt;<\/span> template methods<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Optional dirty tracking via atomic bitmap (64 pages per word) for snapshot\/migration support<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">15.4.2 Thread Safety<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The <span class=\"f_CodeExample\">ensurePage()<\/span> method uses a compare-and-swap pattern: it creates a new zeroed page, then atomically attempts to install it. If another thread has already allocated the page (the CAS fails), the duplicate is deleted and the existing page is returned. Page pointer loads use <span class=\"f_CodeExample\">memory_order_acquire<\/span>; stores use <span class=\"f_CodeExample\">memory_order_release<\/span>. The <span class=\"f_CodeExample\">m_allocatedPages<\/span> counter tracks the total resident page count.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">15.4.3 Source Files<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">File<\/span><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Lines (approx)<\/span><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Content<\/span><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">memoryLib\/SparseMemoryBacking.h<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">~507<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Complete class: page allocation, load\/store 8\/16\/32\/64, block ops, dirty tracking, cross-page handling<\/p>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: memoryLib\/MemorySpan.h (~121 lines) – Contiguous span for safe cross-page buffer access; memoryLib\/SafeMemory.h – Consumer of SparseMemoryBacking.<\/span><\/p>\n\r"
})
