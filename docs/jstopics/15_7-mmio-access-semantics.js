hmLoadTopic({
hmKeywords:"",
hmTitle:"15.7 MMIO Access Semantics",
hmDescription:"MMIO accesses are strongly ordered. They are never buffered in the write buffer, execute synchronously, cannot be reordered relative to other MMIO operations, and are visible...",
hmPrevLink:"15_6-write-buffer-implementati.html",
hmNextLink:"15_8-ll_sc-reservation-trackin.html",
hmParentLink:"chapter-15---memory-system-imp.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-15---memory-system-imp.html\">Chapter 15 – Memory System Implementation Details<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 15 – Memory System Implementation Details > 15.7 MMIO Access Semantics",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">15.7 MMIO Access Semantics<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">MMIO accesses are strongly ordered. They are never buffered in the write buffer, execute synchronously, cannot be reordered relative to other MMIO operations, and are visible immediately to device handlers. This is intentional — devices expect program-order semantics even though Alpha allows weak ordering for RAM.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">When GuestMemory routes a PA to <span class=\"f_CodeExample\">RouteTarget::MMIOManager<\/span>, it calls <span class=\"f_CodeExample\">m_mmio-&gt;handleRead(pa, width, outValue)<\/span> or <span class=\"f_CodeExample\">m_mmio-&gt;handleWrite(pa, width, value)<\/span> with the raw PA (not an offset). MMIO accesses bypass SafeMemory entirely. The <span class=\"f_CodeExample\">WriteBufferEntry::mmio<\/span> flag distinguishes MMIO writes in the write buffer for special handling by the CBox, and <span class=\"f_CodeExample\">WriteBufferManager::hasPendingMMIO()<\/span> checks whether a CPU has any pending MMIO stores.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Instruction fetch from MMIO regions is explicitly rejected: <span class=\"f_CodeExample\">readRouted()<\/span> checks for <span class=\"f_CodeExample\">AccessKind::InstructionFetch<\/span> combined with <span class=\"f_CodeExample\">RouteTarget::MMIOManager<\/span> and returns <span class=\"f_CodeExample\">MEM_STATUS::AccessViolation<\/span>.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Invariant:<\/strong> MMIO is strongly ordered, synchronous, and never buffered.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: mmioLib\/mmio_Manager.h – MMIOManager class; <a href=\"chapter-10---devices-and-mmio.html\" class=\"topiclink\">Chapter 10 – Devices and Memory-Mapped I\/O (MMIO)<\/a>.<\/span><\/p>\n\r"
})
