hmLoadTopic({
hmKeywords:"",
hmTitle:"Integration Steps",
hmDescription:"Phase 0 – Freeze the new “truths”  Before touching call-sites, treat these as the canonical interfaces:  Pipeline & slots – AlphaPipeline and PipelineSlot  AlphaPipeline  P",
hmPrevLink:"",
hmNextLink:"",
hmParentLink:"appendix---trait-examples.html",
hmBreadCrumbs:"",
hmTitlePath:"Introduction > Appendix > Appendix I – Global Singletons",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">Integration Steps<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">Phase 0 – Freeze the new “truths”<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Before touching call-sites, treat these as the canonical interfaces:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Pipeline &amp; slots – AlphaPipeline and PipelineSlot<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">AlphaPipeline<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">PipelineSlot now owns:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">pc, raw, valid<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">DecodedInstruction di<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">decoded, executed, faultPending<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">DecodedInstruction \/ InstructionGrain – the slimmed structures you just finalized.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Exception carrier – PendingEvent<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">PendingEvent_refined<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Exception mapping – ExceptionMapping_inl::mapClassToPalVector(const PendingEvent&amp;)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">ExceptionMapping_inl<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Vector table – PalVectorId_refined + PalVectorEntry + PalVectorTable<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Everything else should fold around those.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Phase 1 – InstructionGrain \/ DecodedInstruction integration<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Goal: make every grain and decode path speak the new DecodedInstruction without bloating it.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Lock down DecodedInstruction shape<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Confirm it has only:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">core fields: opcode, function, Ra\/Rb\/Rc, literal, branch displacement, isLoad\/isStore\/isBranch flags, etc.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">your bit-packed flags instead of booleans.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Mark its helpers AXP_ALWAYS_INLINE where they’re on the hot path.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Update the central decode function<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">In the iGrain system, find decodeInstruction() used by AlphaPipeline (stage_EX) and GrainResolver.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">AlphaPipeline<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Make sure:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Input: quint32 raw, quint64 pc (and optionally a “context” for PAL vs native).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Output: a fully filled DecodedInstruction with:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">pre-decoded flags (branch \/ load \/ store \/ CALL_PAL)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">addressing mode classification (literal vs register)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">CALL_PAL index pre-extracted if applicable.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Update all grain execute signatures<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Standardize to something like:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">void execute(const DecodedInstruction&amp; di,<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlphaProcessorContext&amp; ctx);<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">For PAL grains, same idea, but they’ll be handed a context that already knows it’s in PALmode.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Clean up old “legacy” decode accessors<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Remove \/ deprecate:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Raw bit-twiddling in every grain.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Any grain that recomputes Ra\/Rb\/Rc from the raw op – always use di.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This is where most of the “wide implications” will show. Do a quick sweep:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Integer grains<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">FP grains<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Memory grains<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">branch\/misc grains<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Phase 2 – Wire the Boxes cleanly<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You’ve already moved ownership:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">MBox: memory side, PTE staging, SafeMemory attachment, write buffer.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">EBox: integer register file &amp; integer execute.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">AlphaPipeline<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">FBox: FP register file &amp; FPCR.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">IBox: PC pipeline, fetch, dual-issue scheduling, and now the integration point for AlphaPipeline.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Checklist:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Make Box interfaces take DecodedInstruction<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">EBox:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">void executeInteger(const DecodedInstruction&amp; di);<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">FBox:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">void executeFP(const DecodedInstruction&amp; di);<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">MBox:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">void executeMemory(const DecodedInstruction&amp; di);<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">IBox:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Front end: fetch, branch prediction, updating PC.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Back end: called from pipeline’s EX\/MEM to route the grain to the correct box.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Move register banks completely<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Ensure RegisterBankInteger lives only in EBox.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Ensure RegisterBankFP + FPCR live only in FBox.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">MBox should not own them anymore; it should ask EBox\/FBox when needed.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SafeMemory access<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">MBox should be the only place that touches SafeMemory directly.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Other boxes go through MBox for loads\/stores (or the existing load-silo semantics).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Phase 3 – Integrate AlphaPipeline into AlphaCPU<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Goal: AlphaCPU becomes the “traffic cop,” not the execution engine.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">From AlphaPipeline<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">AlphaPipeline<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">step() currently:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">WB → MEM → EX → IS → DE → IF<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">then advanceRing().<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Steps:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Create a member in AlphaCPU<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">class AlphaCPU final : public QObject, public AlphaProcessorContext {<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ ...<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;AlphaPipeline m_pipeline;<\/p>\n\r<p class=\"p_Normal\">};<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Construct it in AlphaCPU ctor:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">AlphaCPU::AlphaCPU(...):<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;QObject(parent),<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;AlphaProcessorContext(cpuId),<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;m_family(family),<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;m_running(false),<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;m_mBox(new MBox(this)),<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;m_eBox(new EBox(this)),<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;m_fBox(new FBox(this)),<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;m_iBox(new IBox(this, m_mBox, m_eBox, m_fBox)),<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;m_pipeline(this, m_iBox)<\/p>\n\r<p class=\"p_Normal\">{}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Implement the main run loop<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">void AlphaCPU::executeNextInstruction()<\/p>\n\r<p class=\"p_Normal\">{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ 1. Check async events (interrupts, AST) and raise PendingEvent if needed.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ 2. If there is a committed PendingEvent, deliver it (enter PAL) and return.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ 3. Otherwise, step the pipeline.<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;m_pipeline.step();<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Connect pipeline stages to boxes<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">In stage_EX():<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">If not decoded: call decodeInstruction() to fill slot.di.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Use slot.di to:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">compute which box to use (integer \/ FP \/ memory \/ control \/ PAL).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">route to EBox, FBox, or MBox (or control path) for actual grain execution.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">In stage_MEM():<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Use MBox if instruction is a load\/store.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">In stage_WB():<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Apply commit semantics, update PC for branches, check for exceptions.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Phase 4 – Exception model + PendingEvent pipeline<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You already have the refined model:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">PendingEvent carrier<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">PendingEvent_refined<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">mapClassToPalVector(const PendingEvent&amp;)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">ExceptionMapping_inl<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">PalVectorId_refined &amp; PalVectorTable::lookup()<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Design spec (as we discussed):<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Creation (pipeline \/ helper)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">When something goes wrong (SafeMemory status, illegal opcode, FEN, etc.), the pipeline does:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">PendingEvent ev;<\/p>\n\r<p class=\"p_Normal\">ev.kind &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = PendingEventKind::Synchronous;<\/p>\n\r<p class=\"p_Normal\">ev.exceptionClass = ExceptionClass::DTB_MISS_SINGLE; \/\/ example<\/p>\n\r<p class=\"p_Normal\">ev.faultVA &nbsp; &nbsp; &nbsp; &nbsp;= faultVA;<\/p>\n\r<p class=\"p_Normal\">ev.asn &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= currentASN;<\/p>\n\r<p class=\"p_Normal\">ev.Property_info.isInstruction = false;<\/p>\n\r<p class=\"p_Normal\">ev.Property_info.faultType &nbsp; &nbsp; = MemoryFaultType::DTB_MISS;<\/p>\n\r<p class=\"p_Normal\">\/\/ extraInfo, etc. as needed<\/p>\n\r<p class=\"p_Normal\">faultDispatcher.setPendingEvent(ev);<\/p>\n\r<p class=\"p_Normal\">slot.faultPending = true;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">No PAL vector chosen here. No PC rewrite here. Just classification.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Preparation (FaultDispatcher)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Somewhere in a helper like preparePendingEventForDelivery(cpuId):<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">void FaultDispatcher::preparePendingEventForDelivery(CPUIdType cpuId)<\/p>\n\r<p class=\"p_Normal\">{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;PendingEvent&amp; ev = m_pending[cpuId];<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;if (!ev.isValid() || ev.isResolved())<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;return;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ 1) Map ExceptionClass -&gt; PalVectorId<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;ev.palVectorId = mapClassToPalVector(ev); \/\/ ExceptionMapping_inl.h<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ 2) Compute entryPC:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;quint64 entryPC = 0;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;if (ev.exceptionClass == ExceptionClass::CALL_PAL &amp;&amp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;ev.palVectorId == PalVectorId::INVALID)<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;\/\/ Hardware CALL_PAL index → PAL_BASE+offset<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;entryPC = calculateCallPalEntryPC(ev.extraInfo \/*CALL_PAL index*\/);<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;else<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;auto&amp; table &nbsp; = globalPALVectorTable();<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;auto* entry &nbsp; = table.lookup(ev.palVectorId);<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;Q_ASSERT(entry != nullptr);<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp; &nbsp; &nbsp;entryPC &nbsp; &nbsp; &nbsp; = entry-&gt;entryPC; \/\/ You’ll later add PAL_BASE<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;ev.extraInfo = entryPC; \/\/ or store separately in a small struct<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ 3) Mark resolved<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;Q_ASSERT(ev.isResolved());<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Delivery (entering PAL via MBox)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">When the pipeline \/ CPU decides to actually take the exception:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">void FaultDispatcher::deliver(CPUIdType cpuId, AlphaProcessorContext&amp; ctx)<\/p>\n\r<p class=\"p_Normal\">{<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;PendingEvent&amp; ev = m_pending[cpuId];<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;if (!ev.isResolved()) return;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ Save faulting PC, PS, etc. into HWPCB\/IPRs here.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;quint64 entryPC = ev.extraInfo; \/\/ or however you carried it<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;const PalVectorEntry* entry = globalPALVectorTable().lookup(ev.palVectorId);<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;PalArgumentPack args{};<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ Fill args from ev, e.g.:<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;\/\/ args.a0 = ev.faultVA; etc.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;ctx.mbox().enterPal(ev.palVectorId, entry, args);<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"> &nbsp; &nbsp;ev.clear();<\/p>\n\r<p class=\"p_Normal\">}<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">MBox::enterPal(...) then:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">saves PC\/PS into HWPCB,<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">sets PALmode in IPRs,<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">forces CM=kernel, updates IPL per PalVectorEntry::targetIPL,<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">loads R16–R20 with PAL args,<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">updates PC to entryPC.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Phase 5 – Hooking pipeline ↔ FaultDispatcher<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Tie it into the stages:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Before each pipeline step (or at WB)<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Ask FaultDispatcher whether there is a ready event for this CPU that should interrupt normal flow:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">For synchronous exceptions:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Only the slot that faulted should cause delivery.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">On detection (slot.faultPending), flush the pipeline, call preparePendingEventForDelivery(), then deliver(), and start fetching from the PAL entry PC.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">For asynchronous (interrupt) events:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">You can check at WB boundary; if pendingInterrupt, you synthesize a PendingEvent with ExceptionClass::INTERRUPT, then prepare + deliver.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Pipeline flush semantics<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">On exception: flush all slots where pc &gt; faulting_pc (simplified: pipeline.flush()).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">On non-exception aborts (branch mispredict, etc.) you also flush, but these do not go through PendingEvent.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The HRM makes the distinction between exceptions (drain pipeline fully) vs non-exception aborts (can restart immediately) – which you already captured in your mental model.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">21264ev6_hrm<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Phase 6 – CALL_PAL and CALLSYS<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Last piece: making CALL_PAL “just another exception class.”<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Decode stage<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">decodeInstruction sets:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">di.isCallPal = true for OPC_CALL_PAL.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">extracts the 7-bit CALL_PAL index, stores in di.callPalIndex.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Execute stage<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">When the pipeline executes a CALL_PAL grain:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">create a PendingEvent:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">PendingEvent ev;<\/p>\n\r<p class=\"p_Normal\">ev.kind &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = PendingEventKind::Synchronous;<\/p>\n\r<p class=\"p_Normal\">ev.exceptionClass = ExceptionClass::CALL_PAL;<\/p>\n\r<p class=\"p_Normal\">ev.extraInfo &nbsp; &nbsp; &nbsp;= di.callPalIndex;<\/p>\n\r<p class=\"p_Normal\">faultDispatcher.setPendingEvent(ev);<\/p>\n\r<p class=\"p_Normal\">slot.faultPending = true;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Don’t directly manipulate PC here – let the exception path handle it.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">CALLSYS \/ system services<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">For OS CALLSYS (e.g., OpenVMS), you can:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">treat them as CALL_PAL with special indices, or<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">classify as ExceptionClass::SystemService and map via mapClassToPalVector to PalVectorId::CALL_CENTRY_BEG, etc., as you’ve already sketched.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Phase 7 – Bring-up plan \/ tests<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">When you start wiring tomorrow, I’d do it in this order:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Compile with all new headers wired:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Fix any obvious type drift (old TrapCode, old PalVectorId enums, etc.).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Trivial program with no exceptions:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">A loop of ADDL, SUBQ, BR to itself.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Validate: pipeline fetches, decodes via new DecodedInstruction, routes through EBox, and keeps PC stable.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Intentional illegal opcode:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Confirm it creates PendingEvent{EC::ILLEGAL_OPCODE}, maps to PalVectorId::OPCDEC, calls enterPal, and branches to your (dummy) OPCDEC PAL entry.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Simple DTB miss:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Use handleDTBMiss.h path to produce a PendingEvent with EC::DTB_MISS_SINGLE and ensure it maps into DTB_MISS_SINGLE.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">CALL_PAL BPT\/GENTRAP:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Issue CALL_PAL 0x80 \/ 0xAA and confirm:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">exceptionClass::CALL_PAL<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">extraInfo == index<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">mapClassToPalVector returns INVALID for generic CALL_PAL but BREAKPOINT \/ GENTRAP for the named ones, as you’ve defined.<\/p>\n\r"
})
