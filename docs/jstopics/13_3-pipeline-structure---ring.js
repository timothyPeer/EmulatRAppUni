hmLoadTopic({
hmKeywords:"Accessor,advanceRing,Arithmetic,Comment,Commit,Constant,Count,cpuCoreLib\/AlphaPipeline.h,DE,Decode,EX,Execute,Fetch,Flow,HeaderFile,IF,Implementation,Index,Index,Instruction,IS,Issue,Line,LogicalIndex,m_head,m_slots,Mapping,MEM,Memory,Modulo,Pipeline,Position,QVarLengthArray,Retirement,RingBuffer,Rotation,Slot,Stage,stage,tick,WB,Work,Writeback",
hmTitle:"13.3 Pipeline Structure - Ring Buffer",
hmDescription:"13.3.1 Stage Constants  static constexpr int STAGE_COUNT = 6; static constexpr int STAGEIF = 0; \/\/ Instruction Fetch (youngest) static constexpr int STAGEDE = 1; \/\/ Decode sta",
hmPrevLink:"13_2-pipeline-role-and-design.html",
hmNextLink:"13_4-pipelineslot-structure.html",
hmParentLink:"alphapipeline-implementation.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"alphapipeline-implementation.html\">Chapter 13 – AlphaPipeline Implementation<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 13 – AlphaPipeline Implementation > 13.3 Pipeline Structure - Ring Buffer",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">13.3 Pipeline Structure - Ring Buffer<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.3.1 Stage Constants<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">static&nbsp;constexpr&nbsp;int&nbsp;STAGE_COUNT&nbsp;=&nbsp;6;<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">static&nbsp;constexpr&nbsp;int&nbsp;STAGEIF&nbsp;=&nbsp;0;&nbsp;\/\/&nbsp;Instruction&nbsp;Fetch&nbsp;(youngest)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">static&nbsp;constexpr&nbsp;int&nbsp;STAGEDE&nbsp;=&nbsp;1;&nbsp;\/\/&nbsp;Decode<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">static&nbsp;constexpr&nbsp;int&nbsp;STAGEIS&nbsp;=&nbsp;2;&nbsp;\/\/&nbsp;Issue<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">static&nbsp;constexpr&nbsp;int&nbsp;STAGEEX&nbsp;=&nbsp;3;&nbsp;\/\/&nbsp;Execute&nbsp;—&nbsp;ALL&nbsp;real&nbsp;work&nbsp;here<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">static&nbsp;constexpr&nbsp;int&nbsp;STAGEMEM&nbsp;=&nbsp;4;&nbsp;\/\/&nbsp;Memory&nbsp;—&nbsp;register&nbsp;writeback<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">static&nbsp;constexpr&nbsp;int&nbsp;STAGEWB&nbsp;=&nbsp;5;&nbsp;\/\/&nbsp;Writeback&nbsp;—&nbsp;store&nbsp;commit,&nbsp;retirement&nbsp;(oldest)<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.3.2 Ring Buffer Implementation<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The pipeline uses a 6-slot circular buffer:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">QVarLengthArray&lt;PipelineSlot,&nbsp;STAGE_COUNT&gt;&nbsp;m_slots;&nbsp;\/\/&nbsp;Physical&nbsp;slots&nbsp;[0..5]<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">int&nbsp;m_head&nbsp;=&nbsp;0;&nbsp;\/\/&nbsp;Index&nbsp;of&nbsp;oldest&nbsp;instruction&nbsp;(always&nbsp;WB)<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The stage() accessor maps logical stage indices to physical ring buffer positions:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">PipelineSlot&amp;&nbsp;stage(int&nbsp;logicalIndex)&nbsp;noexcept&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;return&nbsp;m_slots[(m_head&nbsp;-&nbsp;logicalIndex&nbsp;+&nbsp;STAGE_COUNT)&nbsp;%&nbsp;STAGE_COUNT];<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">}<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Mapping: stage(5\/WB) = m_slots[m_head] (oldest), stage(4\/MEM) = m_slots[(m_head-1+6)%6], stage(3\/EX) = m_slots[(m_head-2+6)%6], stage(2\/IS) = m_slots[(m_head-3+6)%6], stage(1\/DE) = m_slots[(m_head-4+6)%6], stage(0\/IF) = m_slots[(m_head-5+6)%6] (youngest).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">advanceRing() rotates the buffer at the end of each tick: m_head = (m_head + 1) % STAGE_COUNT. This causes each instruction to &quot;flow forward&quot; one stage — IF→DE→IS→EX→MEM→WB.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: cpuCoreLib\/AlphaPipeline.h (ring buffer comments lines 60–190).<\/span><\/p>\n\r"
})
