hmLoadTopic({
hmKeywords:"",
hmTitle:"15.2 GuestMemory vs SafeMemory (Critical Separation)",
hmDescription:"15.2.1 GuestMemory – PA Router and Semantic Authority",
hmPrevLink:"15_1-memory-is-shared_-not-own.html",
hmNextLink:"15_3-guestmemory-region-suppor.html",
hmParentLink:"chapter-15---memory-system-imp.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-15---memory-system-imp.html\">Chapter 15 – Memory System Implementation Details<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 15 – Memory System Implementation Details > 15.2 GuestMemory vs SafeMemory (Critical Separation)",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">15.2 GuestMemory vs SafeMemory (Critical Separation)<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">15.2.1 GuestMemory – PA Router and Semantic Authority<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">GuestMemory<\/span> is the physical address (PA) router. It is the only component that knows physical address mappings. Its responsibilities are to receive load\/store requests, classify each PA to a subsystem, apply routing rules, and return results or faults. GuestMemory does not store raw bytes directly; it delegates all storage to the appropriate subsystem via the routing table.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">GuestMemory classifies each PA exactly once and routes to exactly one subsystem. Subsystems must not re-route or know their own PA mapping. All CPU, DMA, and device accesses go through GuestMemory. The <span class=\"f_CodeExample\">AccessKind<\/span> enumeration distinguishes InstructionFetch, DataRead, DataWrite, DMARead, and DMAWrite operations, enabling policy enforcement such as preventing instruction fetch from MMIO regions.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">15.2.2 SafeMemory – Offset-Based Backing Store<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span class=\"f_CodeExample\">SafeMemory<\/span> is the single source of truth for all writable RAM bytes. It implements a pure offset-based interface with no knowledge of physical addresses. It owns the raw RAM bytes through a <span class=\"f_CodeExample\">SparseMemoryBacking<\/span> instance, performs bounds-checked and alignment-checked reads and writes per Alpha architectural rules (SRM v6.0 Section 6.3.3), and returns <span class=\"f_CodeExample\">MEM_STATUS<\/span> codes for every operation.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SafeMemory is oblivious to CPU identity, SMP ordering, barriers, or reservations. It provides typed access methods (<span class=\"f_CodeExample\">load8\/16\/32\/64<\/span>, <span class=\"f_CodeExample\">store8\/16\/32\/64<\/span>), block operations (<span class=\"f_CodeExample\">readBlock<\/span>, <span class=\"f_CodeExample\">writeBlock<\/span>), and the preferred <span class=\"f_CodeExample\">getSpan()<\/span> method for safe buffer access across page boundaries.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">15.2.3 Separation Summary<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Component<\/strong><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Responsibility<\/strong><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">GuestMemory<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Semantics and policy: PA classification, routing, access kind enforcement, MMIO vs RAM dispatch<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">SafeMemory<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Storage and safety: offset-based reads\/writes, bounds checking, alignment validation, sparse page allocation<\/p>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Invariant:<\/strong> SafeMemory never enforces architecture rules. GuestMemory never stores raw bytes directly.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: memoryLib\/GuestMemory.h (~286 lines) – PA router class; memoryLib\/SafeMemory.h (~253 lines) – Offset-based RAM interface; memoryLib\/GuestMemory.cpp (~431 lines) – Routing implementation; memoryLib\/SafeMemory.cpp (~424 lines) – Storage implementation.<\/span><\/p>\n\r"
})
