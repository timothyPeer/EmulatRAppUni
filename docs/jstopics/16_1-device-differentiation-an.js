hmLoadTopic({
hmKeywords:"",
hmTitle:"16.1 Device Differentiation and Class Hierarchy",
hmDescription:"16.1.1 Device Classes  ASA-EmulatR distinguishes devices by function, bus attachment, and I\/O characteristics. The mmio_DeviceClass enumeration in coreLib\/mmio_core.h provides...",
hmPrevLink:"chapter-16---device-model--dma.html",
hmNextLink:"16_2-mmio-routing-implementati.html",
hmParentLink:"chapter-16---device-model--dma.html",
hmBreadCrumbs:"<a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-16---device-model--dma.html\">Chapter 16 – Device Model &amp; DMA<\/a>",
hmTitlePath:"Introduction > Architecture Overview > Chapter 16 – Device Model & DMA > 16.1 Device Differentiation and Class Hierarchy",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">16.1 Device Differentiation and Class Hierarchy<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">16.1.1 Device Classes<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">ASA-EmulatR distinguishes devices by function, bus attachment, and I\/O characteristics. The <span class=\"f_CodeExample\">mmio_DeviceClass<\/span> enumeration in <span class=\"f_CodeExample\">coreLib\/mmio_core.h<\/span> provides the primary classification:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">enum&nbsp;class&nbsp;mmio_DeviceClass&nbsp;:&nbsp;quint8&nbsp;{<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;INVALID&nbsp;=&nbsp;0,&nbsp;UNKNOWN,<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;Controllers&nbsp;(bus-facing&nbsp;HBAs)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;SCSI_HBA,&nbsp;IDE_CONTROLLER,&nbsp;NIC,<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;Child&nbsp;devices&nbsp;(protocol-level)<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;SCSI_DISK,&nbsp;SCSI_TAPE,&nbsp;SCSI_CDROM,&nbsp;SCSI_CONTROLLER,<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;IDE_DISK,&nbsp;IDE_CDROM,<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;UART_CONSOLE,&nbsp;UART,<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;\/\/&nbsp;Infrastructure<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">&nbsp;HOST_BRIDGE_NODE,&nbsp;BRIDGE<\/span><\/p>\n\r<p class=\"p_CodeExample\"><span class=\"f_CodeExample\">};<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">This enumeration drives template selection in <span class=\"f_CodeExample\">DeviceCatalog<\/span>, MMIO window attribute assignment, interrupt routing policy defaults, and diagnostic identification. The two-tier structure — controllers versus child devices — reflects the physical Alpha bus topology: a SCSI HBA controller sits on the PCI bus with its own MMIO BAR, while individual SCSI disks and tapes are protocol-level entities behind that controller.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">16.1.2 Specialized Device Managers<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Each device category has a dedicated manager responsible for device lifecycle, resource allocation, and bus-specific protocol handling:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<div style=\"text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;\"><table style=\"border:none; border-spacing:0; border-collapse:collapse;\">\n\r<thead>\n\r<tr>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Manager<\/span><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Device Classes<\/span><\/p>\n\r<\/th>\n\r<th style=\"vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;\" scope=\"col\"><p class=\"p_Normal\"><span style=\"font-weight: bold;\">Responsibility<\/span><\/p>\n\r<\/th>\n\r<\/tr>\n\r<\/thead>\n\r<tbody>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">SCSIDeviceManager<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">SCSI_HBA, SCSI_DISK, SCSI_TAPE, SCSI_CDROM<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">SCSI bus topology, LUN enumeration, command routing<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">IDEDeviceManager<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">IDE_CONTROLLER, IDE_DISK, IDE_CDROM<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">IDE channel\/master-slave pairing, PIO\/DMA mode<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">NetworkManager<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">NIC<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Network adapter lifecycle, packet I\/O, MAC addressing<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">FibreDeviceManager<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Fibre Channel \/ FG storage<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">FC fabric topology, port login, FCP command dispatch<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">ConsoleManager<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">UART_CONSOLE, UART<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">Serial console (OPA0), terminal I\/O, SRM console integration<\/p>\n\r<\/td>\n\r<\/tr>\n\r<tr>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\"><span class=\"f_CodeExample\">FirmwareDeviceManager<\/span><\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">ROM, firmware regions<\/p>\n\r<\/td>\n\r<td style=\"vertical-align:top; padding:0; border:solid thin #000000;\"><p class=\"p_Normal\">SRM firmware loading, DMA coordination (~540 lines)<\/p>\n\r<\/td>\n\r<\/tr>\n\r<\/tbody>\n\r<\/table>\n\r<\/div>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Each manager is independently instantiable and registers its devices with the shared <span class=\"f_CodeExample\">MMIOManager<\/span> and IRQ system. This independence means device categories can be developed and validated in isolation — a fully functional SCSI subsystem does not require a working network stack, and vice versa.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">16.1.3 Storage Device Differentiation<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Storage devices in ASA-EmulatR support multiple backing strategies, selectable per device instance:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Direct RAW Partition Access<\/span> — The device emulator maps a host-side raw disk partition (or raw disk image file) directly as the guest storage medium. Reads and writes translate 1:1 to host-side block I\/O. This mode provides the highest fidelity to real hardware behavior and is the preferred mode for production guest OS installations. RAW access implies no metadata overhead and no container format translation.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">File System Container<\/span> — The guest disk is stored as a container file on the host file system (e.g., a flat image file or a structured container with embedded metadata). This mode supports snapshot-friendly workflows, easier backup, and host-side inspection. The container format includes a header describing geometry, sector size, and optional compression. Access goes through the host file system, which adds latency but enables portability across host platforms.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><span style=\"font-weight: bold;\">Fibre Channel \/ FG Storage<\/span> — Fibre Channel devices present storage via the FCP (Fibre Channel Protocol) command set. The <span class=\"f_CodeExample\">FibreDeviceManager<\/span> emulates FC port login, fabric topology, and FCP command routing. Backing storage may be either RAW or container, but the guest sees an FC-attached LUN with FC-specific inquiry data and error recovery semantics. This path is structurally complete at the manager level but requires further FCP command coverage.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">All three modes present the same SCSI or IDE command interface to the guest — the backing strategy is transparent to guest software. The device manager selects the appropriate host-side I\/O path based on configuration in <span class=\"f_CodeExample\">ASA-EmulatR.ini<\/span>.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: mmioLib\/IDeviceEmulator.h (~266 lines) – Device interface contract; coreLib\/mmio_core.h (~405 lines) – mmio_DeviceClass enumeration, MMIOWindow attributes; mmioLib\/mmio_DeviceCatalog.h (~130 lines) – Template database.<\/span><\/p>\n\r"
})
