hmLoadTopic({
hmKeywords:"Barrier,CALL_PAL,CBox,Completion,Drain,EX,EXCB,Flush,GlobalVisibility,Grain,HW_REI,MB,MEM,memoryBarrierCompleted,MemoryBarrierCoordinator,needsMemoryBarrier,needsWriteBufferDrain,Ordering,PAL_CALL,PipelineAction,Serialization,SMP,stage_EX,stage_MEM,stage_WB,Stall,TRAPB,WB,WMB,WriteBuffer,writeBufferDrained",
hmTitle:"13.9 Serialization and Barriers in Pipeline",
hmDescription:"13.9.1 Barrier Instruction Pipeline Behavior  Barrier instructions (MB, WMB, EXCB, TRAPB) do not execute computational work — they enforce ordering. In stage_EX(), the grain...",
hmPrevLink:"13_8-flush-semantics.html",
hmNextLink:"13_10-exception-precision.html",
hmParentLink:"alphapipeline-implementation.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"alphapipeline-implementation.html\">Chapter 13 – AlphaPipeline Implementation<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 13 – AlphaPipeline Implementation > 13.9 Serialization and Barriers in Pipeline",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">13.9 Serialization and Barriers in Pipeline<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.9.1 Barrier Instruction Pipeline Behavior<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Barrier instructions (MB, WMB, EXCB, TRAPB) do not execute computational work — they enforce ordering. In stage_EX(), the grain sets the appropriate stall flag. In stage_MEM(), the flag is checked: if the barrier has not completed, the slot stalls.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">MB (Memory Barrier)<\/strong> — sets slot.needsMemoryBarrier = true. Requires global visibility: all prior stores must be visible to all CPUs. CBox coordinates with MemoryBarrierCoordinator, which in SMP configurations ensures all CPUs acknowledge the barrier. This is the most expensive barrier — it may stall for multiple cycles while cross-CPU coordination completes.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">WMB (Write Memory Barrier)<\/strong> — sets slot.needsWriteBufferDrain = true. Requires local write ordering only: all prior stores must drain from the local write buffer. No cross-CPU coordination is needed. CBox sets writeBufferDrained = true when the local write buffer is empty.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">EXCB (Exception Barrier)<\/strong> — sets slot.needsMemoryBarrier = true. Requires all prior instructions to complete and all pending exceptions to be resolved before any younger instruction issues. Uses the same stall mechanism as MB but the completion condition is exception resolution rather than store visibility.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">TRAPB (Trap Barrier)<\/strong> — sets slot.needsMemoryBarrier = true. Requires all prior instructions that may generate arithmetic traps to have completed. Specifically targets floating-point trap completion. Uses the same stall path as EXCB.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.9.2 Barrier Completion<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">CBox is responsible for completing all barriers. The pipeline never self-clears a barrier flag. The completion path: CBox evaluates the barrier condition on each tick, and when satisfied, sets the completion flag (memoryBarrierCompleted or writeBufferDrained) on the stalled slot. On the next tick, stage_MEM() finds the flag set, performs commitPending() normally, and the slot advances to WB.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">13.9.3 Serialization Points<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">CALL_PAL<\/strong> is the strongest serialization point. It is detected in stage_WB() and triggers PipelineAction::PAL_CALL, which causes AlphaCPU to flush the entire pipeline, drain all write buffers, clear LL\/SC reservations, and enter PAL mode. No instruction survives a CALL_PAL boundary in either direction.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">HW_REI<\/strong> is the corresponding exit serialization point. It flushes the pipeline, restores context from EXC_ADDR, clears PAL mode (PC bit 0), and clears LL\/SC reservations. No speculative instruction from PAL mode survives into normal execution.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Together, CALL_PAL and HW_REI form a hard boundary: the pipeline is fully drained on entry and fully drained on exit. This is architecturally required — PAL mode operates with shadow registers and privileged state that must not leak across the boundary.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter-6---serialization-and-.html\" class=\"topiclink\">Chapter 6 - Serialization and Stall Model<\/a> ; <a href=\"chapter-15---memory-system-imp.html\" class=\"topiclink\">Chapter 15 – Memory System Implementation Details<\/a> (MemoryBarrierCoordinator); <a href=\"chapter-20---boot-sequence_-pa.html\" class=\"topiclink\">Chapter 20 – Boot Sequence, PAL, and SRM Integration<\/a> (CALL_PAL\/HW_REI serialization).<\/span><\/p>\n\r"
})
