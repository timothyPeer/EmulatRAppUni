hmLoadTopic({
hmKeywords:"",
hmTitle:"18.8 Precise Exception Guarantees",
hmDescription:"18.8.1 Architectural Guarantees  When an exception is delivered, the following guarantees hold: all prior instructions have completed (every instruction older than the faulting...",
hmPrevLink:"18_7-pal-mode-entry.html",
hmNextLink:"18_9-barrier-interaction.html",
hmParentLink:"chapter-18---fault-dispatcher-.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-18---fault-dispatcher-.html\">Chapter 18 – Fault Dispatcher &amp; Precise Exceptions<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 18 – Fault Dispatcher & Precise Exceptions > 18.8 Precise Exception Guarantees",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">18.8 Precise Exception Guarantees<\/span><\/h1>\n\r",
hmBody:"<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">18.8.1 Architectural Guarantees<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">When an exception is delivered, the following guarantees hold: all prior instructions have completed (every instruction older than the faulting instruction has retired through WB), the faulting instruction is identified (EXC_ADDR holds the faulting PC), no later instruction has executed (younger pipeline slots are invalidated), and architectural state is consistent (register files, memory, and IPRs reflect only committed results).<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">18.8.2 Pipeline Flush Semantics<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">When delivering an exception from WB stage, the pipeline performs:<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span><span class=\"f_CodeExample\">flushYoungerSlots()<\/span> — clears all instructions younger than the faulting instruction, preserving older instructions that have already committed<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Write buffers are drained if required (barrier-like behavior)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>LL\/SC reservations are cleared via <span class=\"f_CodeExample\">ReservationManager::breakReservation(cpuId)<\/span><\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Speculative state is discarded (no speculative register writes survive)<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>EXC_ADDR is set to the faulting PC<\/p>\n\r<p class=\"p_Normal\" style=\"text-indent: 0; padding-left: 0.8125rem; margin-left: 0;\"><span class=\"f_Normal\" style=\"font-family: Arial,\'Lucida Sans Unicode\',\'Lucida Grande\',\'Lucida Sans\';display:inline-block;width:0.8125rem;margin-left:-0.8125rem\">&#8226;<\/span>Control transfers to PAL via <span class=\"f_CodeExample\">enterPalMode()<\/span><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">The pipeline guarantees determinism: in-order retirement (<span class=\"f_CodeExample\">m_instructionsRetired<\/span> increments monotonically), one architectural commit per cycle, no speculative side effects (stores only commit in WB, registers only write in MEM via committed pending), and no privilege leakage.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<hr style=\"height:1px; color:#000000; border-width:0; background-color:#000000;\" \/><p class=\"p_Normal\">&nbsp;<\/p>\n\r<h2 class=\"p_Heading2\" style=\"page-break-after: avoid;\"><span class=\"f_Heading2\">18.8.3 Memory Fault Prevention of Partial Effects<\/span><\/h2>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Memory faults may occur during address translation (TLB miss), access permission checks, alignment checks, MMIO routing (unmapped PA), or bus errors. The <span class=\"f_CodeExample\">MEM_STATUS<\/span> enumeration in <span class=\"f_CodeExample\">memory_core.h<\/span> defines all possible return codes: <span class=\"f_CodeExample\">Ok<\/span>, <span class=\"f_CodeExample\">OutOfRange<\/span>, <span class=\"f_CodeExample\">Misaligned<\/span>, <span class=\"f_CodeExample\">TlbMiss<\/span>, <span class=\"f_CodeExample\">AccessViolation<\/span>, <span class=\"f_CodeExample\">BusError<\/span>, <span class=\"f_CodeExample\">WriteProtected<\/span>, <span class=\"f_CodeExample\">TranslationFault<\/span>, and others.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Faults are raised during the EX stage and prevent memory effects from committing. The <span class=\"f_CodeExample\">PermissionDetail<\/span> enumeration provides fine-grained fault classification for read, write, and execute permission failures at each privilege level, plus Fault-On-Write, Fault-On-Read, and Fault-On-Execute for demand-paging support.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Invariant:<\/strong> Faults prevent partial effects. No memory operation may partially commit. A faulting store never reaches SafeMemory. A faulting load never writes a result to the register file.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"15_11-memory-fault-handling.html\" class=\"topiclink\">15.11 Memory Fault Handling<\/a>; <a href=\"13_12-ll_sc-and-determinism.html\" class=\"topiclink\">13.12 LL\/SC and Determinism<\/a>; memoryLib\/memory_core.h – MEM_STATUS, PermissionDetail enumerations.<\/span><\/p>\n\r"
})
