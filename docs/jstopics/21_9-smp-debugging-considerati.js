hmLoadTopic({
hmKeywords:"",
hmTitle:"21.9 SMP Debugging Considerations",
hmDescription:"SMP debugging introduces challenges that do not exist in single-CPU configurations. Each CPU has an independent trace stream. There is no implicit global serialization for...",
hmPrevLink:"21_8-deterministic-replay.html",
hmNextLink:"21_10-architectural-invariants.html",
hmParentLink:"chapter-21---debugging_-tracin.html",
hmBreadCrumbs:"<a href=\"license-_-attributions.html\">ASA-EMulatR Reference Guide<\/a> &gt; <a href=\"index.html\">Introduction<\/a> &gt; <a href=\"architecture-overview.html\">Architecture Overview<\/a> &gt; <a href=\"chapter-21---debugging_-tracin.html\">Chapter 21 – Debugging, Tracing, and Determinism<\/a>",
hmTitlePath:"ASA-EMulatR Reference Guide > Introduction > Architecture Overview > Chapter 21 – Debugging, Tracing, and Determinism > 21.9 SMP Debugging Considerations",
hmHeader:"<h1 class=\"p_Heading1\" style=\"page-break-after: avoid;\"><span class=\"f_Heading1\">21.9 SMP Debugging Considerations<\/span><\/h1>\n\r",
hmBody:"<p class=\"p_Normal\">SMP debugging introduces challenges that do not exist in single-CPU configurations. Each CPU has an independent trace stream. There is no implicit global serialization for debugging — global ordering must be reconstructed from per-CPU timestamps. Cross-CPU events (IPIs, barrier synchronization, TLB shootdowns, reservation invalidations) are correlated explicitly through CPU ID tagging in all log entries.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\"><strong style=\"font-weight: bold;\">Recommended SMP debugging practices:<\/strong><\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">Always identify CPU ID in logs — every DEBUG_LOG in CBox, FaultDispatcher, ReservationManager, and barrier coordination includes the CPU identifier. Track reservation creation and invalidation — <span class=\"f_CodeExample\">ReservationManager<\/span> logs <span class=\"f_CodeExample\">setReservation()<\/span> and <span class=\"f_CodeExample\">breakReservationsOnCacheLine()<\/span> with cache line addresses and CPU IDs. Log barrier stall and release events — CBox logs barrier kind, stall entry, and release; <span class=\"f_CodeExample\">MemoryBarrierCoordinator<\/span> logs initiation, acknowledgment count, and timeout. Trace IPIs and acknowledgments — <span class=\"f_CodeExample\">IPIManager<\/span> tracks <span class=\"f_CodeExample\">totalCount<\/span> per CPU; IPI send\/receive is logged with command type and target CPU. Verify TLB invalidation paths — <span class=\"f_CodeExample\">handleTLBShootdownIPI()<\/span> logs the invalidation command, VA, and ASN on receipt.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_Normal\">SMP ordering differences between runs are intentional when deterministic scheduling mode is disabled. When deterministic mode is enabled, SMP execution is fully reproducible. MMIO bugs are ordering bugs until proven otherwise — always trace device MMIO reads\/writes with CPU ID and correlate with barrier events.<\/p>\n\r<p class=\"p_Normal\">&nbsp;<\/p>\n\r<p class=\"p_SeeAlso\" style=\"page-break-after: avoid;\"><span class=\"f_SeeAlso\">See Also: <a href=\"chapter9-smparchitecture.html\" class=\"topiclink\">Chapter 9 - SMP Architecture<\/a> (SMP execution model); <a href=\"11_9-debugging-and-observabili.html\" class=\"topiclink\">11.9 Debugging and Observability Invariants<\/a> &nbsp;(normative debugging requirements).<\/span><\/p>\n\r"
})
