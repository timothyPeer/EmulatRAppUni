<!DOCTYPE html>
<html>
<head>
   <title>ASA-EMulatR Reference Guide &gt; Introduction &gt; Appendix &gt; Appendix H - Alpha Pipeline &nbsp;&gt; H.2 - Pipeline Retirement Mechanics</title>
   <meta name="viewport" content="width=device-width, initial-scale=1">
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />   
   <meta http-equiv="X-UA-Compatible" content="IE=edge" />
   <meta name="generator" content="Help &amp; Manual" />
   <meta name="keywords" content="AlphaCPU,AlphaPipeline,Architectural,BoxResult,BranchPredictor,branchTaken,breakReservationsOnCacheLine,CALL_PAL,clearDirty,clearIPRStaging,clearMissStaging,Commit,commitInstruction,commitPending,commitPrevious,computeCallPalEntry,Correctness,Cycle,Deferred,deferWriteback,Discard,EBox,enterPal,EX,EXC_ADDR,Exception,EXECTRACE_WB_RETIRE,Fault,faultDispatched,faultPC,faultPending,faultVA,FBox,Flush,flushYoungerSlots,fpClearDirty,fpReg,fpValid,fpValue,GuestMemory,HW_REI,ILLEGAL_INSTRUCTION,InOrder,intClearDirty,intReg,intValid,intValue,Invariant,Irreversible,LLSC,m_instructionsRetired,m_pending,m_totalCycles,MBox,MEM,Ordering,PAL_CALL,palFunction,palVector,payLoad,PendingCommit,Pipeline,PipelineAction,PipelineSlot,PipelineStepResult,Precise,Register,Reservation,Retire,Retirement,S_Store,SafeMemory,Scoreboard,Serialization,slotSequence,SMP,Squash,stage_EX,stage_MEM,stage_WB,Store,trapCode,updatePrediction,valid,WB,Writeback" />
   <meta name="description" content="Pipeline retirement is the architectural commit point — the moment an instruction's effects become permanently visible to all observers. This appendix provides the..." />
   <link type="text/css" href="default.css" rel="stylesheet" />
   <link type="text/css" href="custom.css" rel="stylesheet" />

   <style TYPE="text/css" media="screen"> 
      html, body { margin:0; 
        padding:0; 
        background: #ffffff; 
      } 
      div#printheader { display: none; }
      #idheader { 
        width:100%; 
        min-height: 60px; 
        padding: 0; 
        margin: 0;
        position: fixed;
        top: 0;
        background: #2C5D88;
        z-index: 2;
      } 
      /* The "min-height" for "#idheader table" ensures that the (blue) header of the topic
         has at least the same height as the header of the navigation panel left of it */
      #idheader table { min-height: 59px;}             
      #idheader h1 span { color: #FFF }     
      #idnav {
        text-align: right;
        width: 158px;
        vertical-align: middle;        
      } 
      #idnav a { text-decoration: none }
      #idnav span {
        display: inline-block;
        width: 24px;
        height: 24px;
        margin-left: 4px;
        background:url('hm_webhelp_buttons_grey.png') top left no-repeat;
      } 
      #idnav a span {
        background-image:url('hm_webhelp_buttons_white.png');
      } 
      #idnav a span:hover {
        background-image:url('hm_webhelp_buttons_orange.png');
      } 
      #idnav span.hmbtnprev { background-position: 0 -32px }
      #idnav span.hmbtnnext { background-position: -24px -32px }
      #idnav span.hmbtntop  { background-position: -48px -32px }
      #idnav span.hmbtntoggle  { width: 20px; background-position: -70px -32px }
      #idnav span.hmbtnprint  { background-position: -88px -32px }

      #callout-table, #overview-table {display:block; position:relative; top:0; left:0;}
      #callout-icon {display:block; position:absolute; top:-11px; left:-11px;}
      #callout-icon-flag {display:block; position:absolute; top:-11px; left:-8px;}
      #callout-table a {text-decoration: none; color: blue;}
      #callout-table a:visited {text-decoration: none; color: blue;}
      #overview-table a {text-decoration: none; color: black;}
      #overview-table a:visited {text-decoration: none; color: black;}
      #callout-table a:hover, #overview-table a:hover {text-decoration: underline;}       
      p.help-url { margin: 20px 0 5px 0; text-align: center; }
	  p.help-url a:link { font-size: 50%; text-decoration: none; color: black; }
	  p.help-url a:visited { color: black; }
	  p.help-url a:hover { font-size: 95%; text-decoration: underline; }
      #switchtoggles { text-align: right; padding: 0 2px 0 0; font-size: 90%; } 
      .sync-toc { color: #FFF; font-size: 8pt; font-weight: bold; display: none; }
      .sync-toc a { color: #FFF; text-decoration: none; font-weight: bold;}
      .sync-toc a:visited { color: #FFF; }
      .sync-toc a:hover { text-decoration: underline; }
	  a#printbuttonlink { cursor: pointer; }
      a.hmanchor { display: inline-block; margin-top: -4em; padding-top: 4em; }  
   </style>
   <style TYPE="text/css" media="print">
      div#idheader, img.dropdown-toggle-icon, p.help-url { display:none } 
   </style>
   
   <script type="text/javascript" src="jquery.js"></script>
   <script type="text/javascript" src="helpman_settings.js"></script>
   <script type="text/javascript" src="helpman_topicinit.js"></script>

   <script type="text/javascript">
     HMSyncTOC("index.html", "appendix-k----pipeline-retirem.html");
   </script>
   <script type="text/javascript" src="highlight.js"></script>
   <script type="text/javascript">
     $(document).ready(function(){highlight();});
   </script>
</head>
<body>


<div id="printheader"><h1 class="p_Heading1" style="page-break-after: avoid;"><span class="f_Heading1">Appendix K – Pipeline Retirement Mechanics</span></h1>
</div>
<div id="idheader">
<div id="idheaderbg">
<table style="width:100%;border:none;margin:0px;" cellspacing="0" cellpadding="0"> 
  <tr>
    <td class="topichead" style="text-align:left; vertical-align:middle">
      <p class="sync-toc">&lt;&lt; <a rel="nofollow" href="index.html?appendix-k----pipeline-retirem.html" target="_top">Click to Display Table of Contents</a> &gt;&gt;</p>
      <p class="crumbs"><b>Navigation:</b>&nbsp;
      
      <a href="license-_-attributions.html">ASA-EMulatR Reference Guide</a> &gt; <a href="introduction.html">Introduction</a> &gt; <a href="appendix---trait-examples.html">Appendix</a> &gt; <a href="appendixh-alphapipeline.html">Appendix H - Alpha Pipeline&nbsp;</a>&nbsp;&gt;</p>
   
      <h1 class="p_Heading1" style="page-break-after: avoid;"><span class="f_Heading1">Appendix K – Pipeline Retirement Mechanics</span></h1>

    </td>
    <td class="topichead" id="idnav">
      
      <a href="b_1---pipeline-cycle-mechanics.html" title="Previous Topic"><span class="hmbtnprev"></span></a>
      <a href="appendixh-alphapipeline.html" title="Parent Chapter"><span class="hmbtntop"></span></a>
      <a href="appendix-c---glossary-and-acro.html" title="Next Topic"><span class="hmbtnnext"></span></a>
      <a id="printbuttonlink" onclick=";$('div#idcontent').css('margin-top', '1em');printTopic();$('#idcontent').css('margin-top', $('#idheader').height());" title="Print"><span class="hmbtnprint"></span></a>
    </td>
  </tr>  
</table>
</div>
</div>  

<div id="idcontent"><div id="innerdiv">
<!-- Ask Internet Explorer 6.users to update their obsolete and dangerous browser --> 
<!--[if lt IE 7]><div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;'><a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://storage.ie6countdown.com/assets/100/images/banners/warning_bar_0000_us.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today." /></a></div><![endif]-->

<!--ZOOMRESTART-->
<p class="p_Normal">Pipeline retirement is the architectural commit point — the moment an instruction's effects become permanently visible to all observers. This appendix provides the authoritative reference for the retirement contract, the deferred writeback mechanism, and the three retirement outcomes (normal commit, fault delivery, PAL transfer). Chapter 13.6.6 describes the stage_WB() execution order; this appendix explains why each step exists and what invariants it preserves.</p>
<p class="p_Normal">&nbsp;</p>
<hr style="height:1px; color:#000000; border-width:0; background-color:#000000;" /><p class="p_Normal">&nbsp;</p>
<h2 class="p_Heading2" style="page-break-after: avoid;"><span class="f_Heading2">K.1 What &quot;Architecturally Committed&quot; Means</span></h2>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">An instruction is architecturally committed when all three conditions hold:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Visible</span> — the instruction's register writes are in the architectural register file, and its store (if any) is in SafeMemory. Any subsequent instruction reading the same register or memory address will observe the committed value.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Irreversible</span> — the instruction's effects cannot be undone by any future pipeline event (flush, fault, interrupt). Once committed, the instruction is part of the permanent execution history.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Precise</span> — all instructions older than this one have already committed (in program order). No instruction younger than this one has committed. The PC reflects the committed instruction stream exactly.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Retirement is the only point where these three conditions become true simultaneously. Prior to retirement, an instruction's results are speculative — they may be discarded on flush.</p>
<p class="p_Normal">&nbsp;</p>
<hr style="height:1px; color:#000000; border-width:0; background-color:#000000;" /><p class="p_Normal">&nbsp;</p>
<h2 class="p_Heading2" style="page-break-after: avoid;"><span class="f_Heading2">K.2 Deferred Writeback — The PendingCommit Mechanism</span></h2>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">The problem:</span> When a grain executes in stage_EX(), it produces a result (slot.payLoad). That result must eventually reach the architectural register file. But writing immediately in EX would violate precise exceptions — if the instruction later faults (or a younger instruction faults first), the register write cannot be undone.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">The solution:</span> Deferred writeback. The result is captured in a PendingCommit structure and written to the register file one stage later, in stage_MEM(), via commitPending(). This separates result production (EX) from result publication (MEM), allowing faults to discard uncommitted results.</p>
<p class="p_Normal">&nbsp;</p>
<h2 class="p_Heading2" style="page-break-after: avoid;"><span class="f_Heading2">K.2.1 PendingCommit Structure</span></h2>
<p class="p_Normal">&nbsp;</p>
<p class="p_CodeExample"><span class="f_CodeExample">struct&nbsp;PendingCommit&nbsp;{</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;bool&nbsp;intValid{false};&nbsp;//&nbsp;Integer&nbsp;result&nbsp;pending</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;quint8&nbsp;intReg{0};&nbsp;//&nbsp;Destination&nbsp;register&nbsp;index</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;quint64&nbsp;intValue{0};&nbsp;//&nbsp;Result&nbsp;value</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;bool&nbsp;intClearDirty{false};&nbsp;//&nbsp;Clear&nbsp;EBox&nbsp;scoreboard&nbsp;on&nbsp;commit</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;bool&nbsp;fpValid{false};&nbsp;//&nbsp;FP&nbsp;result&nbsp;pending</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;quint8&nbsp;fpReg{0};&nbsp;//&nbsp;Destination&nbsp;register&nbsp;index</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;quint64&nbsp;fpValue{0};&nbsp;//&nbsp;Result&nbsp;value</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;bool&nbsp;fpClearDirty{false};&nbsp;//&nbsp;Clear&nbsp;FBox&nbsp;scoreboard&nbsp;on&nbsp;commit</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">};</span></p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">PendingCommit holds at most one integer result and one FP result. The intClearDirty/fpClearDirty flags trigger scoreboard cleanup on commit — when the register file is written, the corresponding box's dirty bit is cleared, signaling that the register is no longer in-flight.</p>
<p class="p_Normal">&nbsp;</p>
<h2 class="p_Heading2" style="page-break-after: avoid;"><span class="f_Heading2">K.2.2 Deferred Writeback Lifecycle</span></h2>
<p class="p_Normal">&nbsp;</p>
<p class="p_CodeExample"><span class="f_CodeExample">Cycle&nbsp;N:</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;stage_EX&nbsp;executes&nbsp;instruction&nbsp;A&nbsp;→&nbsp;grain&nbsp;produces&nbsp;result</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;deferWriteback()&nbsp;captures&nbsp;result&nbsp;into&nbsp;m_pending</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;m_pending.intValid&nbsp;=&nbsp;true</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;m_pending.intReg&nbsp;=&nbsp;destReg</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;m_pending.intValue&nbsp;=&nbsp;slot.payLoad</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">Cycle&nbsp;N+1:</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;commitPending()&nbsp;writes&nbsp;A's&nbsp;result&nbsp;→&nbsp;register&nbsp;file&nbsp;updated</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;m_intRegs-&gt;write(intReg,&nbsp;intValue)</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;m_eBox-&gt;clearDirty(intReg)</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;m_pending.intValid&nbsp;=&nbsp;false</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;stage_EX&nbsp;executes&nbsp;instruction&nbsp;B&nbsp;→&nbsp;reads&nbsp;correct&nbsp;value&nbsp;from&nbsp;A</span></p>
<p class="p_CodeExample"><span class="f_CodeExample">&nbsp;deferWriteback()&nbsp;captures&nbsp;B's&nbsp;result&nbsp;into&nbsp;m_pending</span></p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Critical ordering invariant:</span> commitPending() runs at the top of stage_WB(), which executes before stage_EX() in the same cycle (reverse stage order: WB→MEM→EX→IS→DE→IF). This guarantees that the previous cycle's deferred result is visible in the register file before the current cycle's instruction reads registers. No forwarding logic is needed. No pipeline stalls for RAW hazards.</p>
<p class="p_Normal">&nbsp;</p>
<h2 class="p_Heading2" style="page-break-after: avoid;"><span class="f_Heading2">K.2.3 Writeback Paths</span></h2>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">deferWriteback() handles three distinct writeback paths:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Link register (BSR/JSR)</span> — Ra = PC + 4. The return address is computed from the slot's instruction PC and written to the link register.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Integer/FP result</span> — slot.payLoad written to the destination register identified by the decoded instruction. The destination type (integer vs FP) is determined by <span class="f_CodeExample">destIsFloat(slot.di)</span>.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">No writeback</span> — stores, branches (without link), barriers, and instructions writing to R31/F31 produce no register result. deferWriteback() is a no-op for these.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">PAL instructions</span> bypass the deferred writeback mechanism entirely. CALL_PAL is detected in stage_WB() before commitPrevious() would apply — the pending result from a younger instruction is discarded. PAL functions that modify registers do so directly through PalBox, which writes architectural state as part of the PAL function execution.</p>
<p class="p_Normal">&nbsp;</p>
<hr style="height:1px; color:#000000; border-width:0; background-color:#000000;" /><p class="p_Normal">&nbsp;</p>
<h2 class="p_Heading2" style="page-break-after: avoid;"><span class="f_Heading2">K.3 The stage_WB() Retirement Sequence</span></h2>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">stage_WB() executes a strict seven-step sequence. The ordering is architecturally significant — reordering any step would break correctness.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Step 0 — commitPending().</span> Writes the deferred register result from the previous cycle to the architectural register file. This runs unconditionally, before the slot validity check. The pending result is from a different (older) instruction that already passed its own fault checks in EX. That instruction's result is architecturally valid regardless of what happens to the instruction currently in WB.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Step 1 — Slot validity check.</span> If (!slot.valid), return. An empty slot produces no retirement.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Step 2 — Fault check (highest priority).</span> If slot.faultPending is true: discard m_pending (the younger instruction in MEM is squashed — its deferred result must never reach the register file), set PipelineAction::FAULT with trapCode/faultVA/faultPC, invalidate the slot, return immediately. The fault propagates to AlphaCPU via BoxResult::faultDispatched(), which triggers enterPal().</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Step 3 — CALL_PAL check (before store commit).</span> If isCallPal(slot.di): discard m_pending (pipeline serializes — all younger instructions will be flushed), compute PAL entry vector via <span class="f_CodeExample">computeCallPalEntry(m_cpuId, palFunction)</span>, set PipelineAction::PAL_CALL with palFunction/callPC/palVector, invalidate the slot, return. AlphaCPU flushes the entire pipeline and enters PAL mode.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Step 4 — Store commit.</span> If the instruction has store semantics (S_Store): <span class="f_CodeExample">m_guestMemory→write64(slot.pa, slot.payLoad)</span>, then <span class="f_CodeExample">m_reservationManager→breakReservationsOnCacheLine(slot.pa)</span>. This is the only point where store data reaches SafeMemory. Stores that faulted (Step 2) or were superseded by CALL_PAL (Step 3) never reach this step.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Step 5 — Branch predictor update.</span> If slot.branchTaken: <span class="f_CodeExample">m_cBox→updatePrediction(slot.di.pc, slot.branchTaken, slot.branchTarget)</span>. Predictor training occurs at retirement to ensure only committed branch outcomes update the predictor. Speculative branches that were flushed never train the predictor.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Step 6 — Retirement.</span> commitInstruction(slot): increment m_instructionsRetired, update m_totalCycles, emit EXECTRACE_WB_RETIRE. This is the permanent record of the instruction's execution.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Step 7 — Cleanup.</span> slot.valid = false, slot.clear(). The slot is recycled for the next instruction entering the pipeline.</p>
<p class="p_Normal">&nbsp;</p>
<hr style="height:1px; color:#000000; border-width:0; background-color:#000000;" /><p class="p_Normal">&nbsp;</p>
<h2 class="p_Heading2" style="page-break-after: avoid;"><span class="f_Heading2">K.4 The Three Retirement Outcomes</span></h2>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Every instruction that reaches stage_WB() with slot.valid = true produces exactly one of three outcomes. There is no fourth case.</p>
<p class="p_Normal">&nbsp;</p>
<div style="text-align: left; text-indent: 0; padding: 0 0 0 0; margin: 0 0 0 0;"><table style="border:none; border-spacing:0; border-collapse:collapse;">
<thead>
<tr>
<th style="vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;" scope="col"><p class="p_Normal"><span style="font-weight: bold;">Outcome</span></p>
</th>
<th style="vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;" scope="col"><p class="p_Normal"><span style="font-weight: bold;">PipelineAction</span></p>
</th>
<th style="vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;" scope="col"><p class="p_Normal"><span style="font-weight: bold;">PendingCommit</span></p>
</th>
<th style="vertical-align:top; background-color:#00FFFF; padding:0; border:solid thin #000000;" scope="col"><p class="p_Normal"><span style="font-weight: bold;">Pipeline Effect</span></p>
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align:top; padding:0; border:solid thin #000000;"><p class="p_Normal">Fault</p>
</td>
<td style="vertical-align:top; padding:0; border:solid thin #000000;"><p class="p_Normal">FAULT</p>
</td>
<td style="vertical-align:top; padding:0; border:solid thin #000000;"><p class="p_Normal">Discarded (younger squashed)</p>
</td>
<td style="vertical-align:top; padding:0; border:solid thin #000000;"><p class="p_Normal">Full flush, enter PAL at fault vector</p>
</td>
</tr>
<tr>
<td style="vertical-align:top; padding:0; border:solid thin #000000;"><p class="p_Normal">PAL Transfer</p>
</td>
<td style="vertical-align:top; padding:0; border:solid thin #000000;"><p class="p_Normal">PAL_CALL</p>
</td>
<td style="vertical-align:top; padding:0; border:solid thin #000000;"><p class="p_Normal">Discarded (pipeline serializes)</p>
</td>
<td style="vertical-align:top; padding:0; border:solid thin #000000;"><p class="p_Normal">Full flush, enter PAL at CALL_PAL vector</p>
</td>
</tr>
<tr>
<td style="vertical-align:top; padding:0; border:solid thin #000000;"><p class="p_Normal">Normal Commit</p>
</td>
<td style="vertical-align:top; padding:0; border:solid thin #000000;"><p class="p_Normal">ADVANCE</p>
</td>
<td style="vertical-align:top; padding:0; border:solid thin #000000;"><p class="p_Normal">Committed (safe — older instruction passed)</p>
</td>
<td style="vertical-align:top; padding:0; border:solid thin #000000;"><p class="p_Normal">Store written, predictor trained, instruction retired</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">PendingCommit disposition is the critical distinction:</span> On fault or PAL transfer, m_pending is discarded because it contains a result from a younger instruction that must be squashed. On normal commit, m_pending is safe to commit because the producing instruction already passed its own fault checks. The pending result and the retiring instruction are from different instructions — the pending is always one instruction older.</p>
<p class="p_Normal">&nbsp;</p>
<hr style="height:1px; color:#000000; border-width:0; background-color:#000000;" /><p class="p_Normal">&nbsp;</p>
<h2 class="p_Heading2" style="page-break-after: avoid;"><span class="f_Heading2">K.5 Fault Handling at Retirement</span></h2>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Faults are detected in stage_EX() but delivered in stage_WB(). The delay ensures all older instructions have retired before the fault is delivered (precise exception guarantee). The fault handling sequence at retirement:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">1. slot.faultPending is true — set in stage_EX() when a box detected an exception (TLB miss, access violation, arithmetic trap, alignment fault, illegal instruction).</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">2. m_pending is discarded. The pending result is from the instruction that was in EX when the faulting instruction was in MEM — one stage younger. That younger instruction's result must not reach the register file.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">3. PipelineAction::FAULT is set with three fields: trapCode (identifies the exception class — DTBM_SINGLE, ITB_MISS, DFAULT, ACCESS_VIOLATION, ARITH, ILLEGAL_INSTRUCTION, etc.), faultVA (the virtual address that triggered the fault, for TLB/memory faults), faultPC (the PC of the faulting instruction, saved to EXC_ADDR for restart).</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">4. The slot is invalidated. No store commit, no predictor update, no retirement counter increment.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">5. BoxResult::faultDispatched() propagates to AlphaCPU. AlphaCPU calls flushYoungerSlots() (discarding IF/DE/IS/EX/MEM), then enterPal() with the fault vector. EXC_ADDR is set to faultPC. PAL mode begins at the fault handler entry point.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Fault precedence:</span> If multiple slots have faultPending set, the oldest instruction (lowest slotSequence) faults first. Because stage_WB() processes only the oldest slot each cycle, and fault delivery flushes all younger slots, at most one fault is delivered per cycle. Younger faulting instructions are discarded — their faults are artifacts of speculative execution past the true fault point.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Store isolation:</span> The fault check (Step 2) executes before the store commit (Step 4). A faulting store instruction never writes to SafeMemory. A faulting load instruction's result never reaches the register file (its deferWriteback() populated m_pending, but the pending is discarded in the next cycle when the fault reaches WB). This two-phase isolation — stores blocked by step ordering, loads blocked by pending discard — is the mechanism that makes exceptions precise.</p>
<p class="p_Normal">&nbsp;</p>
<hr style="height:1px; color:#000000; border-width:0; background-color:#000000;" /><p class="p_Normal">&nbsp;</p>
<h2 class="p_Heading2" style="page-break-after: avoid;"><span class="f_Heading2">K.6 PAL Instructions at Retirement</span></h2>
<p class="p_Normal">&nbsp;</p>
<h2 class="p_Heading2" style="page-break-after: avoid;"><span class="f_Heading2">K.6.1 CALL_PAL</span></h2>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">CALL_PAL is detected in stage_WB() after the fault check but before store commit. The retirement sequence for CALL_PAL:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">1. m_pending is discarded. Any younger instruction's deferred result is squashed — CALL_PAL serializes the pipeline.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">2. The PAL function code is extracted from the instruction bits: <span class="f_CodeExample">palFunction(slot.di.rawBits())</span>.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">3. The PAL entry vector is computed: <span class="f_CodeExample">computeCallPalEntry(m_cpuId, palFunction)</span>. This uses PAL_BASE from the IPR storage and the architectural vector calculation: PAL_BASE[63:15] | function encoding | PAL mode bit. Privileged functions (0x00–0x3F) and unprivileged functions (0x80–0xBF) use different vector offsets.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">4. PipelineAction::PAL_CALL is set with palFunction, callPC (slot.di.pc), and palVector.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">5. The slot is invalidated. CALL_PAL is not &quot;retired&quot; in the normal sense — it does not increment m_instructionsRetired or emit EXECTRACE_WB_RETIRE. It is a control transfer, not a completed computation.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">6. AlphaCPU receives PAL_CALL, flushes the entire pipeline (flush()), and calls PalBox::enterPal() with PalEntryReason::CALL_PAL_INSTRUCTION. PalBox sets PC to the vector address (with bit 0 set for PAL mode), activates shadow registers, saves the return address (callPC + 4) to EXC_ADDR, and begins PAL execution.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Critical invariant:</span> CALL_PAL is not a pending event. There is no &quot;pending PAL transfer&quot; flag that survives between steps. CALL_PAL is an instruction outcome handled immediately in stage_WB() — detection, vector computation, and action are atomic within the same step.</p>
<p class="p_Normal">&nbsp;</p>
<h2 class="p_Heading2" style="page-break-after: avoid;"><span class="f_Heading2">K.6.2 HW_REI</span></h2>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">HW_REI (Return from PAL) is the exit serialization point. When HW_REI retires in stage_WB():</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">1. The pipeline is fully flushed — all slots invalidated, MBox staging cleared, pending commits discarded.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">2. PC is restored from EXC_ADDR (the return address saved on PAL entry).</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">3. PAL mode is cleared — PC bit 0 is set to 0, restoring normal execution mode.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">4. LL/SC reservations are cleared for the executing CPU.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">5. Shadow registers are deactivated — subsequent register references use the standard register file.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Together, CALL_PAL and HW_REI form a hard serialization boundary. No instruction from before the boundary survives into PAL mode, and no PAL-mode instruction survives into normal execution. Shadow register state, privileged IPR modifications, and PAL-mode memory access semantics are fully contained within the boundary.</p>
<p class="p_Normal">&nbsp;</p>
<h2 class="p_Heading2" style="page-break-after: avoid;"><span class="f_Heading2">K.6.3 PAL Functions That Modify Registers</span></h2>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">PAL functions (MFPR, MTPR, SWPCTX, etc.) modify architectural registers directly through PalBox, not through the deferred writeback mechanism. PalBox writes to the register file, IPR storage, and HWPCB as part of the PAL function execution. These writes occur within PAL mode and are not subject to pipeline speculation — PAL mode is fully serialized (one instruction at a time, no speculative execution). The deferred writeback mechanism (m_pending / commitPending / deferWriteback) is not used for any PAL register modification.</p>
<p class="p_Normal">&nbsp;</p>
<hr style="height:1px; color:#000000; border-width:0; background-color:#000000;" /><p class="p_Normal">&nbsp;</p>
<h2 class="p_Heading2" style="page-break-after: avoid;"><span class="f_Heading2">K.7 Store Commit at Retirement</span></h2>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Store data reaches SafeMemory only at retirement (Step 4 of stage_WB). The store commit sequence:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">1. The instruction must have store semantics: <span class="f_CodeExample">(slot.di.semantics &amp; S_Store)</span>.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">2. <span class="f_CodeExample">m_guestMemory→write64(slot.pa, slot.payLoad)</span> writes the store data to the physical address computed during stage_EX(). This is an atomic write to SafeMemory.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">3. <span class="f_CodeExample">m_reservationManager→breakReservationsOnCacheLine(slot.pa)</span> clears any LL/SC reservations held by any CPU on the affected cache line. This ensures that a store between a LD_L and ST_C on another CPU will cause the ST_C to fail, preserving the atomicity contract.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Store ordering guarantee:</span> Because only one instruction retires per cycle and retirement is in program order, stores are committed in program order. The memory model's weak ordering applies to visibility (when other CPUs see the store), not to the commit order. SafeMemory sees stores in strict program order; memory barriers (MB, WMB) control when those stores become globally visible.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Store-conditional (ST_C):</span> ST_C checks the LL/SC reservation before writing. If the reservation is invalid (broken by another CPU's store or by an intervening exception), ST_C writes 0 to the destination register (indicating failure) and does not write to SafeMemory. If the reservation is valid, ST_C writes to SafeMemory and writes 1 to the destination register (indicating success). The reservation check occurs in stage_EX(); the store commit at retirement is conditional on the check result.</p>
<p class="p_Normal">&nbsp;</p>
<hr style="height:1px; color:#000000; border-width:0; background-color:#000000;" /><p class="p_Normal">&nbsp;</p>
<h2 class="p_Heading2" style="page-break-after: avoid;"><span class="f_Heading2">K.8 Retirement and Flush Interaction</span></h2>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Pipeline flush discards all in-flight instructions. The interaction between flush and the deferred writeback mechanism is architecturally critical:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Flush on fault/PAL:</span> When stage_WB() detects a fault or CALL_PAL, it discards m_pending before returning. AlphaCPU then calls flush(), which clears all slots, clears MBox staging (clearMissStaging / clearIPRStaging), and resets the pipeline. The discarded pending result is from a younger instruction that would have been committed on the next cycle — discarding it ensures no speculative result survives the fault boundary.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Flush on misprediction:</span> flushYoungerSlots() invalidates IF, DE, and IS. The EX and MEM slots are preserved — the mispredicting instruction in EX has already produced its result, and the instruction in MEM must still retire. m_pending is not discarded because it contains a valid result from the instruction currently in MEM.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Flush on interrupt:</span> handleInterrupt() performs a full flush identical to the fault path. m_pending is discarded, all slots are cleared, and execution resumes at the interrupt vector in PAL mode.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Flush safety rule:</span> commitPending() runs at the top of stage_WB(), before any flush decision is made. This ensures that the older instruction's deferred result is committed to the register file before the current cycle determines whether to flush. The committed result is architecturally valid — the producing instruction passed all checks. Even if the current WB instruction faults, the older instruction's result is correctly preserved.</p>
<p class="p_Normal">&nbsp;</p>
<hr style="height:1px; color:#000000; border-width:0; background-color:#000000;" /><p class="p_Normal">&nbsp;</p>
<h2 class="p_Heading2" style="page-break-after: avoid;"><span class="f_Heading2">K.9 Retirement Invariants</span></h2>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">The following invariants hold for every retirement and are verified by the testing framework (Chapter 22):</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Single-instruction retirement.</span> Exactly one instruction retires per cycle (or zero if WB slot is empty). Never two. This is guaranteed by the ring buffer — only one slot occupies the WB position at any time.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">In-order retirement.</span> Instructions retire in strict program order. An instruction at slotSequence N always retires before slotSequence N+1. The ring buffer advancement and single-issue design enforce this without additional logic.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Fault-before-commit.</span> The fault check (Step 2) always executes before the store commit (Step 4). A faulting instruction never writes to SafeMemory.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">PAL-before-commit.</span> The CALL_PAL check (Step 3) always executes before the store commit (Step 4). CALL_PAL serializes without side effects.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Pending-from-older.</span> The m_pending result committed by commitPending() (Step 0) is always from an instruction older than the instruction in WB. The producing instruction already passed its own fault and retirement checks.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">commitPending-before-EX.</span> commitPending() runs before stage_EX() in every cycle (WB executes first in the reverse stage order). The register file is always current before any new instruction reads it.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">No speculative store.</span> Store data never reaches SafeMemory until the instruction retires successfully in stage_WB(). A faulting or flushed store leaves no trace in SafeMemory.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">Reservation break on store.</span> Every store that commits to SafeMemory breaks LL/SC reservations on the affected cache line. No store bypasses the reservation manager.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal"><span style="font-weight: bold;">SMP independence.</span> Retirement is per-CPU. Each CPU retires its own instructions independently. Store visibility to other CPUs is governed by the memory model and barrier semantics, not by retirement order across CPUs.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_SeeAlso" style="page-break-after: avoid;"><span class="f_SeeAlso">See Also: <a href="13_6-stage-implementations.html" class="topiclink">13.6.6 Stage Implementations</a> - stage_WB(); <a href="13_10-exception-precision.html" class="topiclink">13.10 Exception Precision</a> ; <a href="chapter-18---fault-dispatcher-.html" class="topiclink">Chapter 18 – Fault Dispatcher &amp; Precise Exceptions</a> ; <a href="chapter-20---boot-sequence_-pa.html" class="topiclink">Chapter 20 – Boot Sequence, PAL, and SRM Integration</a> (CALL_PAL/HW_REI); <a href="chapter-11---architectural-inv.html" class="topiclink">Chapter 11 - Architectural Invariants</a> ; cpuCoreLib/AlphaPipeline.h (stage_WB implementation).</span></p>

<!--ZOOMSTOP-->
</div></div>
<script type="text/javascript">

  function printTopic() {
    if (document.queryCommandSupported('print')) { document.execCommand('print', false, null); }
    else { window.print(); }
  }



function normHeaders() {
 var topicHeadHeight =  $("#idheaderbg > table").first().height() + 1,
	 $topicHeaderBox = $("#idheader"),
	 $topicContentBox = $("#idcontent"),
	 $navHeader = $("#navbar", parent.document),			 
	$navBox = $("div#hmnavframe", parent.document),
	 navHeaderHeight = $navHeader.height();
 if (topicHeadHeight != navHeaderHeight) {
	 $navHeader.css("height",topicHeadHeight + "px");
	 $navBox.css("top", topicHeadHeight + "px");
	 $topicHeaderBox.css("height", topicHeadHeight + "px");
		if ($topicHeaderBox.css("position") == "fixed"){
			$topicContentBox.css("margin-top", topicHeadHeight + "px");
			}
		}
    }
			 
  $(document).ready(function(){
    $(window).on('resize', function() {
      var y = $('#idheader').height(); 
      $('#idcontent').css('margin-top', y);
      var par = window.parent;
      if ($( par ).width() <= $( window ).width()+20) {
        $('#idheader').css('position', 'relative');
        $('#idcontent').css('margin-top', 0);
        $('#idbacktotop').css('display', 'block');
        $('.hmanchor').css('margin-top', -20);
	$('.hmanchor').css('padding-top', 20);
      }
      else {
        $('#idheader').css('position', 'fixed');
        $('#idcontent').css('margin-top', $('#idheader').height());
        $('#idbacktotop').css('display', 'none');
        $('.hmanchor').css('margin-top', -y-20);
		$('.hmanchor').css('padding-top', y+20);
		$("div#hmsplitter", parent.document).css('width', '3px');
      }
	normHeaders();
    });
    
    //Hide Print button on touch devices
    if (hmBrowser.nonDeskTouch) {
      $("a#printbuttonlink").hide();
      $("#idnav").css({"width": "125px", "padding-left": "0", "padding-right": "2px"});
    }
	 $(window).resize(); //trigger event for initially small displays
  });
 

if ((!parent.hmNavigationFrame) && (parent.location) && (parent.location.href)) { $('.sync-toc').show();$('p.crumbs').hide();}
var baseurl = document.URL.substring(0,document.URL.lastIndexOf("/")+1); 
$('#idcontent').append('<p class="help-url"><b>URL of this topic:<br /></b><a href="'+baseurl+'index.html' +
'?appendix-k----pipeline-retirem.html" target="_top">'+baseurl+'index.html?appendix-k----pipeline-retirem.html</a></p>');

</script>
</body>
</html>
