#!/usr/bin/env python3
"""
generate_cmakelists.py - Auto-generate CMakeLists.txt from directory structure
"""

import os
import sys
from pathlib import Path
from typing import List, Set

# ============================================================================
# CONFIGURATION
# ============================================================================

PROJECT_NAME = "EmulatRAppUni"
CMAKE_MIN_VERSION = "3.16"
CXX_STANDARD = "20"  # C++20 for std::cmp_less

# Qt modules needed
QT_MODULES = [
    "Core",
    "Network",
    "Concurrent"
]

# Compiler flags
COMPILER_FLAGS = {
    "MSVC": [
        "/W4",
        "/permissive-",
        "/Zc:__cplusplus",
        "/MP",
        "/EHsc",
        "/bigobj",  # Required for files with many grains/templates
        "/Gy",      # Enable function-level linking
    ],
    "GCC": [
        "-Wall",
        "-Wextra",
        "-pedantic",
        "-Wno-unused-parameter",
        "-ffunction-sections",  # Enable function-level linking
        "-fdata-sections",
    ],
    "Clang": [
        "-Wall",
        "-Wextra",
        "-pedantic",
        "-Wno-unused-parameter",
        "-ffunction-sections",  # Enable function-level linking
        "-fdata-sections",
    ]
}

# Linker flags
LINKER_FLAGS = {
    "MSVC": [
        "/OPT:REF",        # Remove unreferenced functions
        "/VERBOSE:REF",    # Print what's being removed
        "/OPT:ICF",        # Identical COMDAT folding
    ],
    "GCC": [
        "-Wl,--gc-sections",         # Garbage collect unused sections
        "-Wl,--print-gc-sections",   # Print removed sections
    ],
    "Clang": [
        "-Wl,--gc-sections",         # Garbage collect unused sections
        "-Wl,--print-gc-sections",   # Print removed sections
    ]
}

# Preprocessor definitions
DEFINITIONS = [
    "EXECTRACE_ENABLED",
    "QT_DEPRECATED_WARNINGS",
    "QT_DISABLE_DEPRECATED_BEFORE=0x060000",
    "AXP_DEBUG_PIPELINE",
    "AXP_DEBUG_DECODE",
    "AXP_DEBUG_FETCH",
    "AXP_INSTRUMENTATION_TRACE",
    "WIN32_LEAN_AND_MEAN"  
]

# Specific files to deploy to output directory during build
# Format: (source_file, dest_subdir, dest_filename)
DEPLOY_FILES = [
    ("configLib/ASAEmulatR.ini", "config", "ASAEmulatR.ini"),
    ("firmware/clipper.bin", "firmware", "clipper.bin"),
     ("firmware/decompressed.rom", "firmware", "decompressed.rom"),
     ("firmware/DS10_V6_2.exe", "firmware", "DS10_V6_2.exe"),
     ("firmware/DS20_V6_2.exe", "firmware", "DS20_V6_2.exe"),
     ("firmware/DS20L_V6_2.exe", "firmware", "DS20L_V6_2.exe"),
     ("firmware/ES40_V6_2.exe", "firmware", "ES40_V6_2.exe"),
     ("firmware/ES45_V6_2.exe", "firmware", "ES45_V6_2.exe"),
     ("firmware/GS320_V62.exe", "firmware", "GS320_V62.exe"),
]

# Directories to exclude
EXCLUDE_DIRS = {
    ".git", ".vs", "build", "out",
    "cmake-build-debug", "cmake-build-release",
    "__pycache__", ".idea", "CMakeFiles",
}

# File extensions
SOURCE_EXTENSIONS = {".cpp", ".cc", ".cxx"}
HEADER_EXTENSIONS = {".h", ".hpp", ".hxx"}

MAIN_SOURCE = "main.cpp"




# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def normalize_path(path: str) -> str:
    """Convert Windows backslashes to forward slashes for CMake."""
    return path.replace("\\", "/")

def find_sources(root_dir: Path, exclude_dirs: Set[str]) -> tuple[List[Path], List[Path]]:
    """Find all source and header files."""
    sources = []
    headers = []
    
    for item in root_dir.rglob("*"):
        if any(excluded in item.parts for excluded in exclude_dirs):
            continue
        
        if item.is_file():
            suffix = item.suffix.lower()
            if suffix in SOURCE_EXTENSIONS:
                sources.append(item)
            elif suffix in HEADER_EXTENSIONS:
                headers.append(item)
    
    return sources, headers

def make_relative(paths: List[Path], base: Path) -> List[str]:
    """Convert to relative paths with forward slashes."""
    return [normalize_path(str(p.relative_to(base))) for p in paths]

def generate_cmake(
    project_name: str,
    sources: List[str],
    headers: List[str],
    main_source: str
) -> str:
    """Generate CMakeLists.txt content."""
    
    if main_source not in sources:
        sources.insert(0, main_source)
    
    # Build content using .format() to avoid brace escaping issues
    content = []
    
    # Header
    content.append(f"""# ============================================================================
# Auto-generated CMakeLists.txt for {project_name}
# Generated by: generate_cmakelists.py
# ============================================================================

cmake_minimum_required(VERSION {CMAKE_MIN_VERSION})

project({project_name} LANGUAGES CXX)

# ============================================================================
# C++ Standard
# ============================================================================
set(CMAKE_CXX_STANDARD {CXX_STANDARD})
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# ============================================================================
# Qt Configuration
# ============================================================================
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC ON)

find_package(Qt6 REQUIRED COMPONENTS {' '.join(QT_MODULES)})



# ============================================================================
# Preprocessor Definitions
# ============================================================================
add_compile_definitions(
""")
    
    for definition in DEFINITIONS:
        content.append(f"    {definition}\n")
    
    content.append(""")

# ============================================================================
# Compiler Flags
# ============================================================================
if(MSVC)
""")
    
    for flag in COMPILER_FLAGS["MSVC"]:
        content.append(f'    add_compile_options("{flag}")\n')
    
    content.append("""elseif(CMAKE_CXX_COMPILER_ID MATCHES "GNU")
""")
    
    for flag in COMPILER_FLAGS["GCC"]:
        content.append(f'    add_compile_options("{flag}")\n')
    
    content.append("""elseif(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
""")
    
    for flag in COMPILER_FLAGS["Clang"]:
        content.append(f'    add_compile_options("{flag}")\n')
    
    content.append("""endif()

# ============================================================================
# Linker Flags
# ============================================================================
if(MSVC)
""")
    
    for flag in LINKER_FLAGS["MSVC"]:
        content.append(f'    add_link_options("{flag}")\n')
    
    content.append("""elseif(CMAKE_CXX_COMPILER_ID MATCHES "GNU")
""")
    
    for flag in LINKER_FLAGS["GCC"]:
        content.append(f'    add_link_options("{flag}")\n')
    
    content.append("""elseif(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
""")
    
    for flag in LINKER_FLAGS["Clang"]:
        content.append(f'    add_link_options("{flag}")\n')
    
    content.append("""endif()

# ============================================================================
# Include Directories
# ============================================================================
include_directories(${CMAKE_CURRENT_SOURCE_DIR})

# ============================================================================
# Source Files
# ============================================================================
set(PROJECT_SOURCES
""")
    
    for src in sorted(sources):
        comment = "  # Entry point" if src == main_source else ""
        content.append(f'    "{src}"{comment}\n')
    
    content.append(""")

# ============================================================================
# Header Files (for IDE organization)
# ============================================================================
set(PROJECT_HEADERS
""")
    
    for hdr in sorted(headers):
        content.append(f'    "{hdr}"\n')
    
    content.append(""")

# ============================================================================
# Executable Target
# ============================================================================
add_executable(${PROJECT_NAME}
    ${PROJECT_SOURCES}
    ${PROJECT_HEADERS}
)

# ============================================================================
# Link Qt Libraries
# ============================================================================
target_link_libraries(${PROJECT_NAME} PRIVATE
""")
    
    for module in QT_MODULES:
        content.append(f"    Qt6::{module}\n")
    
    content.append(""")

# ============================================================================
# Qt Deployment (Copy DLLs to output directory) - WINDOWS ONLY
# ============================================================================
if(WIN32)
    # Find windeployqt executable
    get_target_property(_qmake_executable Qt6::qmake IMPORTED_LOCATION)
    get_filename_component(_qt_bin_dir "${_qmake_executable}" DIRECTORY)
    find_program(WINDEPLOYQT_EXECUTABLE windeployqt HINTS "${_qt_bin_dir}")
    
    if(WINDEPLOYQT_EXECUTABLE)
        # Run windeployqt after each build
        add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
            COMMAND "${WINDEPLOYQT_EXECUTABLE}"
                --verbose 1
                --no-translations
                --no-system-d3d-compiler
                --no-opengl-sw
                --no-compiler-runtime
                "$<TARGET_FILE:${PROJECT_NAME}>"
            COMMENT "Deploying Qt libraries with windeployqt..."
        )
        message(STATUS "✓ Qt deployment configured: windeployqt will run after build")
    else()
        message(WARNING "⚠ windeployqt not found - Qt DLLs must be manually deployed!")
    endif()
endif()

set(_asa_ini_src "${PROJECT_SOURCE_DIR}/ASAEmulatr.ini")
set(_asa_ini_dst "$<TARGET_FILE_DIR:${PROJECT_NAME}>/ASAEmulatr.ini")

set(_deploy_script "${CMAKE_CURRENT_BINARY_DIR}/deploy_asa_ini.cmake")
file(WRITE "${_deploy_script}" "
if(EXISTS \"${_asa_ini_src}\")
  execute_process(COMMAND \"${CMAKE_COMMAND}\" -E copy_if_different
    \"${_asa_ini_src}\" \"${_asa_ini_dst}\")
else()
  message(WARNING \"ASAEmulatr.ini not found at: ${_asa_ini_src}\")
endif()
")

add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
  COMMAND ${CMAKE_COMMAND} -P "${_deploy_script}"
  COMMENT \"Deploying ASAEmulatr.ini\"
)

# ============================================================================
# Deploy Firmware Files (glob pattern match)
#   - Copy all firmware/*_64.exe into <target>/bin/firmware
# ============================================================================
file(GLOB CONFIGURE_DEPENDS FIRMWARE_64_FILES
    "${PROJECT_SOURCE_DIR}/firmware/*_64.exe"
)

if(FIRMWARE_64_FILES)
    add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E make_directory
            "$<TARGET_FILE_DIR:${PROJECT_NAME}>/firmware"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
            ${FIRMWARE_64_FILES}
            "$<TARGET_FILE_DIR:${PROJECT_NAME}>/bin/firmware/"
        COMMENT "Deploying firmware images (*_64.exe) to bin/firmware"
    )
else()
    message(WARNING "No firmware files matching *_64.exe found in firmware/")
endif()

# ============================================================================
# Deploy Configuration and Firmware Files
# ============================================================================
""")
    
    # Get unique subdirectories that need to be created
    subdirs = set(dest_subdir for _, dest_subdir, _ in DEPLOY_FILES)
    
    # Generate directory creation commands
    if subdirs:
        content.append("""
# Create runtime directory structure
add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
""")
        for subdir in sorted(subdirs):
            content.append(f"""    COMMAND ${{CMAKE_COMMAND}} -E make_directory
        "$<TARGET_FILE_DIR:${{PROJECT_NAME}}>/{subdir}"
""")
        content.append("""    COMMENT "Creating runtime directory structure"
)
""")
    
    # Generate file copy commands with existence checks
    for source_file, dest_subdir, dest_filename in DEPLOY_FILES:
        content.append(f"""
# Copy {source_file} to {dest_subdir}/{dest_filename}
if(EXISTS "${{CMAKE_CURRENT_SOURCE_DIR}}/{source_file}")
    add_custom_command(TARGET ${{PROJECT_NAME}} POST_BUILD
        COMMAND ${{CMAKE_COMMAND}} -E copy_if_different
            "${{CMAKE_CURRENT_SOURCE_DIR}}/{source_file}"
            "$<TARGET_FILE_DIR:${{PROJECT_NAME}}>/{dest_subdir}/{dest_filename}"
        COMMENT "Deploying {source_file} to {dest_subdir}/"
    )
else()
    message(WARNING "⚠ {source_file} not found - skipping deployment")
endif()
""")
    
    content.append("""
# ============================================================================
# Set Startup Project (Visual Studio)
# ============================================================================
set_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT ${PROJECT_NAME})

set_target_properties(${PROJECT_NAME} PROPERTIES
    VS_DEBUGGER_WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
    WIN32_EXECUTABLE FALSE  # Console application
)

# ============================================================================
# Installation
# ============================================================================
install(TARGETS ${PROJECT_NAME}
    BUNDLE DESTINATION .
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
)

# ============================================================================
# Print Configuration Summary
# ============================================================================
message(STATUS "========================================")
message(STATUS \"""" + project_name + """ Configuration")
message(STATUS "========================================")
message(STATUS "C++ Standard: ${CMAKE_CXX_STANDARD}")
message(STATUS "Compiler: ${CMAKE_CXX_COMPILER_ID}")
message(STATUS "Build Type: ${CMAKE_BUILD_TYPE}")
message(STATUS "Qt Version: ${Qt6_VERSION}")
message(STATUS "Entry Point: """ + main_source + """")
message(STATUS "Definitions: """ + ', '.join(DEFINITIONS) + """")
message(STATUS "========================================")
""")
    
    return ''.join(content)

# ============================================================================
# MAIN
# ============================================================================

def main():
    """Main entry point."""
    
    if len(sys.argv) > 1:
        project_root = Path(sys.argv[1]).resolve()
    else:
        project_root = Path.cwd()
    
    if not project_root.is_dir():
        print(f"Error: {project_root} is not a directory")
        sys.exit(1)
    
    print(f"Scanning {project_root}...")
    
    sources_abs, headers_abs = find_sources(project_root, EXCLUDE_DIRS)
    sources_rel = make_relative(sources_abs, project_root)
    headers_rel = make_relative(headers_abs, project_root)
    
    print(f"Found {len(sources_rel)} source files and {len(headers_rel)} header files")
    
    if MAIN_SOURCE not in sources_rel:
        print(f"⚠ Warning: {MAIN_SOURCE} not found!")
    
    cmake_content = generate_cmake(
        PROJECT_NAME,
        sources_rel,
        headers_rel,
        MAIN_SOURCE
    )
    
    output_path = project_root / "CMakeLists.txt"
    print(f"Writing {output_path}...")
    output_path.write_text(cmake_content, encoding='utf-8')
    
    print(f"\n✓ Generated: {output_path}")
    print(f"✓ Entry point: {MAIN_SOURCE}")
    print(f"✓ C++ Standard: {CXX_STANDARD}")
    print(f"✓ Qt deployment: Enabled (windeployqt)")
    print(f"✓ File deployment:")
    for source_file, dest_subdir, dest_filename in DEPLOY_FILES:
        print(f"  - {source_file} → build/{dest_subdir}/{dest_filename}")
    print(f"✓ Linker optimization: Enabled (/OPT:REF, /VERBOSE:REF)")

if __name__ == "__main__":
    main()
