================================================================================
FILE: z:\EmulatRApp\SmpManager.h
LINE: 71
SIGNATURE:
	void bindSafeMemory(SafeMemory* m) 

BODY (preview):
	void bindSafeMemory(SafeMemory* m) { m_safeMemory = m; }
	void bindMMIOManager(MMIOManager* m) { m_mmio = m; }

================================================================================
FILE: z:\EmulatRApp\SmpManager.h
LINE: 72
SIGNATURE:
	void bindMMIOManager(MMIOManager* m) 

BODY (preview):
	void bindMMIOManager(MMIOManager* m) { m_mmio = m; }
	void bindReservationManager(ReservationManager* r) { m_resv = r; }

================================================================================
FILE: z:\EmulatRApp\SmpManager.h
LINE: 73
SIGNATURE:
	void bindReservationManager(ReservationManager* r) 

BODY (preview):
	void bindReservationManager(ReservationManager* r) { m_resv = r; }
	void bindIRQController(IRQController* irq) { m_irq = irq; }

================================================================================
FILE: z:\EmulatRApp\SmpManager.h
LINE: 74
SIGNATURE:
	void bindIRQController(IRQController* irq) 

BODY (preview):
	void bindIRQController(IRQController* irq) { m_irq = irq; }
	void bindGrainResolver(GrainResolver* g) { m_grains = g; }

================================================================================
FILE: z:\EmulatRApp\SmpManager.h
LINE: 75
SIGNATURE:
	void bindGrainResolver(GrainResolver* g) 

BODY (preview):
	void bindGrainResolver(GrainResolver* g) { m_grains = g; }
	void bindDeviceBus(DeviceBus* d) { m_devBus = d; }

================================================================================
FILE: z:\EmulatRApp\SmpManager.h
LINE: 76
SIGNATURE:
	void bindDeviceBus(DeviceBus* d) 

BODY (preview):
	void bindDeviceBus(DeviceBus* d) { m_devBus = d; }
	void bindScsiController(ScsiController* s) { m_scsiCtrl = s; }

================================================================================
FILE: z:\EmulatRApp\SmpManager.h
LINE: 77
SIGNATURE:
	void bindScsiController(ScsiController* s) 

BODY (preview):
	void bindScsiController(ScsiController* s) { m_scsiCtrl = s; }


================================================================================
FILE: z:\EmulatRApp\SMPManager_IRQ_IPI_Queues.h
LINE: 87
SIGNATURE:
	bool tryEnqueue(MessageType type, quint32 p1, quint32 p2, quint64 p3 = 0) noexcept

BODY (preview):
	bool tryEnqueue(MessageType type, quint32 p1, quint32 p2, quint64 p3 = 0) noexcept {
		qsizetype wIdx = writeIdx.load(std::memory_order_relaxed);
		qsizetype rIdx = readIdx.load(std::memory_order_acquire);
		qsizetype nextWrite = (wIdx + 1) % CAPACITY;

		if (nextWrite == rIdx) {
			WARN_LOG(QString("IPIQueue: overflow (type=%1)").arg(static_cast<int>(type)));
			return false;  // Full
		}

		messages[wIdx].type = type;
		messages[wIdx].param1 = p1;
		messages[wIdx].param2 = p2;
		messages[wIdx].param3 = p3;
		messages[wIdx].ready.store(true, std::memory_order_release);

================================================================================
FILE: z:\EmulatRApp\SMPManager_IRQ_IPI_Queues.h
LINE: 92
SIGNATURE:
 if(nextWrite == rIdx) 

BODY (preview):
		if (nextWrite == rIdx) {
			WARN_LOG(QString("IPIQueue: overflow (type=%1)").arg(static_cast<int>(type)));
			return false;  // Full
		}

================================================================================
FILE: z:\EmulatRApp\SMPManager_IRQ_IPI_Queues.h
LINE: 116
SIGNATURE:
	bool tryDequeue(MessageType& type, quint32& p1, quint32& p2, quint64& p3) noexcept

BODY (preview):
	bool tryDequeue(MessageType& type, quint32& p1, quint32& p2, quint64& p3) noexcept {
		qsizetype rIdx = readIdx.load(std::memory_order_relaxed);
		qsizetype wIdx = writeIdx.load(std::memory_order_acquire);

		if (rIdx == wIdx) {
			return false;  // Empty
		}

		if (!messages[rIdx].ready.load(std::memory_order_acquire)) {
			return false;  // Not yet written
		}

		type = messages[rIdx].type;
		p1 = messages[rIdx].param1;
		p2 = messages[rIdx].param2;

================================================================================
FILE: z:\EmulatRApp\SMPManager_IRQ_IPI_Queues.h
LINE: 120
SIGNATURE:
 if(rIdx == wIdx) 

BODY (preview):
		if (rIdx == wIdx) {
			return false;  // Empty
		}

================================================================================
FILE: z:\EmulatRApp\SMPManager_IRQ_IPI_Queues.h
LINE: 158
SIGNATURE:
	void clear() noexcept

BODY (preview):
	void clear() noexcept {
		qsizetype rIdx = readIdx.load(std::memory_order_relaxed);
		qsizetype wIdx = writeIdx.load(std::memory_order_relaxed);

		while (rIdx != wIdx) {
			messages[rIdx].ready.store(false, std::memory_order_relaxed);
			rIdx = (rIdx + 1) % CAPACITY;
		}

		readIdx.store(wIdx, std::memory_order_release);
	}

================================================================================
FILE: z:\EmulatRApp\SMPManager_IRQ_IPI_Queues.h
LINE: 162
SIGNATURE:
 while(rIdx != wIdx) 

BODY (preview):
		while (rIdx != wIdx) {
			messages[rIdx].ready.store(false, std::memory_order_relaxed);
			rIdx = (rIdx + 1) % CAPACITY;
		}

================================================================================
FILE: z:\EmulatRApp\SMPManager_IRQ_IPI_Queues.h
LINE: 179
SIGNATURE:
 if(rIdx == wIdx) 

BODY (preview):
		if (rIdx == wIdx) {
			return nullptr;
		}

================================================================================
FILE: z:\EmulatRApp\SMPManager_IRQ_IPI_Queues.h
LINE: 198
SIGNATURE:
inline const char* ipiMessageTypeName(IPIQueue::MessageType type) 

BODY (preview):
inline const char* ipiMessageTypeName(IPIQueue::MessageType type) {
	switch (type) {
	case IPIQueue::MessageType::INVALID:          return "INVALID";
	case IPIQueue::MessageType::TLB_SHOOTDOWN:    return "TLB_SHOOTDOWN";
	case IPIQueue::MessageType::CACHE_COHERENCY:  return "CACHE_COHERENCY";
	case IPIQueue::MessageType::BARRIER_SYNC:     return "BARRIER_SYNC";
	case IPIQueue::MessageType::CUSTOM:           return "CUSTOM";
	default:                                      return "UNKNOWN";
	}
}

================================================================================
FILE: z:\EmulatRApp\SMPManager_IRQ_IPI_Queues.h
LINE: 212
SIGNATURE:
inline QString formatIPIMessage(const IPIQueue::Message& msg) 

BODY (preview):
inline QString formatIPIMessage(const IPIQueue::Message& msg) {
	return QString("IPI[%1] p1=0x%2 p2=0x%3 p3=0x%4")
		.arg(ipiMessageTypeName(msg.type))
		.arg(msg.param1, 8, 16, QChar('0'))
		.arg(msg.param2, 8, 16, QChar('0'))
		.arg(msg.param3, 16, 16, QChar('0'));
}

================================================================================
FILE: z:\EmulatRApp\SMPManager_IRQ_IPI_Queues.h
LINE: 223
SIGNATURE:
inline QString formatIRQMessage(quint32 vector, quint8 ipl) 

BODY (preview):
inline QString formatIRQMessage(quint32 vector, quint8 ipl) {
	return QString("IRQ[vector=0x%1 ipl=%2]")
		.arg(vector, 8, 16, QChar('0'))
		.arg(ipl);
}

================================================================================
FILE: z:\EmulatRApp\ABoxLib\ABoxBase.h
LINE: 56
SIGNATURE:
 if(tr != TranslationResult::Ok) 

BODY (preview):
		if (tr != TranslationResult::Ok) {
			raiseTranslationFault(va, tr);
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\ABoxLib\ABoxBase.h
LINE: 69
SIGNATURE:
 if(st != SafeMemory::Status::Ok) 

BODY (preview):
		if (st != SafeMemory::Status::Ok) {
			m_ctx->raiseTrap(translateSafeMemStatusToTrap(st), va);
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\ABoxLib\ABoxBase.h
LINE: 94
SIGNATURE:
 if(st != SafeMemory::Status::Ok) 

BODY (preview):
		if (st != SafeMemory::Status::Ok) {
			m_ctx->raiseTrap(translateSafeMemStatusToTrap(st), pa);
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\ABoxLib\ABoxBase.h
LINE: 119
SIGNATURE:
 if(tr != TranslationResult::Ok) 

BODY (preview):
		if (tr != TranslationResult::Ok) {
			raiseTranslationFault(va, tr);
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\ABoxLib\ABoxBase.h
LINE: 187
SIGNATURE:
 switch(tr) 

BODY (preview):
		switch (tr) {
		case TranslationResult::TlbMiss:
			trap = TrapCode::DTB_MISS;
			break;
		case TranslationResult::PermissionDenied:
			trap = TrapCode::DTB_ACCESS_VIOLATION;
			break;
		case TranslationResult::NonCanonical:
		case TranslationResult::Misaligned:
			trap = TrapCode::DTB_FAULT;
			break;
		default:
			trap = TrapCode::MACHINE_CHECK;
			break;
		}

================================================================================
FILE: z:\EmulatRApp\ABoxLib\ABoxBase.h
LINE: 208
SIGNATURE:
 switch(st) 

BODY (preview):
		switch (st) {
		case SafeMemory::Status::Ok:
			return TrapCode::NONE;
		case SafeMemory::Status::AccessViolation:
			return TrapCode::DTB_ACCESS_VIOLATION;
		case SafeMemory::Status::Un_Aligned:
			return TrapCode::UN_ALIGNED;
		case SafeMemory::Status::BusError:
		case SafeMemory::Status::Time_Out:
		default:
			return TrapCode::MACHINE_CHECK;
		}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 39
SIGNATURE:
	inline void update(bool taken) noexcept

BODY (preview):
	inline void update(bool taken) noexcept {
		if (taken) {
			if (predictor < 3) predictor++;
		}
		else {
			if (predictor > 0) predictor--;
		}
	}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 40
SIGNATURE:
 if(taken) 

BODY (preview):
		if (taken) {
			if (predictor < 3) predictor++;
		}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 66
SIGNATURE:
 for(int i = 0; i < BHT_SIZE; ++i) 

BODY (preview):
		for (int i = 0; i < BHT_SIZE; ++i) {
			for (int j = 0; j < BHT_WAYS; ++j) {
				m_branchHistoryTable[i][j] = { 0, 1, 0, false };
			}
		}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 67
SIGNATURE:
	 for(int j = 0; j < BHT_WAYS; ++j) 

BODY (preview):
			for (int j = 0; j < BHT_WAYS; ++j) {
				m_branchHistoryTable[i][j] = { 0, 1, 0, false };
			}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 76
SIGNATURE:
	inline void setStrategy(BranchStrategy strategy) noexcept

BODY (preview):
	inline void setStrategy(BranchStrategy strategy) noexcept {
		m_strategy = strategy;
	}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 103
SIGNATURE:
	 if(entry != nullptr && entry->valid) 

BODY (preview):
			if (entry != nullptr && entry->valid) {
				return entry->predict();
			}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 124
SIGNATURE:
 if(m_strategy != BranchStrategy::HistoryTable) 

BODY (preview):
		if (m_strategy != BranchStrategy::HistoryTable) {
			return;  // Only history table mode needs updates
		}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 131
SIGNATURE:
 for(int way = 0; way < BHT_WAYS; ++way) 

BODY (preview):
		for (int way = 0; way < BHT_WAYS; ++way) {
			auto& entry = m_branchHistoryTable[idx][way];
			if (entry.valid && entry.pc == pc) {
				entry.update(taken);
				entry.targetPC = target;
				return;
			}
		}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 133
SIGNATURE:
	 if(entry.valid && entry.pc == pc) 

BODY (preview):
			if (entry.valid && entry.pc == pc) {
				entry.update(taken);
				entry.targetPC = target;
				return;
			}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 159
SIGNATURE:
 if(m_strategy == BranchStrategy::HistoryTable) 

BODY (preview):
		if (m_strategy == BranchStrategy::HistoryTable) {
			const BranchHistoryEntry* entry = findBranchEntry(pc);
			if (entry != nullptr && entry->valid && entry->targetPC != 0) {
				return entry->targetPC;
			}
		}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 161
SIGNATURE:
	 if(entry != nullptr && entry->valid && entry->targetPC != 0) 

BODY (preview):
			if (entry != nullptr && entry->valid && entry->targetPC != 0) {
				return entry->targetPC;
			}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 176
SIGNATURE:
 for(int i = 0; i < BHT_SIZE; ++i) 

BODY (preview):
		for (int i = 0; i < BHT_SIZE; ++i) {
			for (int j = 0; j < BHT_WAYS; ++j) {
				if (m_branchHistoryTable[i][j].valid) {
					count++;
				}
			}
		}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 177
SIGNATURE:
	 for(int j = 0; j < BHT_WAYS; ++j) 

BODY (preview):
			for (int j = 0; j < BHT_WAYS; ++j) {
				if (m_branchHistoryTable[i][j].valid) {
					count++;
				}
			}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 178
SIGNATURE:
		 if(m_branchHistoryTable[i][j].valid) 

BODY (preview):
				if (m_branchHistoryTable[i][j].valid) {
					count++;
				}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 189
SIGNATURE:
 for(int i = 0; i < BHT_SIZE; ++i) 

BODY (preview):
		for (int i = 0; i < BHT_SIZE; ++i) {
			for (int j = 0; j < BHT_WAYS; ++j) {
				m_branchHistoryTable[i][j].valid = false;
			}
		}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 190
SIGNATURE:
	 for(int j = 0; j < BHT_WAYS; ++j) 

BODY (preview):
			for (int j = 0; j < BHT_WAYS; ++j) {
				m_branchHistoryTable[i][j].valid = false;
			}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 218
SIGNATURE:
 for(int way = 0; way < BHT_WAYS; ++way) 

BODY (preview):
		for (int way = 0; way < BHT_WAYS; ++way) {
			const auto& entry = m_branchHistoryTable[idx][way];
			if (entry.valid && entry.pc == pc) {
				return &entry;
			}
		}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 220
SIGNATURE:
	 if(entry.valid && entry.pc == pc) 

BODY (preview):
			if (entry.valid && entry.pc == pc) {
				return &entry;
			}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 233
SIGNATURE:
 for(int way = 0; way < BHT_WAYS; ++way) 

BODY (preview):
		for (int way = 0; way < BHT_WAYS; ++way) {
			auto& entry = m_branchHistoryTable[idx][way];
			if (entry.valid && entry.pc == pc) {
				return &entry;
			}
		}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\BranchPredictor.h
LINE: 235
SIGNATURE:
	 if(entry.valid && entry.pc == pc) 

BODY (preview):
			if (entry.valid && entry.pc == pc) {
				return &entry;
			}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\CBoxBase.h
LINE: 90
SIGNATURE:
	AXP_FLATTEN void executeBNE(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept

BODY (preview):
	AXP_FLATTEN void executeBNE(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept { 
		// Current PC points at branch instruction
		const quint64 pc = ctx.getPC();

		// Read integer register RA
		const quint64 regValue = ctx.readIntReg(slot.di.ra);

		// Signed 16-bit displacement, scaled by 4 bytes
		const qint64 disp =
			static_cast<qint16>(getMemDisp(slot.di));

		const qint64 byteOffset = disp << 2;

		// Alpha branches are relative to PC + 4
		const quint64 nextPC = pc + 4;

================================================================================
FILE: z:\EmulatRApp\CBoxLib\CBoxBase.h
LINE: 112
SIGNATURE:
	AXP_FLATTEN void executeBLT(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept

BODY (preview):
	AXP_FLATTEN void executeBLT(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept { 
	
		// Current PC points at branch instruction
		const quint64 pc = ctx.getPC();

		// Read integer register RA
		const qint64 sval = static_cast<qint64>(ctx.readIntReg(slot.di.ra));

		// Signed 16-bit displacement, scaled by 4 bytes
		const qint64 disp =
			static_cast<qint16>(getMemDisp(slot.di));

		const qint64 byteOffset = disp << 2;

		// Alpha branches are relative to PC + 4

================================================================================
FILE: z:\EmulatRApp\CBoxLib\CBoxBase.h
LINE: 135
SIGNATURE:
	AXP_FLATTEN void executeBLE(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept

BODY (preview):
	AXP_FLATTEN void executeBLE(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept { 
	
		// Current PC points at branch instruction
		const quint64 pc = ctx.getPC();

		// Read integer register RA
		const qint64 sval = static_cast<qint64>(ctx.readIntReg(slot.di.ra));

		// Signed 16-bit displacement, scaled by 4 bytes
		const qint64 disp =
			static_cast<qint16>(getMemDisp(slot.di));

		const qint64 byteOffset = disp << 2;



================================================================================
FILE: z:\EmulatRApp\CBoxLib\CBoxBase.h
LINE: 159
SIGNATURE:
	AXP_FLATTEN void executeBGT(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept

BODY (preview):
	AXP_FLATTEN void executeBGT(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept { 

		// Current PC points at branch instruction
		const quint64 pc = ctx.getPC();

		// Read integer register RA
		const qint64 sval = static_cast<qint64>(ctx.readIntReg(slot.di.ra));

		// Signed 16-bit displacement, scaled by 4 bytes
		const qint64 disp =
			static_cast<qint16>(getMemDisp(slot.di));

		const qint64 byteOffset = disp << 2;

		// Alpha branches are relative to PC + 4

================================================================================
FILE: z:\EmulatRApp\CBoxLib\CBoxBase.h
LINE: 183
SIGNATURE:
	AXP_FLATTEN void executeBGE(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept

BODY (preview):
	AXP_FLATTEN void executeBGE(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept {

		// Current PC points at branch instruction
		const quint64 pc = ctx.getPC();

		// Read integer register RA
		const qint64 sval = static_cast<qint64>(ctx.readIntReg(slot.di.ra));

		// Signed 16-bit displacement, scaled by 4 bytes
		const qint64 disp =
			static_cast<qint16>(getMemDisp(slot.di));

		const qint64 byteOffset = disp << 2;

		// Alpha branches are relative to PC + 4

================================================================================
FILE: z:\EmulatRApp\CBoxLib\CBoxBase.h
LINE: 208
SIGNATURE:
	AXP_FLATTEN void executeBLBC(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept

BODY (preview):
	AXP_FLATTEN void executeBLBC(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept { 
		quint64 pc = ctx.getPC();
		quint64 regValue = ctx.readIntReg(slot.di.ra);
		qint64 displacement = static_cast<qint64>(getMemDisp(slot.di)) << 2;
		const quint64 nextPC = pc + 4;
		const quint64 targetPC = nextPC + (displacement << 2);

		bool branchTaken = ((regValue & 0x1) == 0);

		if (branchTaken) {
			ctx.setPC(targetPC);
		
		}
		else {
			ctx.setPC(pc + 4);

================================================================================
FILE: z:\EmulatRApp\CBoxLib\CBoxBase.h
LINE: 217
SIGNATURE:
 if(branchTaken) 

BODY (preview):
		if (branchTaken) {
			ctx.setPC(targetPC);
		
		}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\CBoxBase.h
LINE: 226
SIGNATURE:
	AXP_FLATTEN void executeBLBS(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept

BODY (preview):
	AXP_FLATTEN void executeBLBS(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept { 
		quint64 pc = ctx.getPC();
		quint64 regValue = ctx.readIntReg(slot.di.ra);
		qint64 displacement = static_cast<qint64>(getMemDisp(slot.di)) << 2;
		quint64 targetAddress = pc + displacement;

		bool branchTaken = ((regValue & 0x1) != 0);

		if (branchTaken) {
			ctx.setPC(targetAddress);
		}
		else {
			ctx.setPC(pc + 4);
		}
	

================================================================================
FILE: z:\EmulatRApp\CBoxLib\CBoxBase.h
LINE: 234
SIGNATURE:
 if(branchTaken) 

BODY (preview):
		if (branchTaken) {
			ctx.setPC(targetAddress);
		}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\CBoxBase.h
LINE: 270
SIGNATURE:
	AXP_FLATTEN void executeFBNE(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept

BODY (preview):
	AXP_FLATTEN void executeFBNE(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept {
		// Current PC points at branch instruction
		const quint64 pc = ctx.getPC();

		// FPCR condition: EQ (equal)
		// ASA: FP branch tests FP condition codes set by prior FP compare
		const bool conditionMet = ctx.fpcrNE();

		// Signed 16-bit displacement, scaled by 4 bytes
		const qint64 disp =
			static_cast<qint16>(getMemDisp(slot.di));

		const qint64 byteOffset = disp << 2;

		// Alpha branches are relative to PC + 4

================================================================================
FILE: z:\EmulatRApp\CBoxLib\CBoxBase.h
LINE: 292
SIGNATURE:
	AXP_FLATTEN void executeFBLT(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept

BODY (preview):
	AXP_FLATTEN void executeFBLT(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept {
		// Current PC points at branch instruction
		const quint64 pc = ctx.getPC();

		// FPCR condition: EQ (equal)
		// ASA: FP branch tests FP condition codes set by prior FP compare
		const bool conditionMet = ctx.fpcrLT();

		// Signed 16-bit displacement, scaled by 4 bytes
		const qint64 disp =
			static_cast<qint16>(getMemDisp(slot.di));

		const qint64 byteOffset = disp << 2;

		// Alpha branches are relative to PC + 4

================================================================================
FILE: z:\EmulatRApp\CBoxLib\CBoxBase.h
LINE: 313
SIGNATURE:
	AXP_FLATTEN void executeFBLE(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept

BODY (preview):
	AXP_FLATTEN void executeFBLE(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept {
		// Current PC points at branch instruction
		const quint64 pc = ctx.getPC();

		// FPCR condition: EQ (equal)
		// ASA: FP branch tests FP condition codes set by prior FP compare
		const bool conditionMet = ctx.fpcrLE();

		// Signed 16-bit displacement, scaled by 4 bytes
		const qint64 disp =
			static_cast<qint16>(getMemDisp(slot.di));

		const qint64 byteOffset = disp << 2;

		// Alpha branches are relative to PC + 4

================================================================================
FILE: z:\EmulatRApp\CBoxLib\CBoxBase.h
LINE: 335
SIGNATURE:
	AXP_FLATTEN void executeFBGT(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept

BODY (preview):
	AXP_FLATTEN void executeFBGT(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept {
		// Current PC points at branch instruction
		const quint64 pc = ctx.getPC();

		// FPCR condition: EQ (equal)
		// ASA: FP branch tests FP condition codes set by prior FP compare
		const bool conditionMet = ctx.fpcrGT();

		// Signed 16-bit displacement, scaled by 4 bytes
		const qint64 disp =
			static_cast<qint16>(getMemDisp(slot.di));

		const qint64 byteOffset = disp << 2;

		// Alpha branches are relative to PC + 4

================================================================================
FILE: z:\EmulatRApp\CBoxLib\CBoxBase.h
LINE: 356
SIGNATURE:
	AXP_FLATTEN void executeFBGE(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept

BODY (preview):
	AXP_FLATTEN void executeFBGE(AlphaProcessorContext& ctx, PipelineSlot& slot) noexcept {
		// Current PC points at branch instruction
		const quint64 pc = ctx.getPC();

		// FPCR condition: EQ (equal)
		// ASA: FP branch tests FP condition codes set by prior FP compare
		const bool conditionMet = ctx.fpcrGE();

		// Signed 16-bit displacement, scaled by 4 bytes
		const qint64 disp =
			static_cast<qint16>(getMemDisp(slot.di));

		const qint64 byteOffset = disp << 2;

		// Alpha branches are relative to PC + 4

================================================================================
FILE: z:\EmulatRApp\CBoxLib\CBoxBase.h
LINE: 389
SIGNATURE:
	AXP_FLATTEN BranchPredictor& getBranchPredictor() noexcept

BODY (preview):
	AXP_FLATTEN BranchPredictor& getBranchPredictor() noexcept {
		return m_branchPredictor;
	}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\CBoxBase.h
LINE: 470
SIGNATURE:
 if(m_ctx) 

BODY (preview):
		if (m_ctx) {
			m_ctx->requestPipelineFlush(correctPC);
		}

================================================================================
FILE: z:\EmulatRApp\CBoxLib\CBoxBase.h
LINE: 521
SIGNATURE:
 	void flushPipeline() noexcept

BODY (preview):
	// 	void flushPipeline() noexcept { /* TODO */ }
	// 	void restartFetch(quint64 pc) noexcept { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\CBoxLib\CBoxBase.h
LINE: 522
SIGNATURE:
 	void restartFetch(quint64 pc) noexcept

BODY (preview):
	// 	void restartFetch(quint64 pc) noexcept { /* TODO */ }
};

#endif // CBOXBASE_H

================================================================================
FILE: z:\EmulatRApp\controllersLib\PciScsiConfigBinder.h
LINE: 313
SIGNATURE:
    if(dev) 

BODY (preview):
			//     if (dev) {
			//         bc.vscsi->attachDevice(static_cast<quint8>(targetId),
			//                                lun,
			//                                dev);
			//         bd.device = dev;
			//     }

================================================================================
FILE: z:\EmulatRApp\controllersLib\PciScsiDmaChannel.h
LINE: 37
SIGNATURE:
       void guestWritesDmaControl(quint32 val) 

BODY (preview):
//       void guestWritesDmaControl(quint32 val) {
//           if (val & START_BIT) m_dmaChannel.start();
//           if (val & STOP_BIT)  m_dmaChannel.stop();
//       }

================================================================================
FILE: z:\EmulatRApp\controllersLib\PciScsiInterruptController.h
LINE: 30
SIGNATURE:
       void someInternalEvent() 

BODY (preview):
//       void someInternalEvent() {
//           m_irqCtl.raiseReason(PciScsiInterruptReason::CommandComplete);
//           if (m_irqCtl.hasPending()) {
//               raiseInterrupt();   // PciScsiDevice's hook
//           }
//       }

================================================================================
FILE: z:\EmulatRApp\controllersLib\PciScsiInterruptController.h
LINE: 37
SIGNATURE:
       void guestWritesAckRegister(quint32 ackBits) 

BODY (preview):
//       void guestWritesAckRegister(quint32 ackBits) {
//           m_irqCtl.acknowledge(ackBits);
//           if (!m_irqCtl.hasPending()) {
//               clearInterrupt();
//           }
//       }

================================================================================
FILE: z:\EmulatRApp\controllersLib\PciScsiMmioInterface.h
LINE: 97
SIGNATURE:
	virtual void setDeviceUid(quint32 uid) noexcept

BODY (preview):
	virtual void setDeviceUid(quint32 uid) noexcept { m_deviceUid = uid; }


================================================================================
FILE: z:\EmulatRApp\controllersLib\PciScsiMmioInterface.h
LINE: 99
SIGNATURE:
	virtual void mmioReset() noexcept

BODY (preview):
	virtual void mmioReset() noexcept  { /* default: no-op */ }
	virtual void mmioFence(palCore_FenceKind) noexcept  { /* default: no-op */ }

================================================================================
FILE: z:\EmulatRApp\controllersLib\PciScsiMmioInterface.h
LINE: 100
SIGNATURE:
	virtual void mmioFence(palCore_FenceKind) noexcept

BODY (preview):
	virtual void mmioFence(palCore_FenceKind) noexcept  { /* default: no-op */ }


================================================================================
FILE: z:\EmulatRApp\controllersLib\PciScsiScriptEngine.h
LINE: 202
SIGNATURE:
	virtual void onEngineStart() noexcept

BODY (preview):
	virtual void onEngineStart() noexcept {}
	virtual void onEngineStop()  noexcept {}

================================================================================
FILE: z:\EmulatRApp\controllersLib\PciScsiScriptEngine.h
LINE: 203
SIGNATURE:
	virtual void onEngineStop() noexcept

BODY (preview):
	virtual void onEngineStop()  noexcept {}
	virtual void onEngineReset() noexcept {}

================================================================================
FILE: z:\EmulatRApp\controllersLib\PciScsiScriptEngine.h
LINE: 204
SIGNATURE:
	virtual void onEngineReset() noexcept

BODY (preview):
	virtual void onEngineReset() noexcept {}


================================================================================
FILE: z:\EmulatRApp\controllersLib\ScsiTargetPort.h
LINE: 89
SIGNATURE:
	inline void setName(const QString& name) noexcept

BODY (preview):
	inline void setName(const QString& name) noexcept { m_name = name; }


================================================================================
FILE: z:\EmulatRApp\controllersLib\ScsiTargetPort.h
LINE: 92
SIGNATURE:
	inline void setWorldWideName(quint64 wwn) noexcept

BODY (preview):
	inline void setWorldWideName(quint64 wwn) noexcept { m_wwn = wwn; }


================================================================================
FILE: z:\EmulatRApp\controllersLib\ScsiTargetPort.h
LINE: 98
SIGNATURE:
	inline ScsiBus* bus() noexcept

BODY (preview):
	inline ScsiBus* bus() noexcept { return m_bus; }
	inline const ScsiBus* bus() const noexcept { return m_bus; }

================================================================================
FILE: z:\EmulatRApp\controllersLib\ScsiTargetPort.h
LINE: 100
SIGNATURE:
	inline void setBus(ScsiBus* b) noexcept

BODY (preview):
	inline void setBus(ScsiBus* b) noexcept { m_bus = b; }


================================================================================
FILE: z:\EmulatRApp\controllersLib\ScsiTargetPort.h
LINE: 115
SIGNATURE:
	inline void setTargetId(quint8 tid) noexcept

BODY (preview):
	inline void setTargetId(quint8 tid) noexcept { m_targetId = tid; }
	inline quint8 targetId() const noexcept { return m_targetId; }

================================================================================
FILE: z:\EmulatRApp\controllersLib_\PciScsiConfigBinder.h
LINE: 313
SIGNATURE:
    if(dev) 

BODY (preview):
			//     if (dev) {
			//         bc.vscsi->attachDevice(static_cast<quint8>(targetId),
			//                                lun,
			//                                dev);
			//         bd.device = dev;
			//     }

================================================================================
FILE: z:\EmulatRApp\controllersLib_\PciScsiDmaChannel.h
LINE: 37
SIGNATURE:
       void guestWritesDmaControl(quint32 val) 

BODY (preview):
//       void guestWritesDmaControl(quint32 val) {
//           if (val & START_BIT) m_dmaChannel.start();
//           if (val & STOP_BIT)  m_dmaChannel.stop();
//       }

================================================================================
FILE: z:\EmulatRApp\controllersLib_\PciScsiInterruptController.h
LINE: 30
SIGNATURE:
       void someInternalEvent() 

BODY (preview):
//       void someInternalEvent() {
//           m_irqCtl.raiseReason(PciScsiInterruptReason::CommandComplete);
//           if (m_irqCtl.hasPending()) {
//               raiseInterrupt();   // PciScsiDevice's hook
//           }
//       }

================================================================================
FILE: z:\EmulatRApp\controllersLib_\PciScsiInterruptController.h
LINE: 37
SIGNATURE:
       void guestWritesAckRegister(quint32 ackBits) 

BODY (preview):
//       void guestWritesAckRegister(quint32 ackBits) {
//           m_irqCtl.acknowledge(ackBits);
//           if (!m_irqCtl.hasPending()) {
//               clearInterrupt();
//           }
//       }

================================================================================
FILE: z:\EmulatRApp\controllersLib_\PciScsiMmioInterface.h
LINE: 97
SIGNATURE:
	virtual void setDeviceUid(quint32 uid) noexcept

BODY (preview):
	virtual void setDeviceUid(quint32 uid) noexcept { m_deviceUid = uid; }


================================================================================
FILE: z:\EmulatRApp\controllersLib_\PciScsiMmioInterface.h
LINE: 99
SIGNATURE:
	virtual void mmioReset() noexcept

BODY (preview):
	virtual void mmioReset() noexcept  { /* default: no-op */ }
	virtual void mmioFence(palCore_FenceKind) noexcept  { /* default: no-op */ }

================================================================================
FILE: z:\EmulatRApp\controllersLib_\PciScsiMmioInterface.h
LINE: 100
SIGNATURE:
	virtual void mmioFence(palCore_FenceKind) noexcept

BODY (preview):
	virtual void mmioFence(palCore_FenceKind) noexcept  { /* default: no-op */ }


================================================================================
FILE: z:\EmulatRApp\controllersLib_\PciScsiScriptEngine.h
LINE: 202
SIGNATURE:
	virtual void onEngineStart() noexcept

BODY (preview):
	virtual void onEngineStart() noexcept {}
	virtual void onEngineStop()  noexcept {}

================================================================================
FILE: z:\EmulatRApp\controllersLib_\PciScsiScriptEngine.h
LINE: 203
SIGNATURE:
	virtual void onEngineStop() noexcept

BODY (preview):
	virtual void onEngineStop()  noexcept {}
	virtual void onEngineReset() noexcept {}

================================================================================
FILE: z:\EmulatRApp\controllersLib_\PciScsiScriptEngine.h
LINE: 204
SIGNATURE:
	virtual void onEngineReset() noexcept

BODY (preview):
	virtual void onEngineReset() noexcept {}


================================================================================
FILE: z:\EmulatRApp\controllersLib_\ScsiTargetPort.h
LINE: 89
SIGNATURE:
	inline void setName(const QString& name) noexcept

BODY (preview):
	inline void setName(const QString& name) noexcept { m_name = name; }


================================================================================
FILE: z:\EmulatRApp\controllersLib_\ScsiTargetPort.h
LINE: 92
SIGNATURE:
	inline void setWorldWideName(quint64 wwn) noexcept

BODY (preview):
	inline void setWorldWideName(quint64 wwn) noexcept { m_wwn = wwn; }


================================================================================
FILE: z:\EmulatRApp\controllersLib_\ScsiTargetPort.h
LINE: 98
SIGNATURE:
	inline ScsiBus* bus() noexcept

BODY (preview):
	inline ScsiBus* bus() noexcept { return m_bus; }
	inline const ScsiBus* bus() const noexcept { return m_bus; }

================================================================================
FILE: z:\EmulatRApp\controllersLib_\ScsiTargetPort.h
LINE: 100
SIGNATURE:
	inline void setBus(ScsiBus* b) noexcept

BODY (preview):
	inline void setBus(ScsiBus* b) noexcept { m_bus = b; }


================================================================================
FILE: z:\EmulatRApp\controllersLib_\ScsiTargetPort.h
LINE: 115
SIGNATURE:
	inline void setTargetId(quint8 tid) noexcept

BODY (preview):
	inline void setTargetId(quint8 tid) noexcept { m_targetId = tid; }
	inline quint8 targetId() const noexcept { return m_targetId; }

================================================================================
FILE: z:\EmulatRApp\coreLib\AlphaAccessSequenceGenerator.h
LINE: 35
SIGNATURE:
           TimerHolder() 

BODY (preview):
            TimerHolder() { timer.start(); }
        };
        static TimerHolder th; // guaranteed thread-safe init in C++11+

        const quint64 seqId = counter.fetchAndAddRelaxed(1);               // returns old value
        const quint64 ts    = static_cast<quint64>(th.timer.nsecsElapsed()); // qint64 -> quint64

        return SequenceInfo{ seqId, ts };
    }

};

// Usage:
// GlobalAccessSequencer::SequenceInfo access = GlobalAccessSequencer::next();
// access.sequenceId -> unique id, access.timestampNs -> timestamp in ns

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 40
SIGNATURE:
	inline s64 sext32(u32 v) noexcept

BODY (preview):
	inline s64 sext32(u32 v) noexcept { return static_cast<s64>(static_cast<s32>(v)); }
	inline s64 sext32(u64 v) noexcept { return static_cast<s64>(static_cast<s32>(v & 0xFFFF'FFFFULL)); }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 41
SIGNATURE:
	inline s64 sext32(u64 v) noexcept

BODY (preview):
	inline s64 sext32(u64 v) noexcept { return static_cast<s64>(static_cast<s32>(v & 0xFFFF'FFFFULL)); }


================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 44
SIGNATURE:
	inline s64 asL(u64 v) noexcept

BODY (preview):
	inline s64 asL(u64 v) noexcept { return sext32(v); }


================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 47
SIGNATURE:
	inline s64 asQ(u64 v) noexcept

BODY (preview):
	inline s64 asQ(u64 v) noexcept { return static_cast<s64>(v); }


================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 113
SIGNATURE:
	inline bool isZeroL(u64 v) noexcept

BODY (preview):
	inline bool isZeroL(u64 v) noexcept { return (static_cast<u32>(v) == 0); }
	inline bool isZeroQ(u64 v) noexcept { return (v == 0); }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 114
SIGNATURE:
	inline bool isZeroQ(u64 v) noexcept

BODY (preview):
	inline bool isZeroQ(u64 v) noexcept { return (v == 0); }


================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 116
SIGNATURE:
	inline bool isNegL(u64 v) noexcept

BODY (preview):
	inline bool isNegL(u64 v) noexcept { return (static_cast<s32>(v) < 0); }
	inline bool isNegQ(u64 v) noexcept { return (static_cast<s64>(v) < 0); }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 117
SIGNATURE:
	inline bool isNegQ(u64 v) noexcept

BODY (preview):
	inline bool isNegQ(u64 v) noexcept { return (static_cast<s64>(v) < 0); }


================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 119
SIGNATURE:
	inline bool signBitL(u64 v) noexcept

BODY (preview):
	inline bool signBitL(u64 v) noexcept { return (v & SIGNBIT_32) != 0; }
	inline bool signBitQ(u64 v) noexcept { return (v & SIGNBIT_64) != 0; }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 120
SIGNATURE:
	inline bool signBitQ(u64 v) noexcept

BODY (preview):
	inline bool signBitQ(u64 v) noexcept { return (v & SIGNBIT_64) != 0; }


================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 125
SIGNATURE:
	inline bool cmpEqL(u64 a, u64 b) noexcept

BODY (preview):
	inline bool cmpEqL(u64 a, u64 b) noexcept { return static_cast<s32>(a) == static_cast<s32>(b); }
	inline bool cmpEqQ(u64 a, u64 b) noexcept { return static_cast<s64>(a) == static_cast<s64>(b); }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 126
SIGNATURE:
	inline bool cmpEqQ(u64 a, u64 b) noexcept

BODY (preview):
	inline bool cmpEqQ(u64 a, u64 b) noexcept { return static_cast<s64>(a) == static_cast<s64>(b); }


================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 128
SIGNATURE:
	inline bool cmpLtL(u64 a, u64 b) noexcept

BODY (preview):
	inline bool cmpLtL(u64 a, u64 b) noexcept { return static_cast<s32>(a) < static_cast<s32>(b); }
	inline bool cmpLtQ(u64 a, u64 b) noexcept { return static_cast<s64>(a) < static_cast<s64>(b); }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 129
SIGNATURE:
	inline bool cmpLtQ(u64 a, u64 b) noexcept

BODY (preview):
	inline bool cmpLtQ(u64 a, u64 b) noexcept { return static_cast<s64>(a) < static_cast<s64>(b); }


================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 131
SIGNATURE:
	inline bool cmpLeL(u64 a, u64 b) noexcept

BODY (preview):
	inline bool cmpLeL(u64 a, u64 b) noexcept { return static_cast<s32>(a) <= static_cast<s32>(b); }
	inline bool cmpLeQ(u64 a, u64 b) noexcept { return static_cast<s64>(a) <= static_cast<s64>(b); }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 132
SIGNATURE:
	inline bool cmpLeQ(u64 a, u64 b) noexcept

BODY (preview):
	inline bool cmpLeQ(u64 a, u64 b) noexcept { return static_cast<s64>(a) <= static_cast<s64>(b); }


================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 156
SIGNATURE:
	inline u64 logicalAnd(u64 a, u64 b) noexcept

BODY (preview):
	inline u64 logicalAnd(u64 a, u64 b) noexcept { return a & b; }
	inline u64 logicalOr(u64 a, u64 b) noexcept { return a | b; }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 157
SIGNATURE:
	inline u64 logicalOr(u64 a, u64 b) noexcept

BODY (preview):
	inline u64 logicalOr(u64 a, u64 b) noexcept { return a | b; }
	inline u64 logicalXor(u64 a, u64 b) noexcept { return a ^ b; }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 158
SIGNATURE:
	inline u64 logicalXor(u64 a, u64 b) noexcept

BODY (preview):
	inline u64 logicalXor(u64 a, u64 b) noexcept { return a ^ b; }
	inline u64 logicalNand(u64 a, u64 b) noexcept { return ~(a & b); }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 159
SIGNATURE:
	inline u64 logicalNand(u64 a, u64 b) noexcept

BODY (preview):
	inline u64 logicalNand(u64 a, u64 b) noexcept { return ~(a & b); }
	inline u64 logicalNor(u64 a, u64 b) noexcept { return ~(a | b); }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_alu_inl.h
LINE: 160
SIGNATURE:
	inline u64 logicalNor(u64 a, u64 b) noexcept

BODY (preview):
	inline u64 logicalNor(u64 a, u64 b) noexcept { return ~(a | b); }


================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_fp_helpers_inl.h
LINE: 18
SIGNATURE:
 switch(variant.roundingMode) 

BODY (preview):
		switch (variant.roundingMode) {
		case AlphaFP::FpRoundingMode::RoundToNearest:
			std::fesetround(FE_TONEAREST);
			break;

		case AlphaFP::FpRoundingMode::RoundTowardZero:
			std::fesetround(FE_TOWARDZERO);
			break;

		case AlphaFP::FpRoundingMode::RoundUp:
			std::fesetround(FE_UPWARD);
			break;

		case AlphaFP::FpRoundingMode::RoundDown:
			std::fesetround(FE_DOWNWARD);

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_fp_helpers_inl.h
LINE: 55
SIGNATURE:
 if(exceptions & FE_UNDERFLOW) 

BODY (preview):
		if (exceptions & FE_UNDERFLOW) {
			if (!variant.suppressUnderflow) {
				fpcr |= AlphaFPCR::UNF;
			}
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_fp_helpers_inl.h
LINE: 56
SIGNATURE:
	 if(!variant.suppressUnderflow) 

BODY (preview):
			if (!variant.suppressUnderflow) {
				fpcr |= AlphaFPCR::UNF;
			}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_fp_helpers_inl.h
LINE: 62
SIGNATURE:
 if(exceptions & FE_INEXACT) 

BODY (preview):
		if (exceptions & FE_INEXACT) {
			if (!variant.suppressInexact) {
				fpcr |= AlphaFPCR::INE;
			}
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_fp_helpers_inl.h
LINE: 63
SIGNATURE:
	 if(!variant.suppressInexact) 

BODY (preview):
			if (!variant.suppressInexact) {
				fpcr |= AlphaFPCR::INE;
			}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_fp_helpers_inl.h
LINE: 323
SIGNATURE:
 if(unordered) 

BODY (preview):
		if (unordered) {
			fpcr |= AlphaFPCR::INV;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_byteops_inl.h
LINE: 41
SIGNATURE:
   for(int i = 0; i < 8; i++) 

BODY (preview):
    for (int i = 0; i < 8; i++) {
        if ((mask & (1ULL << i)) == 0) {  // If bit NOT set, keep byte
            byteMask |= (0xFFULL << (i * 8));
        }
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_byteops_inl.h
LINE: 54
SIGNATURE:
   for(int i = 0; i < 8; i++) 

BODY (preview):
    for (int i = 0; i < 8; i++) {
        if (mask & (1ULL << i)) {
            result &= ~(0xFFULL << (i * 8));
        }
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_byteops_inl.h
LINE: 72
SIGNATURE:
   for(int i = 0; i < 8; i++) 

BODY (preview):
    for (int i = 0; i < 8; i++) {
        if (mask & (1ULL << i)) {  // If bit set, keep byte
            byteMask |= (0xFFULL << (i * 8));
        }
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_byteops_inl.h
LINE: 85
SIGNATURE:
   for(int i = 0; i < 8; i++) 

BODY (preview):
    for (int i = 0; i < 8; i++) {
        if (mask & (1ULL << i)) {
            result |= value & (0xFFULL << (i * 8));
        }
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 14
SIGNATURE:
 : overflow(false) 

BODY (preview):
    IntStatus() : overflow(false) {}
    constexpr bool hasError() const noexcept { return overflow; }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 32
SIGNATURE:
inline qint32 addL(qint32 a, qint32 b, IntStatus& status) noexcept

BODY (preview):
inline qint32 addL(qint32 a, qint32 b, IntStatus& status) noexcept {
    qint32 result = a + b;

    if ((a > 0 && b > 0 && result < 0) ||
        (a < 0 && b < 0 && result > 0)) {
        status.overflow = true;
    }
    return result;
}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 42
SIGNATURE:
inline qint32 subL(qint32 a, qint32 b, IntStatus& status) noexcept

BODY (preview):
inline qint32 subL(qint32 a, qint32 b, IntStatus& status) noexcept {
    qint32 result = a - b;

    if ((a > 0 && b < 0 && result < 0) ||
        (a < 0 && b > 0 && result > 0)) {
        status.overflow = true;
    }
    return result;
}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 52
SIGNATURE:
inline qint32 mulL(qint32 a, qint32 b, IntStatus& status) noexcept

BODY (preview):
inline qint32 mulL(qint32 a, qint32 b, IntStatus& status) noexcept {
    qint64 wide = static_cast<qint64>(a) * static_cast<qint64>(b);
    qint32 result = static_cast<qint32>(wide);

    if (wide != static_cast<qint64>(result)) {
        status.overflow = true;
    }
    return result;
}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 65
SIGNATURE:
inline qint64 addQ(qint64 a, qint64 b, IntStatus& status) noexcept

BODY (preview):
inline qint64 addQ(qint64 a, qint64 b, IntStatus& status) noexcept {
    qint64 result = a + b;

    if ((a > 0 && b > 0 && result < 0) ||
        (a < 0 && b < 0 && result > 0)) {
        status.overflow = true;
    }
    return result;
}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 75
SIGNATURE:
inline qint64 subQ(qint64 a, qint64 b, IntStatus& status) noexcept

BODY (preview):
inline qint64 subQ(qint64 a, qint64 b, IntStatus& status) noexcept {
    qint64 result = a - b;

    if ((a > 0 && b < 0 && result < 0) ||
        (a < 0 && b > 0 && result > 0)) {
        status.overflow = true;
    }
    return result;
}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 85
SIGNATURE:
inline qint64 mulQ(qint64 a, qint64 b, IntStatus& status) noexcept

BODY (preview):
inline qint64 mulQ(qint64 a, qint64 b, IntStatus& status) noexcept {
#ifdef __SIZEOF_INT128__
    __int128 wide = static_cast<__int128>(a) * static_cast<__int128>(b);
    qint64 result = static_cast<qint64>(wide);

    if (wide != static_cast<__int128>(result)) {
        status.overflow = true;
    }
    return result;
#else
    qint64 result = a * b;

    if (a != 0 && b != 0) {
        if ((a == -1 && b == std::numeric_limits<qint64>::min()) ||
            (b == -1 && a == std::numeric_limits<qint64>::min())) {

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 97
SIGNATURE:
   if(a != 0 && b != 0) 

BODY (preview):
    if (a != 0 && b != 0) {
        if ((a == -1 && b == std::numeric_limits<qint64>::min()) ||
            (b == -1 && a == std::numeric_limits<qint64>::min())) {
            status.overflow = true;
        }
        else if (result / a != b) {
            status.overflow = true;
        }
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 102
SIGNATURE:
        else if(result / a != b) 

BODY (preview):
        else if (result / a != b) {
            status.overflow = true;
        }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 113
SIGNATURE:
inline quint64 addQU(quint64 a, quint64 b, IntStatus& status) noexcept

BODY (preview):
inline quint64 addQU(quint64 a, quint64 b, IntStatus& status) noexcept {
    quint64 result = a + b;
    if (result < a) status.overflow = true;
    return result;
}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 119
SIGNATURE:
inline quint64 subQU(quint64 a, quint64 b, IntStatus& status) noexcept

BODY (preview):
inline quint64 subQU(quint64 a, quint64 b, IntStatus& status) noexcept {
    quint64 result = a - b;
    if (a < b) status.overflow = true;
    return result;
}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 125
SIGNATURE:
inline quint64 mulQU(quint64 a, quint64 b, IntStatus& status) noexcept

BODY (preview):
inline quint64 mulQU(quint64 a, quint64 b, IntStatus& status) noexcept {
    quint64 result = a * b;
    if (b != 0 && result / b != a) status.overflow = true;
    return result;
}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 134
SIGNATURE:
inline quint64 andQ(quint64 a, quint64 b) noexcept

BODY (preview):
inline quint64 andQ(quint64 a, quint64 b) noexcept { return a & b; }
inline quint64 orQ (quint64 a, quint64 b) noexcept { return a | b; }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 135
SIGNATURE:
inline quint64 orQ(quint64 a, quint64 b) noexcept

BODY (preview):
inline quint64 orQ (quint64 a, quint64 b) noexcept { return a | b; }
inline quint64 xorQ(quint64 a, quint64 b) noexcept { return a ^ b; }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 136
SIGNATURE:
inline quint64 xorQ(quint64 a, quint64 b) noexcept

BODY (preview):
inline quint64 xorQ(quint64 a, quint64 b) noexcept { return a ^ b; }
inline quint64 notQ(quint64 a) noexcept             { return ~a; }

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 137
SIGNATURE:
inline quint64 notQ(quint64 a) noexcept

BODY (preview):
inline quint64 notQ(quint64 a) noexcept             { return ~a; }


================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 142
SIGNATURE:
inline quint64 sllQ(quint64 v, int s) noexcept

BODY (preview):
inline quint64 sllQ(quint64 v, int s) noexcept {
    if (s >= 64) return 0;
    if (s < 0) return v;
    return v << s;
}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 148
SIGNATURE:
inline quint64 srlQ(quint64 v, int s) noexcept

BODY (preview):
inline quint64 srlQ(quint64 v, int s) noexcept {
    if (s >= 64) return 0;
    if (s < 0) return v;
    return v >> s;
}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 154
SIGNATURE:
inline qint64 sraQ(qint64 v, int s) noexcept

BODY (preview):
inline qint64 sraQ(qint64 v, int s) noexcept {
    if (s >= 64) return (v < 0) ? -1 : 0;
    if (s < 0) return v;
    return v >> s;
}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_int_helpers_inl.h
LINE: 170
SIGNATURE:
inline bool isTrappingVariant(quint8 opcode, quint16 function) noexcept

BODY (preview):
inline bool isTrappingVariant(quint8 opcode, quint16 function) noexcept {
    if (opcode != 0x10)
        return false;
    constexpr quint16 TRAP_BIT = 0x40;
    return (function & TRAP_BIT) != 0;
}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_SSE_fp_inl.h
LINE: 25
SIGNATURE:
 if(Config::useSSE2 && !Config::forceFallback) 

BODY (preview):
		if (Config::useSSE2 && !Config::forceFallback) {
			__m128i va = _mm_cvtsi64_si128(a);
			__m128i vb = _mm_cvtsi64_si128(b);
			__m128i vresult = _mm_add_epi64(va, vb);
			result = _mm_cvtsi128_si64(vresult);

			// Check for unsigned overflow
			if (result < a) {
				status.intOverflow = true;
			}
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_SSE_fp_inl.h
LINE: 32
SIGNATURE:
	 if(result < a) 

BODY (preview):
			if (result < a) {
				status.intOverflow = true;
			}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_SSE_fp_inl.h
LINE: 38
SIGNATURE:
	 if(result < a) 

BODY (preview):
			if (result < a) {
				status.intOverflow = true;
			}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_SSE_fp_inl.h
LINE: 52
SIGNATURE:
 if(Config::useSSE2 && !Config::forceFallback) 

BODY (preview):
		if (Config::useSSE2 && !Config::forceFallback) {
			__m128i va = _mm_cvtsi64_si128(a);
			__m128i vb = _mm_cvtsi64_si128(b);
			__m128i vresult = _mm_add_epi64(va, vb);
			result = _mm_cvtsi128_si64(vresult);
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_SSE_fp_inl.h
LINE: 77
SIGNATURE:
 if(Config::useSSE2 && !Config::forceFallback) 

BODY (preview):
		if (Config::useSSE2 && !Config::forceFallback) {
			__m128i va = _mm_cvtsi64_si128(a);
			__m128i vb = _mm_cvtsi64_si128(b);
			__m128i vresult = _mm_sub_epi64(va, vb);
			result = _mm_cvtsi128_si64(vresult);

			// Check for unsigned underflow
			if (a < b) {
				status.intOverflow = true;
			}
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_SSE_fp_inl.h
LINE: 84
SIGNATURE:
	 if(a < b) 

BODY (preview):
			if (a < b) {
				status.intOverflow = true;
			}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_SSE_fp_inl.h
LINE: 90
SIGNATURE:
	 if(a < b) 

BODY (preview):
			if (a < b) {
				status.intOverflow = true;
			}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_SSE_fp_inl.h
LINE: 105
SIGNATURE:
 if(b != 0 && result / b != a) 

BODY (preview):
		if (b != 0 && result / b != a) {
			status.intOverflow = true;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_SSE_fp_inl.h
LINE: 124
SIGNATURE:
 if(Config::useSSE2 && !Config::forceFallback) 

BODY (preview):
		if (Config::useSSE2 && !Config::forceFallback) {
			__m128d va = _mm_load_sd(&a);
			__m128d vb = _mm_load_sd(&b);
			__m128d vresult = _mm_add_sd(va, vb);
			_mm_store_sd(&result, vresult);
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_SSE_fp_inl.h
LINE: 146
SIGNATURE:
 if(Config::useSSE2 && !Config::forceFallback) 

BODY (preview):
		if (Config::useSSE2 && !Config::forceFallback) {
			__m128d va = _mm_load_sd(&a);
			__m128d vb = _mm_load_sd(&b);
			__m128d vresult = _mm_sub_sd(va, vb);
			_mm_store_sd(&result, vresult);
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_SSE_fp_inl.h
LINE: 168
SIGNATURE:
 if(Config::useSSE2 && !Config::forceFallback) 

BODY (preview):
		if (Config::useSSE2 && !Config::forceFallback) {
			__m128d va = _mm_load_sd(&a);
			__m128d vb = _mm_load_sd(&b);
			__m128d vresult = _mm_mul_sd(va, vb);
			_mm_store_sd(&result, vresult);
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_SSE_fp_inl.h
LINE: 189
SIGNATURE:
 if(b == 0.0) 

BODY (preview):
		if (b == 0.0) {
			status.divByZero = true;
			result = std::copysign(INFINITY, a);
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_SSE_fp_inl.h
LINE: 196
SIGNATURE:
	 if(Config::useSSE2 && !Config::forceFallback) 

BODY (preview):
			if (Config::useSSE2 && !Config::forceFallback) {
				__m128d va = _mm_load_sd(&a);
				__m128d vb = _mm_load_sd(&b);
				__m128d vresult = _mm_div_sd(va, vb);
				_mm_store_sd(&result, vresult);
			}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_SSE_fp_inl.h
LINE: 218
SIGNATURE:
 if(a < 0.0) 

BODY (preview):
		if (a < 0.0) {
			status.invalid = true;
			result = std::numeric_limits<double>::quiet_NaN();
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_SSE_fp_inl.h
LINE: 225
SIGNATURE:
	 if(Config::useSSE2 && !Config::forceFallback) 

BODY (preview):
			if (Config::useSSE2 && !Config::forceFallback) {
				__m128d va = _mm_load_sd(&a);
				__m128d vresult = _mm_sqrt_sd(va, va);
				_mm_store_sd(&result, vresult);
			}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_SSE_fp_inl.h
LINE: 282
SIGNATURE:
 if(Config::useSSE2 && !Config::forceFallback) 

BODY (preview):
		if (Config::useSSE2 && !Config::forceFallback) {
			__m128i va = _mm_set_epi64x(a.high, a.low);
			__m128i vb = _mm_set_epi64x(b.high, b.low);
			__m128i vresult = _mm_add_epi64(va, vb);

			result.low = _mm_cvtsi128_si64(vresult);
			result.high = _mm_cvtsi128_si64(_mm_srli_si128(vresult, 8));

			// Check both for overflow
			if (result.low < a.low)  status.intOverflow = true;
			if (result.high < a.high) status.intOverflow = true;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_SSE_int_inl.h
LINE: 23
SIGNATURE:
 if(Config::useSSE2 && !Config::forceFallback) 

BODY (preview):
		if (Config::useSSE2 && !Config::forceFallback) {
			__m128i va = _mm_cvtsi64_si128(a);
			__m128i vb = _mm_cvtsi64_si128(b);
			__m128i vresult = _mm_add_epi64(va, vb);
			result = _mm_cvtsi128_si64(vresult);
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\alpha_SSE_int_inl.h
LINE: 48
SIGNATURE:
 if(Config::useSSE2 && !Config::forceFallback) 

BODY (preview):
		if (Config::useSSE2 && !Config::forceFallback) {
			__m128i va = _mm_cvtsi64_si128(a);
			__m128i vb = _mm_cvtsi64_si128(b);
			__m128i vresult = _mm_sub_epi64(va, vb);
			result = _mm_cvtsi128_si64(vresult);
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\arithExtender_helpers.h
LINE: 22
SIGNATURE:
inline void seedEmulatrRandom() 

BODY (preview):
inline void seedEmulatrRandom() {
	qsrand(static_cast<quint32>(QTime::currentTime().msec()));
}

================================================================================
FILE: z:\EmulatRApp\coreLib\arithExtender_helpers.h
LINE: 26
SIGNATURE:
inline void seedEmulatrRandom() 

BODY (preview):
inline void seedEmulatrRandom() {} // No-op for QRandomGenerator
#endif

================================================================================
FILE: z:\EmulatRApp\coreLib\arithExtender_helpers.h
LINE: 36
SIGNATURE:
inline quint64 signExtend8(quint8 value) 

BODY (preview):
inline quint64 signExtend8(quint8 value) {
	return static_cast<quint64>(static_cast<qint64>(static_cast<qint8>(value)));
}

================================================================================
FILE: z:\EmulatRApp\coreLib\arithExtender_helpers.h
LINE: 42
SIGNATURE:
inline quint64 signExtend16(quint16 value) 

BODY (preview):
inline quint64 signExtend16(quint16 value) {
	return static_cast<quint64>(static_cast<qint64>(static_cast<qint16>(value)));
}

================================================================================
FILE: z:\EmulatRApp\coreLib\arithExtender_helpers.h
LINE: 49
SIGNATURE:
inline quint64 signExtend32(quint32 value) 

BODY (preview):
inline quint64 signExtend32(quint32 value) {
	return static_cast<quint64>(static_cast<qint64>(static_cast<qint32>(value)));
}

================================================================================
FILE: z:\EmulatRApp\coreLib\arithExtender_helpers.h
LINE: 53
SIGNATURE:
inline quint64 signExtend21(quint32 value) 

BODY (preview):
inline quint64 signExtend21(quint32 value) {
	constexpr quint32 signBit = 1u << 20;
	constexpr quint32 mask = ~((1u << 21) - 1);

	quint64 extended = (value & signBit) ? (value | mask) : value;

	return static_cast<quint64>(static_cast<qint64>(static_cast<qint32>(extended)));
}

================================================================================
FILE: z:\EmulatRApp\coreLib\arithExtender_helpers.h
LINE: 65
SIGNATURE:
static inline quint64 zeroExtend8(qsizetype v) 

BODY (preview):
static inline quint64 zeroExtend8(qsizetype v) {
	return static_cast<quint64>(v);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\arithExtender_helpers.h
LINE: 72
SIGNATURE:
static inline quint64 zeroExtend16(quint16 v) 

BODY (preview):
static inline quint64 zeroExtend16(quint16 v) {
	return static_cast<quint64>(v);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\arithExtender_helpers.h
LINE: 79
SIGNATURE:
static inline quint64 zeroExtend32(quint32 v) 

BODY (preview):
static inline quint64 zeroExtend32(quint32 v) {
	return static_cast<quint64>(v);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\arithExtender_helpers.h
LINE: 84
SIGNATURE:
inline uint countTrailingZeros64(quint64 x) 

BODY (preview):
inline uint countTrailingZeros64(quint64 x) {
	return qCountTrailingZeroBits(x);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\Axp_Attributes_core.h
LINE: 63
SIGNATURE:
   AXP_FLATTEN inline quint64 addFast(quint64 a, quint64 b) noexcept

BODY (preview):
//   AXP_FLATTEN inline quint64 addFast(quint64 a, quint64 b) noexcept {
//       return a + b;
//   }

================================================================================
FILE: z:\EmulatRApp\coreLib\Axp_Attributes_core.h
LINE: 148
SIGNATURE:
  switch(exceptionClass) 

BODY (preview):
//   switch (exceptionClass) {
//   case ExceptionClass::ARITHMETIC: ...
//   case ExceptionClass::MEMORY: ...
//   default:
//       AXP_UNREACHABLE();
//   }

================================================================================
FILE: z:\EmulatRApp\coreLib\cboxCSRState.h
LINE: 320
SIGNATURE:
	inline int getCPUCount() noexcept

BODY (preview):
	inline int getCPUCount() noexcept{ return perCpuState.count(); }
};

// ---------------------------------------------------------------------------
// Global accessor for the CBOX CSR bank
// ---------------------------------------------------------------------------
// This uses a function-local static to lazily construct the per-CPU bank.
// The helper getCPUCount() is expected to be defined in your core library
// (for example, alongside your EmulatorManager / CPU configuration helpers).
// ---------------------------------------------------------------------------
inline CboxCSRBank& global_CboxCSRs(CPUIdType cpuId)
{

================================================================================
FILE: z:\EmulatRApp\coreLib\CPURegistryEntry.h
LINE: 40
SIGNATURE:
	bool hasReservation() 

BODY (preview):
	bool hasReservation() { return m_hasReservation; }
	void setHasReservation(bool bReserved) { m_hasReservation = bReserved; }

================================================================================
FILE: z:\EmulatRApp\coreLib\CPURegistryEntry.h
LINE: 41
SIGNATURE:
	void setHasReservation(bool bReserved) 

BODY (preview):
	void setHasReservation(bool bReserved) { m_hasReservation = bReserved; }
	void setReservationAddr(quint64 regAddress) { m_registrationAddress = regAddress; }

================================================================================
FILE: z:\EmulatRApp\coreLib\CPURegistryEntry.h
LINE: 42
SIGNATURE:
	void setReservationAddr(quint64 regAddress) 

BODY (preview):
	void setReservationAddr(quint64 regAddress) { m_registrationAddress = regAddress; }
	quint64 registrationAddr() { return m_registrationAddress; }

================================================================================
FILE: z:\EmulatRApp\coreLib\CPURegistryEntry.h
LINE: 43
SIGNATURE:
	quint64 registrationAddr() 

BODY (preview):
	quint64 registrationAddr() { return m_registrationAddress; }
	quint64 pendingInterrupts() const { m_pendingInterrupts.loadAcquire(); }

================================================================================
FILE: z:\EmulatRApp\coreLib\CPURegistryEntry.h
LINE: 46
SIGNATURE:
	AlphaCPU* alphaCPU() 

BODY (preview):
	AlphaCPU* alphaCPU() { return m_alphaCpu; }
	bool isActive() const { return m_isActive; }

================================================================================
FILE: z:\EmulatRApp\coreLib\CPURegistryEntry.h
LINE: 60
SIGNATURE:
	void setOnline(bool isOnline) 

BODY (preview):
	void setOnline(bool isOnline) { m_isOnline = isOnline; }
	void setActive(bool isActive) { m_isActive = isActive; }

================================================================================
FILE: z:\EmulatRApp\coreLib\CPURegistryEntry.h
LINE: 61
SIGNATURE:
	void setActive(bool isActive) 

BODY (preview):
	void setActive(bool isActive) { m_isActive = isActive; }
	void setDegraded(bool isDegraded) {
		m_isDegraded = isDegraded;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPURegistryEntry.h
LINE: 62
SIGNATURE:
	void setDegraded(bool isDegraded) 

BODY (preview):
	void setDegraded(bool isDegraded) {
		m_isDegraded = isDegraded;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPURegistryEntry.h
LINE: 65
SIGNATURE:
	void incrementAccessCnt() 

BODY (preview):
	void incrementAccessCnt() { ++m_accessCount; }
	quint64 accessCount() { return m_accessCount; }

================================================================================
FILE: z:\EmulatRApp\coreLib\CPURegistryEntry.h
LINE: 66
SIGNATURE:
	quint64 accessCount() 

BODY (preview):
	quint64 accessCount() { return m_accessCount; }
	void updateLastActivity(quint64 secondsSinceEpoch) { m_lastActivity = secondsSinceEpoch; }

================================================================================
FILE: z:\EmulatRApp\coreLib\CPURegistryEntry.h
LINE: 67
SIGNATURE:
	void updateLastActivity(quint64 secondsSinceEpoch) 

BODY (preview):
	void updateLastActivity(quint64 secondsSinceEpoch) { m_lastActivity = secondsSinceEpoch; }
	CPURegistryEntry() : m_alphaCpu(nullptr), m_cpuId(0), m_isActive(false), m_isOnline(false) {}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPR.h
LINE: 21
SIGNATURE:
	void clearStagedDTBUpdate() 

BODY (preview):
	void clearStagedDTBUpdate() {
		stagedDTBPTE.clear();
		stagedDTBTag.clear();
		hasStagedDTBUpdate = false;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 37
SIGNATURE:
	inline void setInterruptEligibilityDirty(bool bValue) noexcept

BODY (preview):
	inline void setInterruptEligibilityDirty(bool bValue) noexcept { m_interruptEligibilityDirty = bValue; }


================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 66
SIGNATURE:
	inline void setVA(quint64 va) noexcept

BODY (preview):
	inline void setVA(quint64 va) noexcept {
		vaState.setVA(va);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 70
SIGNATURE:
	inline void setVA_CTL(quint64 va_ctl) noexcept

BODY (preview):
	inline void setVA_CTL(quint64 va_ctl) noexcept {
		vaState.setVA_CTL(va_ctl);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 74
SIGNATURE:
	inline void setVAPTB(quint64 ptbr) noexcept

BODY (preview):
	inline void setVAPTB(quint64 ptbr) noexcept {
		vaState.setVPTB(ptbr);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 95
SIGNATURE:
*	inline quint8 cpuId() 

BODY (preview):
	/*	inline quint8 cpuId() { return m_cpuId; }*/


================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 105
SIGNATURE:
	inline void setModePrivilege(Mode_Privilege mp) 

BODY (preview):
	inline void setModePrivilege(Mode_Privilege mp) { m_mode_privilege = mp; }
	// on reset or context restore

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 107
SIGNATURE:
	inline void syncProcessorModeFromIPR(CPUIdType cpuId) 

BODY (preview):
	inline void syncProcessorModeFromIPR(CPUIdType cpuId) {

		quint8 cm = getCM_Active(cpuId);
		m_mode_privilege = static_cast<Mode_Privilege>(cm & 0x7);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 113
SIGNATURE:
	inline void setDTB0ASID(quint8 v) noexcept

BODY (preview):
	inline void setDTB0ASID(quint8 v) noexcept {
		setDTB0ASID_Active(cpuId(), v);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 117
SIGNATURE:
	inline void setDTB1ASID(quint8 v) noexcept

BODY (preview):
	inline void setDTB1ASID(quint8 v) noexcept {
		setDTB1ASID_Active(cpuId(), v);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 168
SIGNATURE:
	void clearReservationSet() 

BODY (preview):
	void clearReservationSet() {  // is a local CPU reservation.

	}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 178
SIGNATURE:
	inline void updateExceptionState(quint64) noexcept

BODY (preview):
	inline void updateExceptionState(quint64) noexcept {}
	inline void updateExceptionVectorTable(quint64) noexcept {}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 179
SIGNATURE:
	inline void updateExceptionVectorTable(quint64) noexcept

BODY (preview):
	inline void updateExceptionVectorTable(quint64) noexcept {}
	inline void logExceptionSummaryChange(quint64, quint64) noexcept {}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 180
SIGNATURE:
	inline void logExceptionSummaryChange(quint64, quint64) noexcept

BODY (preview):
	inline void logExceptionSummaryChange(quint64, quint64) noexcept {}


================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 183
SIGNATURE:
	inline void adjustInstructionFetchOnException(quint64) noexcept

BODY (preview):
	inline void adjustInstructionFetchOnException(quint64) noexcept {}
	inline void notifyExceptionAddressChanged(quint64, quint64) noexcept {}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 184
SIGNATURE:
	inline void notifyExceptionAddressChanged(quint64, quint64) noexcept

BODY (preview):
	inline void notifyExceptionAddressChanged(quint64, quint64) noexcept {}
	inline void evaluateExceptionSummary(quint64) noexcept {}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 185
SIGNATURE:
	inline void evaluateExceptionSummary(quint64) noexcept

BODY (preview):
	inline void evaluateExceptionSummary(quint64) noexcept {}
	inline bool isHardwareErrorPresent(quint64) const noexcept { return false; }

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 187
SIGNATURE:
	inline void triggerMachineCheck(quint64) noexcept

BODY (preview):
	inline void triggerMachineCheck(quint64) noexcept {}
	inline bool shouldGenerateExceptionInterrupt(quint64) const noexcept { return false; }

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 189
SIGNATURE:
	inline void generateExceptionInterrupt(quint64) noexcept

BODY (preview):
	inline void generateExceptionInterrupt(quint64) noexcept {}
	inline void attemptErrorRecovery(quint64, quint64) noexcept {}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 190
SIGNATURE:
	inline void attemptErrorRecovery(quint64, quint64) noexcept

BODY (preview):
	inline void attemptErrorRecovery(quint64, quint64) noexcept {}


================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface.h
LINE: 193
SIGNATURE:
	inline void syncPALcodeExceptionState(quint64) noexcept

BODY (preview):
	inline void syncPALcodeExceptionState(quint64) noexcept {}


================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface_ipl_inl.h
LINE: 9
SIGNATURE:
inline quint8 ipl(CPUStateIPRInterface& cpuState) 

BODY (preview):
inline quint8 ipl(CPUStateIPRInterface& cpuState)  {

	CPUIdType cpuId = cpuState.cpuId();
	auto &irq = global_IRQController();
	return irq.getCPUIpl(cpuId);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface_ipl_inl.h
LINE: 16
SIGNATURE:
inline void raiseIPL(CPUStateIPRInterface& cpuState, quint8 newIPL) noexcept

BODY (preview):
inline void raiseIPL(CPUStateIPRInterface& cpuState, quint8 newIPL)  noexcept {
	CPUIdType cpuId = cpuState.cpuId();
	auto& irq = global_IRQController();
	irq.setCPUIpl(cpuId, newIPL);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface_ipl_inl.h
LINE: 21
SIGNATURE:
inline void lowerIPL(CPUStateIPRInterface& cpuState, quint8 newIpl) noexcept

BODY (preview):
inline void lowerIPL(CPUStateIPRInterface& cpuState, quint8 newIpl) noexcept {
	CPUIdType cpuId = cpuState.cpuId();
	auto& irq = global_IRQController();
	irq.setCPUIpl(cpuId, newIpl);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface_ipl_inl.h
LINE: 26
SIGNATURE:
inline bool canSeeInterrupt(CPUStateIPRInterface& cpuState, quint8 irqIpl) 

BODY (preview):
inline bool canSeeInterrupt(CPUStateIPRInterface& cpuState, quint8 irqIpl)  {
	CPUIdType cpuId = cpuState.cpuId();
	auto& irq = global_IRQController();
	return irq.checkPendingInterrupts(cpuId);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface_ipl_inl.h
LINE: 57
SIGNATURE:
inline quint8 currentMode(CPUStateIPRInterface& cpuState) noexcept

BODY (preview):
inline quint8 currentMode(CPUStateIPRInterface& cpuState)  noexcept {
	CPUIdType cpuId = cpuState.cpuId();
	return getCM_Active(cpuId);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface_ipl_inl.h
LINE: 62
SIGNATURE:
inline void savetoPCB(CPUStateIPRInterface& cpuState) noexcept

BODY (preview):
inline void savetoPCB(CPUStateIPRInterface& cpuState)  noexcept {
	CPUIdType cpuId = cpuState.cpuId();
	setContextSnapshot(cpuId);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface_ipl_inl.h
LINE: 66
SIGNATURE:
inline void restoreFromPCB(CPUStateIPRInterface& cpuState) noexcept

BODY (preview):
inline void restoreFromPCB(CPUStateIPRInterface& cpuState)  noexcept {
	CPUIdType cpuId = cpuState.cpuId();
	restoreContextFromSnapshot(cpuId);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\CPUStateIPRInterface_ipl_inl.h
LINE: 121
SIGNATURE:
quint64 getPendingSoftwareInterrupts(CPUStateIPRInterface* cpuState) 

BODY (preview):
quint64 getPendingSoftwareInterrupts(CPUStateIPRInterface* cpuState) {

}

================================================================================
FILE: z:\EmulatRApp\coreLib\CurrentCpuTls.h
LINE: 8
SIGNATURE:
	inline void set(quint16 id) noexcept

BODY (preview):
	inline void set(quint16 id) noexcept { g_id = id; }
	inline quint16 get() noexcept { return g_id; }

================================================================================
FILE: z:\EmulatRApp\coreLib\CurrentCpuTls.h
LINE: 9
SIGNATURE:
	inline quint16 get() noexcept

BODY (preview):
	inline quint16 get() noexcept { return g_id; }
	inline bool isSet() noexcept { return g_id != std::numeric_limits<quint16>::max(); }

================================================================================
FILE: z:\EmulatRApp\coreLib\CurrentCpuTls.h
LINE: 10
SIGNATURE:
	inline bool isSet() noexcept

BODY (preview):
	inline bool isSet() noexcept { return g_id != std::numeric_limits<quint16>::max(); }
}

================================================================================
FILE: z:\EmulatRApp\coreLib\device_core.h
LINE: 96
SIGNATURE:
 : type(Type::NONE) 

BODY (preview):
// 	DevicePayload() : type(Type::NONE) {}
// 	~DevicePayload() {}

================================================================================
FILE: z:\EmulatRApp\coreLib\device_core.h
LINE: 102
SIGNATURE:
bool hasPayload(const DevicePayload& payload) 

BODY (preview):
bool hasPayload(const DevicePayload& payload) {
	return std::holds_alternative<T>(payload);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\device_core.h
LINE: 157
SIGNATURE:
 inline bool hasKind(NodeKindFlags flags, NodeKindFlags test) 

BODY (preview):
// inline bool hasKind(NodeKindFlags flags, NodeKindFlags test) {
// 	return (flags & test) != NODE_NONE;
// }

================================================================================
FILE: z:\EmulatRApp\coreLib\device_core.h
LINE: 161
SIGNATURE:
inline bool hasKind(NodeKindFlags flags, NodeKindFlags test) 

BODY (preview):
inline bool hasKind(NodeKindFlags flags, NodeKindFlags test) {
	return (static_cast<quint16>(flags) & static_cast<quint16>(test)) != 0;
}

================================================================================
FILE: z:\EmulatRApp\coreLib\device_core.h
LINE: 184
SIGNATURE:
	bool isRoot() 

BODY (preview):
	bool		 isRoot() { return m_bIsRoot; }
	/*DeviceClass deviceClass() { return m_deviceClass;  }*/

================================================================================
FILE: z:\EmulatRApp\coreLib\device_core.h
LINE: 185
SIGNATURE:
*DeviceClass deviceClass() 

BODY (preview):
	/*DeviceClass deviceClass() { return m_deviceClass;  }*/


================================================================================
FILE: z:\EmulatRApp\coreLib\enum_header.h
LINE: 97
SIGNATURE:
inline QString PrivilegeLevelToString(PrivilegeLevel plevel) noexcept

BODY (preview):
inline QString PrivilegeLevelToString(PrivilegeLevel plevel) noexcept {
	switch (plevel)
	{
	case PrivilegeLevel::KERNEL:
		return "Privilege:Kernel";
		
	case PrivilegeLevel::EXECUTIVE:
		return "Privilege:Executive";
	case PrivilegeLevel::SUPERVISOR:
		return "Privilege:Supervisor";
	case PrivilegeLevel::USER:
		return "Privilege:User";
	default:
		break;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\enum_header.h
LINE: 141
SIGNATURE:
inline QString privilegeLevelName(PrivilegeLevel priv) 

BODY (preview):
inline QString privilegeLevelName(PrivilegeLevel priv) {
	switch (priv) {
	case PrivilegeLevel::KERNEL:     return "KERNEL";
	case PrivilegeLevel::EXECUTIVE:  return "EXECUTIVE";
	case PrivilegeLevel::SUPERVISOR: return "SUPERVISOR";
	case PrivilegeLevel::USER:       return "USER";
	default:                          return "UNKNOWN_PRIV";
	}
}

================================================================================
FILE: z:\EmulatRApp\coreLib\globalCPUCount.h
LINE: 12
SIGNATURE:
    static inline void initialize(int count = MAX_CPUS) noexcept

BODY (preview):
    static inline void initialize(int count = MAX_CPUS) noexcept {
        cpuCount_ = count;
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\globalCPUCount.h
LINE: 16
SIGNATURE:
    static inline int get() noexcept

BODY (preview):
    static inline int get() noexcept {
        return cpuCount_;
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\Global_HWPCBBank_Interface.h
LINE: 32
SIGNATURE:
 if(cpuCount > 0 && MAX_CPUS > 0) 

BODY (preview):
		if (cpuCount > 0 && MAX_CPUS > 0) {
			m_perCpu.resize(cpuCount);
			for (int i = 0; i < cpuCount; ++i)
				m_perCpu[i].resize(MAX_CPUS);
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\Global_HWPCBBank_Interface.h
LINE: 60
SIGNATURE:
 	inline void context_save(int cpuId) 

BODY (preview):
// 	inline void context_save(int cpuId) {
// 
// 	}

================================================================================
FILE: z:\EmulatRApp\coreLib\Global_HWPCBBank_Interface.h
LINE: 63
SIGNATURE:
 	inline void context_restore(int cpuId) 

BODY (preview):
// 	inline void context_restore(int cpuId) {
// 
// 	}

================================================================================
FILE: z:\EmulatRApp\coreLib\Global_HWPCBBank_Interface.h
LINE: 76
SIGNATURE:
	inline QVector<QVector<HWPCB>>& rawArray() 

BODY (preview):
	inline QVector<QVector<HWPCB>>& rawArray() { return m_perCpu; }
	inline const QVector<QVector<HWPCB>>& rawArray() const { return m_perCpu; }

================================================================================
FILE: z:\EmulatRApp\coreLib\Global_IPRInterface.h
LINE: 22
SIGNATURE:
	static IPRBank& instance() noexcept

BODY (preview):
	static IPRBank& instance() noexcept {
		static IPRBank iprBank;
		return iprBank;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\Global_IPRInterface.h
LINE: 29
SIGNATURE:
AXP_FLATTEN  IPRBank& globalIPRBank() noexcept

BODY (preview):
AXP_FLATTEN  IPRBank& globalIPRBank() noexcept {
	return GlobalIPRBank::instance();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\global_IRQController.h
LINE: 49
SIGNATURE:
  if(numCpus == 0 || numCpus > MAX_CPUS) 

BODY (preview):
// 		if (numCpus == 0 || numCpus > MAX_CPUS) {
// 			qFatal("GlobalIRQController::initialize: invalid numCpus=%u",
// 				static_cast<unsigned>(numCpus));
// 		}

================================================================================
FILE: z:\EmulatRApp\coreLib\Global_PALVectorTable.h
LINE: 181
SIGNATURE:
 switch(exClass) 

BODY (preview):
		switch (exClass) {
		case ExceptionClass::MEMORY_FAULT:               return PalVectorId::DFAULT;
		case ExceptionClass::ACCESS_VIOLATION:      return PalVectorId::IACV;
		case ExceptionClass::SystemService:        return PalVectorId::CALL_CENTRY_BEG;
		case ExceptionClass::General:              return PalVectorId::GENTRAP;
		case ExceptionClass::ARITHMETIC:           return PalVectorId::ARITH;
		case ExceptionClass::UN_ALIGNED:            return PalVectorId::UN_ALIGNED;
		case ExceptionClass::IllegalInstruction:   return PalVectorId::OPCDEC;
		case ExceptionClass::InvalidAddress:       return PalVectorId::IFAULT;
		case ExceptionClass::SoftwareTrap:         return PalVectorId::FEN;
		case ExceptionClass::Breakpoint:           return PalVectorId::BREAKPOINT;
		case ExceptionClass::MACHINE_CHECK:         return PalVectorId::MCHK;
		case ExceptionClass::Panic:                return PalVectorId::BUGCHECK;
		default:                                   return PalVectorId::BUGCHECK;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\Global_PALVectorTable.h
LINE: 202
SIGNATURE:
	inline QVector<PalVectorEntry>& rawEntries() noexcept

BODY (preview):
	inline QVector<PalVectorEntry>& rawEntries() noexcept { return entries_; }


================================================================================
FILE: z:\EmulatRApp\coreLib\Global_SafeMemory.h
LINE: 8
SIGNATURE:
inline SafeMemory& Global_SafeMemory() 

BODY (preview):
inline SafeMemory& Global_SafeMemory() {
	return *g_safeMemory();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 92
SIGNATURE:
 for(int i = 0; i < 6; ++i) 

BODY (preview):
		for (int i = 0; i < 6; ++i) {
			PALScratch[i] = 0;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 106
SIGNATURE:
	inline void setKSP(quint64 value) noexcept

BODY (preview):
	inline void setKSP(quint64 value) noexcept { ksp = value; }


================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 110
SIGNATURE:
	inline void setESP(quint64 value) noexcept

BODY (preview):
	inline void setESP(quint64 value) noexcept { esp = value; }


================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 114
SIGNATURE:
	inline void setSSP(quint64 value) noexcept

BODY (preview):
	inline void setSSP(quint64 value) noexcept { ssp = value; }


================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 118
SIGNATURE:
	inline void setUSP(quint64 value) noexcept

BODY (preview):
	inline void setUSP(quint64 value) noexcept { usp = value; }


================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 122
SIGNATURE:
	inline void setPTBR(quint64 value) noexcept

BODY (preview):
	inline void setPTBR(quint64 value) noexcept { ptbr = value; }


================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 126
SIGNATURE:
	inline void setASN(ASNType value) noexcept

BODY (preview):
	inline void setASN(ASNType value) noexcept { asn = value; }


================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 130
SIGNATURE:
	inline void setPC(quint64 value) noexcept

BODY (preview):
	inline void setPC(quint64 value) noexcept { pc = value; }


================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 135
SIGNATURE:
	inline void setPS(quint64 value) noexcept

BODY (preview):
	inline void setPS(quint64 value) noexcept { ps = value; }


================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 141
SIGNATURE:
	inline void setASTER(quint64 value) 

BODY (preview):
	inline void setASTER( quint64 value) { aster = value; }
	// PCTX

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 144
SIGNATURE:
	inline void setPCTX(const quint64 pctx_) 

BODY (preview):
	inline void setPCTX(const quint64 pctx_) { pctx = pctx_; }
	inline quint64 getPPCE() const noexcept { return ppce; }

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 146
SIGNATURE:
	inline void setPPCE(quint64 ppce_) 

BODY (preview):
	inline void setPPCE(quint64 ppce_) { ppce = ppce_; }
	// UNQ

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 149
SIGNATURE:
	inline void setUNQ(quint64 value) noexcept

BODY (preview):
	inline void setUNQ(quint64 value) noexcept { unq = value; }


================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 153
SIGNATURE:
	inline void setFEN(quint64 value) noexcept

BODY (preview):
	inline void setFEN(quint64 value) noexcept { fen = value; }


================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 157
SIGNATURE:
	inline void setFPE(quint64 value) noexcept

BODY (preview):
	inline void setFPE(quint64 value) noexcept { fpe = value; }


================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 161
SIGNATURE:
	inline void setCM(const quint64 cm_) 

BODY (preview):
	inline void setCM(const quint64 cm_) { cm = cm_; }
	

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 170
SIGNATURE:
 	inline void setUSP(quint64 value) noexcept

BODY (preview):
// 	inline void setUSP(quint64 value) noexcept {
// 		usp = value;
// 	}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 173
SIGNATURE:
 	inline void setSSP(quint64 value) noexcept

BODY (preview):
// 	inline void setSSP(quint64 value) noexcept {
// 		ssp = value;
// 	}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 176
SIGNATURE:
 	inline void setESP(quint64 value) noexcept

BODY (preview):
// 	inline void setESP(quint64 value) noexcept {
// 		esp = value;
// 	}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 179
SIGNATURE:
 	inline void setKSP(quint64 value) noexcept

BODY (preview):
// 	inline void setKSP(quint64 value) noexcept {
// 		ksp = value;
// 	}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 187
SIGNATURE:
 	inline void setUNQ(quint64 value) noexcept

BODY (preview):
// 	inline void setUNQ(quint64 value) noexcept {
// 		unq = value;
// 	}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 197
SIGNATURE:
	inline void setVA_Fault(VAType va) noexcept

BODY (preview):
	inline void setVA_Fault(VAType va)  noexcept {
		va_fault = va;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 212
SIGNATURE:
 if(index >= 0 && index < 6) 

BODY (preview):
		if (index >= 0 && index < 6) {
			PALScratch[index] = value;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 219
SIGNATURE:
	inline void setSavedPC(quint64 value) noexcept

BODY (preview):
	inline void setSavedPC(quint64 value) noexcept { pc = value; }


================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 223
SIGNATURE:
	inline void setSavedPS(quint64 value) noexcept

BODY (preview):
	inline void setSavedPS(quint64 value) noexcept { ps = value; }


================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 227
SIGNATURE:
	inline void setHWPCBExc_Addr(quint64 value) noexcept

BODY (preview):
	inline void setHWPCBExc_Addr(quint64 value) noexcept {
		exc_addr = value;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 230
SIGNATURE:
	inline quint64 getHWPCBExc_Addr() noexcept

BODY (preview):
	inline quint64 getHWPCBExc_Addr() noexcept {
		return exc_addr;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 237
SIGNATURE:
	inline void setDTB0ASID(quint8 v) noexcept

BODY (preview):
	inline void setDTB0ASID(quint8 v) noexcept {
		// preserve other PCTX bits
		pctx = (pctx & ~(0xFFULL << 32)) | (static_cast<quint64>(v) << 32);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 245
SIGNATURE:
	inline void setDTB1ASID(quint8 v) noexcept

BODY (preview):
	inline void setDTB1ASID(quint8 v) noexcept {
		pctx = (pctx & ~(0xFFULL << 40)) | (static_cast<quint64>(v) << 40);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 274
SIGNATURE:
	AXP_FLATTEN void setActive_PalShadowBank0(quint8 idx, quint8 value) noexcept

BODY (preview):
	AXP_FLATTEN void setActive_PalShadowBank0(quint8 idx, quint8 value) noexcept {
		m_palShadowBank0[idx] = value;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_core.h
LINE: 280
SIGNATURE:
	AXP_FLATTEN void setActive_PalShadowBank1(quint8 idx, quint8 value) noexcept

BODY (preview):
	AXP_FLATTEN void setActive_PalShadowBank1(quint8 idx, quint8 value) noexcept {
		m_palShadowBank1[idx] = value;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 18
SIGNATURE:
inline HWPCB& getHWPCB_Active(CPUIdType cpuId) noexcept

BODY (preview):
inline HWPCB& getHWPCB_Active(CPUIdType cpuId) noexcept {
	return globalHWPCBController()(cpuId);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 23
SIGNATURE:
inline const HWPCB& getHWPCB_Active_Const(CPUIdType cpuId) noexcept

BODY (preview):
inline const HWPCB& getHWPCB_Active_Const(CPUIdType cpuId) noexcept {
	return globalHWPCBController()(cpuId);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 28
SIGNATURE:
inline HWPCB& getHWPCB_Context(CPUIdType cpuId, quint32 contextIndex) noexcept

BODY (preview):
inline HWPCB& getHWPCB_Context(CPUIdType cpuId, quint32 contextIndex) noexcept {
	return globalHWPCBController().getHWPCB(cpuId, contextIndex);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 33
SIGNATURE:
inline HWPCB& getHWPCB_Snapshot(CPUIdType cpuId) noexcept

BODY (preview):
inline HWPCB& getHWPCB_Snapshot(CPUIdType cpuId) noexcept {
	return globalHWPCBController().getHWPCB(cpuId, cpuId + HWPCB_CONTEXT_SAVE_OFFSET);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 45
SIGNATURE:
inline quint64 getKSP_Active(CPUIdType cpuId) noexcept

BODY (preview):
inline quint64 getKSP_Active(CPUIdType cpuId) noexcept {
	return globalHWPCBController()(cpuId).getKSP();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 48
SIGNATURE:
inline void setKSP_Active(CPUIdType cpuId, quint64 value) noexcept

BODY (preview):
inline void setKSP_Active(CPUIdType cpuId, quint64 value) noexcept {
	globalHWPCBController()(cpuId).setKSP(value);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 53
SIGNATURE:
inline quint64 getESP_Active(CPUIdType cpuId) noexcept

BODY (preview):
inline quint64 getESP_Active(CPUIdType cpuId) noexcept {
	return globalHWPCBController()(cpuId).getESP();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 56
SIGNATURE:
inline void setESP_Active(CPUIdType cpuId, quint64 value) noexcept

BODY (preview):
inline void setESP_Active(CPUIdType cpuId, quint64 value) noexcept {
	globalHWPCBController()(cpuId).setESP(value);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 61
SIGNATURE:
inline quint64 getSSP_Active(CPUIdType cpuId) noexcept

BODY (preview):
inline quint64 getSSP_Active(CPUIdType cpuId) noexcept {
	return globalHWPCBController()(cpuId).getSSP();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 64
SIGNATURE:
inline void setSSP_Active(CPUIdType cpuId, quint64 value) noexcept

BODY (preview):
inline void setSSP_Active(CPUIdType cpuId, quint64 value) noexcept {
	globalHWPCBController()(cpuId).setSSP(value);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 69
SIGNATURE:
inline quint64 getUSP_Active(CPUIdType cpuId) noexcept

BODY (preview):
inline quint64 getUSP_Active(CPUIdType cpuId) noexcept {
	return globalHWPCBController()(cpuId).getUSP();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 72
SIGNATURE:
inline void setUSP_Active(CPUIdType cpuId, quint64 value) noexcept

BODY (preview):
inline void setUSP_Active(CPUIdType cpuId, quint64 value) noexcept {
	globalHWPCBController()(cpuId).setUSP(value);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 91
SIGNATURE:
inline quint64 getPTBR_Active(CPUIdType cpuId) noexcept

BODY (preview):
inline quint64 getPTBR_Active(CPUIdType cpuId) noexcept {
	return globalHWPCBController()(cpuId).getPTBR();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 94
SIGNATURE:
inline void setPTBR_Active(CPUIdType cpuId, quint64 value) noexcept

BODY (preview):
inline void setPTBR_Active(CPUIdType cpuId, quint64 value) noexcept {
	globalHWPCBController()(cpuId).setPTBR(value);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 98
SIGNATURE:
inline quint64 getPCTX_Active(CPUIdType cpuId) noexcept

BODY (preview):
inline quint64 getPCTX_Active(CPUIdType cpuId) noexcept {
	return globalHWPCBController()(cpuId).getPCTX();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 101
SIGNATURE:
inline void setPCTX_Active(CPUIdType cpuId, quint64 value) noexcept

BODY (preview):
inline void setPCTX_Active(CPUIdType cpuId, quint64 value) noexcept {
	globalHWPCBController()(cpuId).setPCTX(value);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 105
SIGNATURE:
inline quint64 getPC_Active(CPUIdType cpuId) noexcept

BODY (preview):
inline quint64 getPC_Active(CPUIdType cpuId)  noexcept {
	return globalHWPCBController()(cpuId).getPC();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 108
SIGNATURE:
inline void setPC_Active(CPUIdType cpuId, quint64 value) noexcept

BODY (preview):
inline void setPC_Active(CPUIdType cpuId, quint64 value) noexcept {
	return globalHWPCBController()(cpuId).setPC(value);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 112
SIGNATURE:
inline quint64 getPS_Active(CPUIdType cpuId) noexcept

BODY (preview):
inline quint64 getPS_Active(CPUIdType cpuId)  noexcept {
	return globalHWPCBController()(cpuId).getPS();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 115
SIGNATURE:
inline void setPS_Active(CPUIdType cpuId, quint64 value) noexcept

BODY (preview):
inline void setPS_Active(CPUIdType cpuId, quint64 value) noexcept {
	return globalHWPCBController()(cpuId).setPS(value);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 120
SIGNATURE:
inline ASNType getASN_Active(CPUIdType cpuId) noexcept

BODY (preview):
inline ASNType getASN_Active(CPUIdType cpuId) noexcept {
	return static_cast<ASNType>(globalHWPCBController()(cpuId).getASN());
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 123
SIGNATURE:
inline void setASN_Active(CPUIdType cpuId, ASNType asn) noexcept

BODY (preview):
inline void setASN_Active(CPUIdType cpuId, ASNType asn) noexcept {
	globalHWPCBController()(cpuId).setASN(asn);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 127
SIGNATURE:
inline quint8 getCM_Active(CPUIdType cpuId) noexcept

BODY (preview):
inline quint8 getCM_Active(CPUIdType cpuId) noexcept {
	return static_cast<quint8>(globalHWPCBController()(cpuId).getCM());
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 130
SIGNATURE:
inline void setCM_Active(CPUIdType cpuId, quint8 cm) noexcept

BODY (preview):
inline void setCM_Active(CPUIdType cpuId, quint8 cm) noexcept {
	globalHWPCBController()(cpuId).setCM(cm);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 134
SIGNATURE:
inline quint64 getASTSR_Active(CPUIdType cpuId) noexcept

BODY (preview):
inline quint64 getASTSR_Active(CPUIdType cpuId) noexcept {
	return  globalIPRHot(cpuId).astsr;
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 137
SIGNATURE:
inline void setASTSR_Active(CPUIdType cpuId, quint64 value) noexcept

BODY (preview):
inline void setASTSR_Active(CPUIdType cpuId, quint64 value) noexcept {
	globalIPRHot(cpuId).astsr = value;
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 141
SIGNATURE:
inline quint64 getASTRR_Active(CPUIdType cpuId) noexcept

BODY (preview):
inline quint64 getASTRR_Active(CPUIdType cpuId) noexcept {
	return globalIPRHot(cpuId).astrr;
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 144
SIGNATURE:
inline void setASTRR_Active(CPUIdType cpuId, quint64 value) noexcept

BODY (preview):
inline void setASTRR_Active(CPUIdType cpuId, quint64 value) noexcept {
	globalIPRHot(cpuId).astrr = value;
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 147
SIGNATURE:
inline quint64 getASTER_Active(CPUIdType cpuId) noexcept

BODY (preview):
inline quint64 getASTER_Active(CPUIdType cpuId) noexcept {
	return globalHWPCBController()(cpuId).getASTER();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 150
SIGNATURE:
inline void setASTER_Active(CPUIdType cpuId, quint64 value) noexcept

BODY (preview):
inline void setASTER_Active(CPUIdType cpuId, quint64 value) noexcept {
	globalHWPCBController()(cpuId).setASTER(value);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 154
SIGNATURE:
inline quint8 getDTB0ASID_Active(CPUIdType cpuId) noexcept

BODY (preview):
inline quint8 getDTB0ASID_Active(CPUIdType cpuId) noexcept {
	return globalHWPCBController()(cpuId).getDTB0ASID();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 157
SIGNATURE:
inline void setDTB0ASID_Active(CPUIdType cpuId, quint8 v) noexcept

BODY (preview):
inline void setDTB0ASID_Active(CPUIdType cpuId, quint8 v) noexcept {
	globalHWPCBController()(cpuId).setDTB0ASID(v);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 161
SIGNATURE:
inline quint8 getDTB1ASID_Active(CPUIdType cpuId) noexcept

BODY (preview):
inline quint8 getDTB1ASID_Active(CPUIdType cpuId) noexcept {
	return globalHWPCBController()(cpuId).getDTB1ASID();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 164
SIGNATURE:
inline void setDTB1ASID_Active(CPUIdType cpuId, quint8 v) noexcept

BODY (preview):
inline void setDTB1ASID_Active(CPUIdType cpuId, quint8 v) noexcept {
	globalHWPCBController()(cpuId).setDTB1ASID(v);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 168
SIGNATURE:
AXP_FLATTEN bool getActivePalModeStatus(CPUIdType cpuId) noexcept

BODY (preview):
AXP_FLATTEN bool getActivePalModeStatus(CPUIdType cpuId) noexcept {
	return globalIPRHot(cpuId).isInPalMode();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 172
SIGNATURE:
AXP_FLATTEN void setActivePalModeStatus(CPUIdType cpuId, bool bStatus) noexcept

BODY (preview):
AXP_FLATTEN void setActivePalModeStatus(CPUIdType cpuId, bool bStatus) noexcept {
	return globalIPRHot(cpuId).setInPalMode(bStatus);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 177
SIGNATURE:
 inline quint64 getUSP_Active(int cpuId) noexcept

BODY (preview):
// inline quint64 getUSP_Active(int cpuId)  noexcept {
// 	return globalHWPCBController()(cpuId).getUSP();
// }

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 180
SIGNATURE:
 inline quint64 getKSP_Active(int cpuId) noexcept

BODY (preview):
// inline quint64  getKSP_Active(int cpuId) noexcept {
// 	return globalHWPCBController()(cpuId).getKSP();
// }

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 183
SIGNATURE:
 quint64 getESP_Active(int cpuId) noexcept

BODY (preview):
// quint64 getESP_Active(int cpuId)  noexcept {
// 	return globalHWPCBController()(cpuId).getESP();
// }

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 186
SIGNATURE:
 quint64 getSSP_Active(int cpuId) noexcept

BODY (preview):
// quint64 getSSP_Active(int cpuId) noexcept {
// 	return globalHWPCBController()(cpuId).getSSP();
// }

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 190
SIGNATURE:
 inline void setUSP_Active(int cpuId, quint64 usp) noexcept

BODY (preview):
// inline void setUSP_Active(int cpuId, quint64 usp) noexcept {
// 	globalHWPCBController()(cpuId).setUSP(usp);
// }

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 194
SIGNATURE:
 inline void setSSP_Active(int cpuId, quint64 ssp) noexcept

BODY (preview):
// inline void setSSP_Active(int cpuId, quint64 ssp) noexcept {
// 	globalHWPCBController()(cpuId).setSSP(ssp);
// }

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 197
SIGNATURE:
 inline void setESP_Active(int cpuId, quint64 esp) noexcept

BODY (preview):
// inline void setESP_Active(int cpuId, quint64 esp) noexcept {
// 	 globalHWPCBController()(cpuId).setESP(esp);
// }

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 200
SIGNATURE:
 inline void setKSP_Active(int cpuId, quint64 ksp) noexcept

BODY (preview):
// inline void setKSP_Active(int cpuId, quint64 ksp) noexcept {
// 	 globalHWPCBController()(cpuId).setKSP(ksp);
// }

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 206
SIGNATURE:
inline void setActiveExc_Addr(int cpuId, quint64 value) noexcept

BODY (preview):
inline void setActiveExc_Addr(int cpuId, quint64 value) noexcept {
	globalHWPCBController()(cpuId).setHWPCBExc_Addr(value);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 209
SIGNATURE:
inline quint64 getActiveExc_Addr(int cpuId) noexcept

BODY (preview):
inline quint64 getActiveExc_Addr(int cpuId) noexcept {
	return  globalHWPCBController()(cpuId).getHWPCBExc_Addr();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 215
SIGNATURE:
inline void setVA_FAULT(int cpuId, quint64 va) 

BODY (preview):
inline void setVA_FAULT(int cpuId, quint64 va) {
	globalHWPCBController()(cpuId).setVA_Fault(va);
  }

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 218
SIGNATURE:
inline quint64 getVA_Fault(int cpuId) noexcept

BODY (preview):
inline quint64 getVA_Fault(int cpuId)noexcept {
	return globalHWPCBController()(cpuId).getVA_Fault();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 223
SIGNATURE:
inline quint64 getUNQ_Active(int cpuId) noexcept

BODY (preview):
inline quint64 getUNQ_Active(int cpuId) noexcept {
	return globalHWPCBController()(cpuId).getUNQ();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 226
SIGNATURE:
inline void setUNQ_Active(int cpuId, quint64 value) noexcept

BODY (preview):
inline void setUNQ_Active(int cpuId, quint64 value) noexcept {
	globalHWPCBController()(cpuId).setUNQ(value);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 231
SIGNATURE:
inline quint64 getFEN_Active(int cpuId) noexcept

BODY (preview):
inline quint64 getFEN_Active(int cpuId) noexcept {
	return globalHWPCBController()(cpuId).getFEN();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 234
SIGNATURE:
inline void setFEN_Active(int cpuId, quint64 value) noexcept

BODY (preview):
inline void setFEN_Active(int cpuId, quint64 value) noexcept {
	globalHWPCBController()(cpuId).setFEN(value);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 239
SIGNATURE:
inline quint64 getFPE_Active(int cpuId) noexcept

BODY (preview):
inline quint64 getFPE_Active(int cpuId) noexcept {
	return globalHWPCBController()(cpuId).getFPE();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 242
SIGNATURE:
inline void setFPE_Active(int cpuId, quint64 value) noexcept

BODY (preview):
inline void setFPE_Active(int cpuId, quint64 value) noexcept {
	globalHWPCBController()(cpuId).setFPE(value);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 246
SIGNATURE:
inline quint64 getPPCE_Active(int cpuId) noexcept

BODY (preview):
inline quint64 getPPCE_Active(int cpuId) noexcept {
	return globalHWPCBController()(cpuId).getPPCE();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 249
SIGNATURE:
inline void setPPCE_Active(int cpuId, quint64 value) noexcept

BODY (preview):
inline void setPPCE_Active(int cpuId, quint64 value) noexcept {
	globalHWPCBController()(cpuId).setPPCE(value);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 253
SIGNATURE:
 inline quint64 getSavedPC_Active(int cpuId) noexcept

BODY (preview):
// inline quint64 getSavedPC_Active(int cpuId) noexcept {
// 	return globalHWPCBController()(cpuId).getSavedPC();
// }

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 256
SIGNATURE:
inline void setSavedPC_Active(int cpuId, quint64 value) noexcept

BODY (preview):
inline void setSavedPC_Active(int cpuId, quint64 value) noexcept {
	globalHWPCBController()(cpuId).setSavedPC(value);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 261
SIGNATURE:
inline quint64 getSavedPS_Active(int cpuId) noexcept

BODY (preview):
inline quint64 getSavedPS_Active(int cpuId) noexcept {
	return globalHWPCBController()(cpuId).getSavedPS();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 264
SIGNATURE:
inline void setSavedPS_Active(int cpuId, quint64 value) noexcept

BODY (preview):
inline void setSavedPS_Active(int cpuId, quint64 value) noexcept {
	globalHWPCBController()(cpuId).setSavedPS(value);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 269
SIGNATURE:
inline quint64 getPALScratch_Active(int cpuId, int index) noexcept

BODY (preview):
inline quint64 getPALScratch_Active(int cpuId, int index) noexcept {
	return globalHWPCBController()(cpuId).getPALScratch(index);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 272
SIGNATURE:
inline void setPALScratch_Active(int cpuId, int index, quint64 value) noexcept

BODY (preview):
inline void setPALScratch_Active(int cpuId, int index, quint64 value) noexcept {
	globalHWPCBController()(cpuId).setPALScratch(index, value);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 276
SIGNATURE:
inline  void setContextSnapshot(CPUIdType cpuId) noexcept

BODY (preview):
inline  void setContextSnapshot(CPUIdType cpuId) noexcept {
	globalHWPCBController().context_snapshot(cpuId);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 279
SIGNATURE:
inline void restoreContextFromSnapshot(CPUIdType cpuId) noexcept

BODY (preview):
inline void restoreContextFromSnapshot(CPUIdType cpuId) noexcept {
	globalHWPCBController().context_revertSnapshot(cpuId);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 292
SIGNATURE:
constexpr bool isPalShadowGroup1Reg(quint8 regNum) noexcept

BODY (preview):
constexpr bool isPalShadowGroup1Reg(quint8 regNum) noexcept {
	return (regNum >= 4 && regNum <= 7) || (regNum >= 20 && regNum <= 23);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 299
SIGNATURE:
constexpr quint8 palShadowGroup1Index(quint8 regNum) noexcept

BODY (preview):
constexpr quint8 palShadowGroup1Index(quint8 regNum) noexcept {
	if (regNum >= 4 && regNum <= 7) {
		return regNum - 4;      // R4->0, R5->1, R6->2, R7->3
	}
	// regNum >= 20 && regNum <= 23
	return regNum - 20 + 4;     // R20->4, R21->5, R22->6, R23->7
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 309
SIGNATURE:
constexpr bool isPalShadowGroup0Reg(quint8 regNum) noexcept

BODY (preview):
constexpr bool isPalShadowGroup0Reg(quint8 regNum) noexcept {
	return (regNum >= 8 && regNum <= 11) || (regNum >= 24 && regNum <= 27);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 316
SIGNATURE:
constexpr quint8 palShadowGroup0Index(quint8 regNum) noexcept

BODY (preview):
constexpr quint8 palShadowGroup0Index(quint8 regNum) noexcept {
	if (regNum >= 8 && regNum <= 11) {
		return regNum - 8;      // R8->0, R9->1, R10->2, R11->3
	}
	// regNum >= 24 && regNum <= 27
	return regNum - 24 + 4;     // R24->4, R25->5, R26->6, R27->7
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 325
SIGNATURE:
inline bool getICtlSDE1(CPUIdType cpuId) noexcept

BODY (preview):
inline bool getICtlSDE1(CPUIdType cpuId) noexcept {
	return (globalIPRHot(cpuId).i_ctl & 0x2ULL) != 0; // bit 1
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 329
SIGNATURE:
inline bool getICtlSDE0(CPUIdType cpuId) noexcept

BODY (preview):
inline bool getICtlSDE0(CPUIdType cpuId) noexcept {
	return (globalIPRHot(cpuId).i_ctl & 0x1ULL) != 0; // bit 0
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 333
SIGNATURE:
inline void setICtlSDE1(CPUIdType cpuId, bool enable) noexcept

BODY (preview):
inline void setICtlSDE1(CPUIdType cpuId, bool enable) noexcept {
	if (enable) {
		globalIPRHot(cpuId).i_ctl |= 0x2ULL;
	}
	else {
		globalIPRHot(cpuId).i_ctl &= ~0x2ULL;
	}
}

================================================================================
FILE: z:\EmulatRApp\coreLib\HWPCB_helpers_inline.h
LINE: 342
SIGNATURE:
inline void setICtlSDE0(CPUIdType cpuId, bool enable) noexcept

BODY (preview):
inline void setICtlSDE0(CPUIdType cpuId, bool enable) noexcept {
	if (enable) {
		globalIPRHot(cpuId).i_ctl |= 0x1ULL;
	}
	else {
		globalIPRHot(cpuId).i_ctl &= ~0x1ULL;
	}
}

================================================================================
FILE: z:\EmulatRApp\coreLib\ICCSR_Bits_inl.h
LINE: 119
SIGNATURE:
	inline bool getFPE(quint64 iccsr) noexcept

BODY (preview):
	inline bool getFPE(quint64 iccsr) noexcept {
		return (iccsr & FPE_MASK) != 0;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\ICCSR_Bits_inl.h
LINE: 124
SIGNATURE:
	inline quint64 setFPE(quint64 iccsr, bool enable) noexcept

BODY (preview):
	inline quint64 setFPE(quint64 iccsr, bool enable) noexcept {
		if (enable)
			return iccsr | FPE_MASK;
		else
			return iccsr & ~FPE_MASK;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\ICCSR_Bits_inl.h
LINE: 132
SIGNATURE:
	inline bool getHWE(quint64 iccsr) noexcept

BODY (preview):
	inline bool getHWE(quint64 iccsr) noexcept {
		return (iccsr & HWE_MASK) != 0;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\ICCSR_Bits_inl.h
LINE: 137
SIGNATURE:
	inline quint64 setHWE(quint64 iccsr, bool enable) noexcept

BODY (preview):
	inline quint64 setHWE(quint64 iccsr, bool enable) noexcept {
		if (enable)
			return iccsr | HWE_MASK;
		else
			return iccsr & ~HWE_MASK;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\ICCSR_Bits_inl.h
LINE: 145
SIGNATURE:
	inline bool getBPE(quint64 iccsr) noexcept

BODY (preview):
	inline bool getBPE(quint64 iccsr) noexcept {
		return (iccsr & BPE_MASK) != 0;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\ICCSR_Bits_inl.h
LINE: 150
SIGNATURE:
	inline quint64 setBPE(quint64 iccsr, bool enable) noexcept

BODY (preview):
	inline quint64 setBPE(quint64 iccsr, bool enable) noexcept {
		if (enable)
			return iccsr | BPE_MASK;
		else
			return iccsr & ~BPE_MASK;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\ICCSR_Bits_inl.h
LINE: 158
SIGNATURE:
	inline bool getBHE(quint64 iccsr) noexcept

BODY (preview):
	inline bool getBHE(quint64 iccsr) noexcept {
		return (iccsr & BHE_MASK) != 0;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\ICCSR_Bits_inl.h
LINE: 163
SIGNATURE:
	inline quint64 setBHE(quint64 iccsr, bool enable) noexcept

BODY (preview):
	inline quint64 setBHE(quint64 iccsr, bool enable) noexcept {
		if (enable)
			return iccsr | BHE_MASK;
		else
			return iccsr & ~BHE_MASK;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\ICCSR_Bits_inl.h
LINE: 171
SIGNATURE:
	inline quint8 getPC0(quint64 iccsr) noexcept

BODY (preview):
	inline quint8 getPC0(quint64 iccsr) noexcept {
		return static_cast<quint8>((iccsr >> PC0_SHIFT) & 0x3);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\ICCSR_Bits_inl.h
LINE: 176
SIGNATURE:
	inline quint64 setPC0(quint64 iccsr, quint8 value) noexcept

BODY (preview):
	inline quint64 setPC0(quint64 iccsr, quint8 value) noexcept {
		return (iccsr & ~PC0_MASK) | ((quint64(value) & 0x3) << PC0_SHIFT);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\ICCSR_Bits_inl.h
LINE: 181
SIGNATURE:
	inline quint8 getPC1(quint64 iccsr) noexcept

BODY (preview):
	inline quint8 getPC1(quint64 iccsr) noexcept {
		return static_cast<quint8>((iccsr >> PC1_SHIFT) & 0x3);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\ICCSR_Bits_inl.h
LINE: 186
SIGNATURE:
	inline quint64 setPC1(quint64 iccsr, quint8 value) noexcept

BODY (preview):
	inline quint64 setPC1(quint64 iccsr, quint8 value) noexcept {
		return (iccsr & ~PC1_MASK) | ((quint64(value) & 0x3) << PC1_SHIFT);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\ICCSR_Bits_inl.h
LINE: 191
SIGNATURE:
	inline bool getICPERR(quint64 iccsr) noexcept

BODY (preview):
	inline bool getICPERR(quint64 iccsr) noexcept {
		return (iccsr & ICPERR_MASK) != 0;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\ICCSR_Bits_inl.h
LINE: 208
SIGNATURE:
	inline const char* getBitName(unsigned bitIndex) 

BODY (preview):
	inline const char* getBitName(unsigned bitIndex) {
		switch (bitIndex) {
		case FPE_BIT:    return "FPE (Floating-Point Enable)";
		case HWE_BIT:    return "HWE (Hardware Enable)";
		case BPE_BIT:    return "BPE (Branch Prediction Enable)";
		case BHE_BIT:    return "BHE (Branch History Enable)";
		case JSE_BIT:    return "JSE (Jump Stack Enable)";
		case SDE_BIT:    return "SDE (Single-Issue Disable Enable)";
		case SLE_BIT:    return "SLE (Serial Line Enable)";
		case MAP_BIT:    return "MAP (Memory Address Prediction)";
		case ICPERR_BIT: return "ICPERR (Icache Parity Error)";
		default:         return "Reserved";
		}
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\ICCSR_Bits_inl.h
LINE: 209
SIGNATURE:
 switch(bitIndex) 

BODY (preview):
		switch (bitIndex) {
		case FPE_BIT:    return "FPE (Floating-Point Enable)";
		case HWE_BIT:    return "HWE (Hardware Enable)";
		case BPE_BIT:    return "BPE (Branch Prediction Enable)";
		case BHE_BIT:    return "BHE (Branch History Enable)";
		case JSE_BIT:    return "JSE (Jump Stack Enable)";
		case SDE_BIT:    return "SDE (Single-Issue Disable Enable)";
		case SLE_BIT:    return "SLE (Serial Line Enable)";
		case MAP_BIT:    return "MAP (Memory Address Prediction)";
		case ICPERR_BIT: return "ICPERR (Icache Parity Error)";
		default:         return "Reserved";
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\info_inl_helpers.h
LINE: 117
SIGNATURE:
 : rawCode(0) 

BODY (preview):
	ExceptionDetail() : rawCode(0) {}
};



// /**
//  * @brief Master exception information structure.
//  *
//  * Complete exception context passed to exception handlers.
//  *
//  * Example usage:
//  *     ExceptionInfo ex;
//  *     ex.type = ExceptionType::FAULT;
//  *     ex.category = ExceptionCategory::FLOATING_POINT;
//  *     ex.detail.fpReason = FloatingPointReason::OVERFLOW;

================================================================================
FILE: z:\EmulatRApp\coreLib\info_inl_helpers.h
LINE: 156
SIGNATURE:
 	void setAlphaExceptionType(AlphaExceptionType exType) 

BODY (preview):
// 	void setAlphaExceptionType(AlphaExceptionType exType) { alphaExceptonType = exType; }
// 	AlphaExceptionType getAlphaExceptionType() const { return alphaExceptonType; }

================================================================================
FILE: z:\EmulatRApp\coreLib\info_inl_helpers.h
LINE: 158
SIGNATURE:
	void setMessage(const QString& msg) 

BODY (preview):
	void setMessage(const QString& msg) { m_msg = msg; }
	QString& getMessage() { return m_msg; }

================================================================================
FILE: z:\EmulatRApp\coreLib\info_inl_helpers.h
LINE: 159
SIGNATURE:
	QString& getMessage() 

BODY (preview):
	QString& getMessage() { return m_msg; }
	bool hasMessage() const { return !m_msg.isEmpty(); }

================================================================================
FILE: z:\EmulatRApp\coreLib\info_inl_helpers.h
LINE: 162
SIGNATURE:
	void setPcAtFault(quint64 faultingPC) 

BODY (preview):
	void setPcAtFault(quint64 faultingPC) { m_pcAtFault = faultingPC; }
	quint64 faultingPC() const { return m_pcAtFault; }

================================================================================
FILE: z:\EmulatRApp\coreLib\info_inl_helpers.h
LINE: 164
SIGNATURE:
     void setPrecise(bool bValue) 

BODY (preview):
	//     void setPrecise(bool bValue) { m_precise = bValue; }
	//     bool isPrecise() { return m_precise; }

================================================================================
FILE: z:\EmulatRApp\coreLib\info_inl_helpers.h
LINE: 165
SIGNATURE:
     bool isPrecise() 

BODY (preview):
	//     bool isPrecise() { return m_precise; }
	void setSourceRegisterBitmask(quint32 mask) { m_sourceRegisterBitmask = mask; }

================================================================================
FILE: z:\EmulatRApp\coreLib\info_inl_helpers.h
LINE: 166
SIGNATURE:
	void setSourceRegisterBitmask(quint32 mask) 

BODY (preview):
	void setSourceRegisterBitmask(quint32 mask) { m_sourceRegisterBitmask = mask; }
	quint32 sourceRegisterBitmask() const { return m_sourceRegisterBitmask; }

================================================================================
FILE: z:\EmulatRApp\coreLib\info_inl_helpers.h
LINE: 169
SIGNATURE:
	void setSoftwareIPLBitmask(quint32 mask) 

BODY (preview):
	void setSoftwareIPLBitmask(quint32 mask) { m_software_IPLBitMask = mask; }
	quint32 softwareIPLBitmask() const { return m_software_IPLBitMask; }

================================================================================
FILE: z:\EmulatRApp\coreLib\info_inl_helpers.h
LINE: 172
SIGNATURE:
	void setSoftwareRepairBitmask(quint32 mask) 

BODY (preview):
	void setSoftwareRepairBitmask(quint32 mask) { m_softwareRepairBitmask = mask; }
	quint32 softwareRepairBitmask() const { return m_softwareRepairBitmask; }

================================================================================
FILE: z:\EmulatRApp\coreLib\info_inl_helpers.h
LINE: 175
SIGNATURE:
	void setSoftwareCompletion(bool bCompletionNeeded) 

BODY (preview):
	void setSoftwareCompletion(bool bCompletionNeeded) { m_softwareCompletionNeeded = bCompletionNeeded; }
	bool getSoftwareCompletion() { return m_softwareCompletionNeeded; }

================================================================================
FILE: z:\EmulatRApp\coreLib\info_inl_helpers.h
LINE: 176
SIGNATURE:
	bool getSoftwareCompletion() 

BODY (preview):
	bool getSoftwareCompletion() { return m_softwareCompletionNeeded; }


================================================================================
FILE: z:\EmulatRApp\coreLib\info_inl_helpers.h
LINE: 178
SIGNATURE:
	void setIsWrite(quint8 writeVal) 

BODY (preview):
	void setIsWrite(quint8 writeVal) { m_isWrite = writeVal; }
	quint8 getIsWrite() { return m_isWrite; }

================================================================================
FILE: z:\EmulatRApp\coreLib\info_inl_helpers.h
LINE: 179
SIGNATURE:
	quint8 getIsWrite() 

BODY (preview):
	quint8 getIsWrite() { return m_isWrite; }
	/**

================================================================================
FILE: z:\EmulatRApp\coreLib\info_inl_helpers.h
LINE: 187
SIGNATURE:
 switch(category) 

BODY (preview):
		switch (category) {
		case ExceptionCategory::MEMORY_FAULT:
			return (detail.memoryFault == MemoryFaultReason::PAGE_FAULT_REASON ||
				detail.memoryFault == MemoryFaultReason::ACCESS_VIOLATION_REASON);
		case ExceptionCategory::MACHINE_CHECK:
			return (
				(detail.machineCheck == MachineCheckReason::DOUBLE_MACHINE_CHECK) ||
				(detail.machineCheck == MachineCheckReason::CORRECTABLE_ERROR)
				);
		case ExceptionCategory::SOFTWARE_TRAP:
			return true;
		case ExceptionCategory::DOUBLE_EXCEPTION_ERROR:
		case ExceptionCategory::KERNEL_STACK_NOT_VALID:
			return true;
		default:

================================================================================
FILE: z:\EmulatRApp\coreLib\info_inl_helpers.h
LINE: 210
SIGNATURE:
 switch(type) 

BODY (preview):
		switch (type) {
		case ExceptionType::FAULT: return "FAULT";
		case ExceptionType::TRAP: return "TRAP";
		case ExceptionType::ABORT: return "ABORT";
		case ExceptionType::INTERRUPT: return "INTERRUPT";
		default: return "UNKNOWN";
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IPRBank.h
LINE: 25
SIGNATURE:
 : m_cpuCount(0) 

BODY (preview):
    IPRBank() : m_cpuCount(0) {
        // Initialize all entries to default state
        for (auto& ipr : m_perCpu) {
            ipr.reset();
        }
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPRBank.h
LINE: 27
SIGNATURE:
       for(auto& ipr : m_perCpu) 

BODY (preview):
        for (auto& ipr : m_perCpu) {
            ipr.reset();
        }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPRBank.h
LINE: 88
SIGNATURE:
       for(int i = 0; i < m_cpuCount; ++i) 

BODY (preview):
        for (int i = 0; i < m_cpuCount; ++i) {
            m_perCpu[i].reset();
        }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_Cold.h
LINE: 119
SIGNATURE:
   IPRStorage_Cold() 

BODY (preview):
    IPRStorage_Cold() { reset(); }


================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_Cold.h
LINE: 121
SIGNATURE:
    inline void reset() noexcept

BODY (preview):
    inline void reset() noexcept {
        std::memset(this, 0, sizeof(IPRStorage_Cold));
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_Cold.h
LINE: 129
SIGNATURE:
    static constexpr qsizetype size() 

BODY (preview):
    static constexpr qsizetype size() {
        return static_cast<qsizetype>(sizeof(IPRStorage_Cold));
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 30
SIGNATURE:
   IPRStorage() 

BODY (preview):
    IPRStorage() {
        hot.reset();
        cold.reset();
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 35
SIGNATURE:
    inline void reset() noexcept

BODY (preview):
    inline void reset() noexcept {
        hot.reset();
        cold.reset();
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 45
SIGNATURE:
    inline quint64& fpcr() 

BODY (preview):
    inline quint64& fpcr() { return hot.fpcr; }
    inline quint64& va() { return hot.va; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 46
SIGNATURE:
    inline quint64& va() 

BODY (preview):
    inline quint64& va() { return hot.va; }
    inline quint64& exc_addr() { return hot.exc_addr; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 47
SIGNATURE:
    inline quint64& exc_addr() 

BODY (preview):
    inline quint64& exc_addr() { return hot.exc_addr; }
    inline quint64& ptbr() { return hot.ptbr; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 48
SIGNATURE:
    inline quint64& ptbr() 

BODY (preview):
    inline quint64& ptbr() { return hot.ptbr; }
    inline quint64& asn() { return hot.asn; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 49
SIGNATURE:
    inline quint64& asn() 

BODY (preview):
    inline quint64& asn() { return hot.asn; }
    inline quint64* pal_temp() { return hot.pal_temp; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 50
SIGNATURE:
    inline quint64* pal_temp() 

BODY (preview):
    inline quint64* pal_temp() { return hot.pal_temp; }
    inline quint64& iccsr() { return hot.iccsr; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 51
SIGNATURE:
    inline quint64& iccsr() 

BODY (preview):
    inline quint64& iccsr() { return hot.iccsr; }
    inline quint64& i_ctl() { return hot.i_ctl; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 52
SIGNATURE:
    inline quint64& i_ctl() 

BODY (preview):
    inline quint64& i_ctl() { return hot.i_ctl; }
    inline quint64& m_ctl() { return hot.m_ctl; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 53
SIGNATURE:
    inline quint64& m_ctl() 

BODY (preview):
    inline quint64& m_ctl() { return hot.m_ctl; }
    inline quint64& dc_ctl() { return hot.dc_ctl; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 54
SIGNATURE:
    inline quint64& dc_ctl() 

BODY (preview):
    inline quint64& dc_ctl() { return hot.dc_ctl; }
    inline quint64& cc() { return hot.cc; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 55
SIGNATURE:
    inline quint64& cc() 

BODY (preview):
    inline quint64& cc() { return hot.cc; }


================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 58
SIGNATURE:
    inline quint64& mces() 

BODY (preview):
    inline quint64& mces() { return cold.mces; }
    inline quint64& biu_addr() { return cold.biu_addr; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 59
SIGNATURE:
    inline quint64& biu_addr() 

BODY (preview):
    inline quint64& biu_addr() { return cold.biu_addr; }
    inline quint64& sl_rcv() { return cold.sl_rcv; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 60
SIGNATURE:
    inline quint64& sl_rcv() 

BODY (preview):
    inline quint64& sl_rcv() { return cold.sl_rcv; }
    inline quint64& c_data() { return cold.c_data; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 61
SIGNATURE:
    inline quint64& c_data() 

BODY (preview):
    inline quint64& c_data() { return cold.c_data; }


================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 70
SIGNATURE:
    inline void setFpcr(quint64 fpcr_) noexcept

BODY (preview):
    inline void setFpcr(quint64 fpcr_) noexcept { hot.fpcr = fpcr_; }


================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 76
SIGNATURE:
    inline void setFPCR_RoundingMode(quint8 rm) noexcept

BODY (preview):
    inline void setFPCR_RoundingMode(quint8 rm) noexcept {
        quint64 value = hot.fpcr;
        value &= ~(FPCR_RM_MASK << FPCR_RM_SHIFT);
        value |= (static_cast<quint64>(rm) & FPCR_RM_MASK) << FPCR_RM_SHIFT;
        hot.fpcr = value;
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 91
SIGNATURE:
    inline void iccsr_setFPE(bool enable) 

BODY (preview):
    inline void iccsr_setFPE(bool enable) {
        if (enable)
            hot.iccsr |= ICCSR_Bits::FPE_MASK;
        else
            hot.iccsr &= ~ICCSR_Bits::FPE_MASK;
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 102
SIGNATURE:
    inline void iccsr_setHWE(bool enable) 

BODY (preview):
    inline void iccsr_setHWE(bool enable) {
        if (enable)
            hot.iccsr |= ICCSR_Bits::HWE_MASK;
        else
            hot.iccsr &= ~ICCSR_Bits::HWE_MASK;
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 113
SIGNATURE:
    inline void iccsr_setBPE(bool enable) 

BODY (preview):
    inline void iccsr_setBPE(bool enable) {
        if (enable)
            hot.iccsr |= ICCSR_Bits::BPE_MASK;
        else
            hot.iccsr &= ~ICCSR_Bits::BPE_MASK;
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 120
SIGNATURE:
    inline void iccsr_setBHE(bool enable) 

BODY (preview):
    inline void iccsr_setBHE(bool enable) {
        if (enable)
            hot.iccsr |= ICCSR_Bits::BHE_MASK;
        else
            hot.iccsr &= ~ICCSR_Bits::BHE_MASK;
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 131
SIGNATURE:
    inline void iccsr_setPC0(quint8 value) 

BODY (preview):
    inline void iccsr_setPC0(quint8 value) {
        hot.iccsr = (hot.iccsr & ~ICCSR_Bits::PC0_MASK) |
                    ((quint64(value) & 0x3) << ICCSR_Bits::PC0_SHIFT);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 140
SIGNATURE:
    inline void setDtb_Tag_Raw(quint64 tag) noexcept

BODY (preview):
    inline void setDtb_Tag_Raw(quint64 tag) noexcept { hot.dtbTagScratch.raw = tag; }
    inline quint64 getDtb_Tag_Raw() const noexcept { return hot.dtbTagScratch.raw; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 143
SIGNATURE:
    inline void setDtb_Tag_Vpn(quint64 vpn) noexcept

BODY (preview):
    inline void setDtb_Tag_Vpn(quint64 vpn) noexcept { hot.dtbTagScratch.vpn = vpn; }
    inline quint64 getDtb_Tag_Vpn() const noexcept { return hot.dtbTagScratch.vpn; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 146
SIGNATURE:
    inline void setDtb_Tag_Asn(quint8 asn) noexcept

BODY (preview):
    inline void setDtb_Tag_Asn(quint8 asn) noexcept { hot.dtbTagScratch.asn = asn; }
    inline quint8 getDtb_Tag_Asn() const noexcept { return hot.dtbTagScratch.asn; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 149
SIGNATURE:
    inline void setDtb_Tag_Gh(quint8 gh) noexcept

BODY (preview):
    inline void setDtb_Tag_Gh(quint8 gh) noexcept { hot.dtbTagScratch.gh = gh; }
    inline quint8 getDtb_Tag_Gh() const noexcept { return hot.dtbTagScratch.gh; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 152
SIGNATURE:
    inline void setItb_Tag_Va(VAType tag) noexcept

BODY (preview):
    inline void setItb_Tag_Va(VAType tag) noexcept { hot.itbTagScratch.va = tag; }
    inline VAType getItb_Tag_Va() const noexcept { return hot.itbTagScratch.va; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 155
SIGNATURE:
    inline void setItb_Tag_Asn(ASNType tag) noexcept

BODY (preview):
    inline void setItb_Tag_Asn(ASNType tag) noexcept { hot.itbTagScratch.asn = tag; }
    inline ASNType getItb_Tag_Asn() const noexcept { return hot.itbTagScratch.asn; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 158
SIGNATURE:
    inline void setDtb_Tag_Bank(quint8 bank_) noexcept

BODY (preview):
    inline void setDtb_Tag_Bank(quint8 bank_) noexcept {
        hot.dtbTagScratch.bank1 = (bank_ != 0);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 167
SIGNATURE:
    inline void setMM_STAT(quint64 rawValue) noexcept

BODY (preview):
    inline void setMM_STAT(quint64 rawValue) noexcept {
        hot.mm_stat = rawValue;
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 175
SIGNATURE:
    static constexpr qsizetype getHotSize() 

BODY (preview):
    static constexpr qsizetype getHotSize() {
        return static_cast<qsizetype>(sizeof(IPRStorage_Hot));
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 179
SIGNATURE:
    static constexpr qsizetype getColdSize() 

BODY (preview):
    static constexpr qsizetype getColdSize() {
        return static_cast<qsizetype>(sizeof(IPRStorage_Cold));
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_core.h
LINE: 183
SIGNATURE:
    static constexpr qsizetype getTotalSize() 

BODY (preview):
    static constexpr qsizetype getTotalSize() {
        return static_cast<qsizetype>(sizeof(IPRStorage));
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_Hot.h
LINE: 172
SIGNATURE:
 if(bPalMode) 

BODY (preview):
		if (bPalMode) {
			pal_mode |= 0x1ULL;  // set bit 0
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_Hot.h
LINE: 185
SIGNATURE:
   IPRStorage_Hot() 

BODY (preview):
    IPRStorage_Hot() { reset(); }


================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_Hot.h
LINE: 187
SIGNATURE:
    AXP_FLATTEN void reset() noexcept

BODY (preview):
    AXP_FLATTEN void reset() noexcept {
        std::memset(this, 0, sizeof(IPRStorage_Hot));
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_Hot.h
LINE: 195
SIGNATURE:
    static constexpr qsizetype size() 

BODY (preview):
    static constexpr qsizetype size() {
        return static_cast<qsizetype>(sizeof(IPRStorage_Hot));
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_IBox.h
LINE: 55
SIGNATURE:
    void set_vptb_sext(quint16 val) noexcept

BODY (preview):
    void set_vptb_sext(quint16 val) noexcept {
        raw = (raw & ~(0xFFFFULL << 48)) | (quint64(val & 0xFFFF) << 48);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_IBox.h
LINE: 61
SIGNATURE:
    void set_vptb(quint32 val) noexcept

BODY (preview):
    void set_vptb(quint32 val) noexcept {
        raw = (raw & ~(0xFFFFULL << 30)) | (quint64(val & 0xFFFF) << 30);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_IBox.h
LINE: 73
SIGNATURE:
    void set_tb_mb_en(bool en) noexcept

BODY (preview):
    void set_tb_mb_en(bool en) noexcept {
        raw = (raw & ~(1ULL << 22)) | (quint64(en) << 22);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_IBox.h
LINE: 79
SIGNATURE:
    void set_mchk_en(bool en) noexcept

BODY (preview):
    void set_mchk_en(bool en) noexcept {
        raw = (raw & ~(1ULL << 21)) | (quint64(en) << 21);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_IBox.h
LINE: 85
SIGNATURE:
    void set_call_pal_r23(bool en) noexcept

BODY (preview):
    void set_call_pal_r23(bool en) noexcept {
        raw = (raw & ~(1ULL << 20)) | (quint64(en) << 20);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_IBox.h
LINE: 91
SIGNATURE:
    void set_pct1_en(bool en) noexcept

BODY (preview):
    void set_pct1_en(bool en) noexcept {
        raw = (raw & ~(1ULL << 19)) | (quint64(en) << 19);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_IBox.h
LINE: 97
SIGNATURE:
    void set_pct0_en(bool en) noexcept

BODY (preview):
    void set_pct0_en(bool en) noexcept {
        raw = (raw & ~(1ULL << 18)) | (quint64(en) << 18);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_IBox.h
LINE: 103
SIGNATURE:
    void set_single_issue(bool en) noexcept

BODY (preview):
    void set_single_issue(bool en) noexcept {
        raw = (raw & ~(1ULL << 17)) | (quint64(en) << 17);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_IBox.h
LINE: 109
SIGNATURE:
    void set_va_form_32(bool en) noexcept

BODY (preview):
    void set_va_form_32(bool en) noexcept {
        raw = (raw & ~(1ULL << 16)) | (quint64(en) << 16);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_IBox.h
LINE: 115
SIGNATURE:
    void set_va_48(bool en) noexcept

BODY (preview):
    void set_va_48(bool en) noexcept {
        raw = (raw & ~(1ULL << 15)) | (quint64(en) << 15);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_IBox.h
LINE: 123
SIGNATURE:
    void set_sl_xmit(bool en) noexcept

BODY (preview):
    void set_sl_xmit(bool en) noexcept {
        raw = (raw & ~(1ULL << 13)) | (quint64(en) << 13);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_IBox.h
LINE: 129
SIGNATURE:
    void set_hwe(bool en) noexcept

BODY (preview):
    void set_hwe(bool en) noexcept {
        raw = (raw & ~(1ULL << 12)) | (quint64(en) << 12);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_IBox.h
LINE: 135
SIGNATURE:
    void set_bp_mode(quint8 val) noexcept

BODY (preview):
    void set_bp_mode(quint8 val) noexcept {
        raw = (raw & ~(0x3ULL << 10)) | (quint64(val & 0x3) << 10);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_IBox.h
LINE: 141
SIGNATURE:
    void set_sbe(quint8 val) noexcept

BODY (preview):
    void set_sbe(quint8 val) noexcept {
        raw = (raw & ~(0x3ULL << 8)) | (quint64(val & 0x3) << 8);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_IBox.h
LINE: 147
SIGNATURE:
    void set_sde(quint8 val) noexcept

BODY (preview):
    void set_sde(quint8 val) noexcept {
        raw = (raw & ~(0x3ULL << 6)) | (quint64(val & 0x3) << 6);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_IBox.h
LINE: 153
SIGNATURE:
    void set_spe(quint8 val) noexcept

BODY (preview):
    void set_spe(quint8 val) noexcept {
        raw = (raw & ~(0x7ULL << 3)) | (quint64(val & 0x7) << 3);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_IBox.h
LINE: 159
SIGNATURE:
    void set_ic_en(quint8 val) noexcept

BODY (preview):
    void set_ic_en(quint8 val) noexcept {
        raw = (raw & ~(0x3ULL << 1)) | (quint64(val & 0x3) << 1);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_IBox.h
LINE: 165
SIGNATURE:
    void set_spce(bool en) noexcept

BODY (preview):
    void set_spce(bool en) noexcept {
        raw = (raw & ~1ULL) | quint64(en);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IprStorage_IBox.h
LINE: 186
SIGNATURE:
   void flushICache(AlphaProcessorContext& ctx) 

BODY (preview):
    //   void flushICache(AlphaProcessorContext& ctx) {
    //       ctx.invalidateAllLines_iCache();
    //       ctx.clearInstructionPrefetchState();
    //       ctx.resetBranchPredictorHistory();
    //   }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 319
SIGNATURE:
   IPRStorage_Hot() 

BODY (preview):
    IPRStorage_Hot() { reset(); }


================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 321
SIGNATURE:
    inline void reset() noexcept

BODY (preview):
    inline void reset() noexcept {
        std::memset(this, 0, sizeof(IPRStorage_Hot));
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 325
SIGNATURE:
   inline  quint64 getASTSR() noexcept

BODY (preview):
   inline  quint64 getASTSR() noexcept {
       return astsr;
   }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 328
SIGNATURE:
   inline void setASTSR(quint64 rawValue) 

BODY (preview):
   inline void setASTSR(quint64 rawValue) {
       astsr = rawValue;
   }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 331
SIGNATURE:
   inline  quint64 getASTRR() noexcept

BODY (preview):
   inline  quint64 getASTRR() noexcept {
	   return astsr;
   }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 334
SIGNATURE:
   inline void setASTRR(quint64 rawValue) 

BODY (preview):
   inline void setASTRR(quint64 rawValue) {
       astsr = rawValue;
   }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 341
SIGNATURE:
    inline void setCurrentASN(quint64 value) noexcept

BODY (preview):
    inline void setCurrentASN(quint64 value) noexcept { asn = value; }


================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 344
SIGNATURE:
    inline void setPTBR(quint64 value) noexcept

BODY (preview):
    inline void setPTBR(quint64 value) noexcept { ptbr = value; }


================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 348
SIGNATURE:
    inline void setEnteredPALContext(bool value) noexcept

BODY (preview):
    inline void setEnteredPALContext(bool value) noexcept { bEnteredPALContext = value; }
    inline bool isEnteredPALContext() const noexcept { return bEnteredPALContext; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 658
SIGNATURE:
   IPRStorage_Cold() 

BODY (preview):
    IPRStorage_Cold() { reset(); }


================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 660
SIGNATURE:
    inline void reset() noexcept

BODY (preview):
    inline void reset() noexcept {
        std::memset(this, 0, sizeof(IPRStorage_Cold));
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 674
SIGNATURE:
   IPRStorage() 

BODY (preview):
    IPRStorage() {
        hot.reset();
        cold.reset();
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 679
SIGNATURE:
    inline void reset() noexcept

BODY (preview):
    inline void reset() noexcept {
        hot.reset();
        cold.reset();
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 689
SIGNATURE:
    inline quint64& fpcr() 

BODY (preview):
    inline quint64& fpcr() { return hot.fpcr; }
    inline quint64& va() { return hot.va; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 690
SIGNATURE:
    inline quint64& va() 

BODY (preview):
    inline quint64& va() { return hot.va; }
    inline quint64& exc_addr() { return hot.exc_addr; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 691
SIGNATURE:
    inline quint64& exc_addr() 

BODY (preview):
    inline quint64& exc_addr() { return hot.exc_addr; }
    inline quint64& ptbr() { return hot.ptbr; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 692
SIGNATURE:
    inline quint64& ptbr() 

BODY (preview):
    inline quint64& ptbr() { return hot.ptbr; }
    inline quint64& asn() { return hot.asn; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 693
SIGNATURE:
    inline quint64& asn() 

BODY (preview):
    inline quint64& asn() { return hot.asn; }
    inline quint64* pal_temp() { return hot.pal_temp; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 694
SIGNATURE:
    inline quint64* pal_temp() 

BODY (preview):
    inline quint64* pal_temp() { return hot.pal_temp; }
    inline quint64& iccsr() { return hot.iccsr; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 695
SIGNATURE:
    inline quint64& iccsr() 

BODY (preview):
    inline quint64& iccsr() { return hot.iccsr; }
    inline quint64& i_ctl() { return hot.i_ctl; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 696
SIGNATURE:
    inline quint64& i_ctl() 

BODY (preview):
    inline quint64& i_ctl() { return hot.i_ctl; }
    inline quint64& m_ctl() { return hot.m_ctl; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 697
SIGNATURE:
    inline quint64& m_ctl() 

BODY (preview):
    inline quint64& m_ctl() { return hot.m_ctl; }
    inline quint64& dc_ctl() { return hot.dc_ctl; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 698
SIGNATURE:
    inline quint64& dc_ctl() 

BODY (preview):
    inline quint64& dc_ctl() { return hot.dc_ctl; }
    inline quint64& cc() { return hot.cc; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 699
SIGNATURE:
    inline quint64& cc() 

BODY (preview):
    inline quint64& cc() { return hot.cc; }


================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 702
SIGNATURE:
    inline quint64& mces() 

BODY (preview):
    inline quint64& mces() { return cold.mces; }
    inline quint64& biu_addr() { return cold.biu_addr; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 703
SIGNATURE:
    inline quint64& biu_addr() 

BODY (preview):
    inline quint64& biu_addr() { return cold.biu_addr; }
    inline quint64& sl_rcv() { return cold.sl_rcv; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 704
SIGNATURE:
    inline quint64& sl_rcv() 

BODY (preview):
    inline quint64& sl_rcv() { return cold.sl_rcv; }
    inline quint64& c_data() { return cold.c_data; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 705
SIGNATURE:
    inline quint64& c_data() 

BODY (preview):
    inline quint64& c_data() { return cold.c_data; }


================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 714
SIGNATURE:
    inline void setFpcr(quint64 fpcr_) noexcept

BODY (preview):
    inline void setFpcr(quint64 fpcr_) noexcept { hot.fpcr = fpcr_; }


================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 720
SIGNATURE:
    inline void setFPCR_RoundingMode(quint8 rm) noexcept

BODY (preview):
    inline void setFPCR_RoundingMode(quint8 rm) noexcept {
        quint64 value = hot.fpcr;
        value &= ~(FPCR_RM_MASK << FPCR_RM_SHIFT);
        value |= (static_cast<quint64>(rm) & FPCR_RM_MASK) << FPCR_RM_SHIFT;
        hot.fpcr = value;
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 737
SIGNATURE:
    inline void iccsr_setFPE(bool enable) 

BODY (preview):
    inline void iccsr_setFPE(bool enable) {
        if (enable)
            hot.iccsr |= ICCSR_Bits::FPE_MASK;
        else
            hot.iccsr &= ~ICCSR_Bits::FPE_MASK;
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 748
SIGNATURE:
    inline void iccsr_setHWE(bool enable) 

BODY (preview):
    inline void iccsr_setHWE(bool enable) {
        if (enable)
            hot.iccsr |= ICCSR_Bits::HWE_MASK;
        else
            hot.iccsr &= ~ICCSR_Bits::HWE_MASK;
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 759
SIGNATURE:
    inline void iccsr_setBPE(bool enable) 

BODY (preview):
    inline void iccsr_setBPE(bool enable) {
        if (enable)
            hot.iccsr |= ICCSR_Bits::BPE_MASK;
        else
            hot.iccsr &= ~ICCSR_Bits::BPE_MASK;
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 766
SIGNATURE:
    inline void iccsr_setBHE(bool enable) 

BODY (preview):
    inline void iccsr_setBHE(bool enable) {
        if (enable)
            hot.iccsr |= ICCSR_Bits::BHE_MASK;
        else
            hot.iccsr &= ~ICCSR_Bits::BHE_MASK;
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 777
SIGNATURE:
    inline void iccsr_setPC0(quint8 value) 

BODY (preview):
    inline void iccsr_setPC0(quint8 value) {
        hot.iccsr = (hot.iccsr & ~ICCSR_Bits::PC0_MASK) |
                    ((quint64(value) & 0x3) << ICCSR_Bits::PC0_SHIFT);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 786
SIGNATURE:
    inline void setDtb_Tag_Raw(quint64 tag) noexcept

BODY (preview):
    inline void setDtb_Tag_Raw(quint64 tag) noexcept { hot.dtbTagScratch.raw = tag; }
    inline quint64 getDtb_Tag_Raw() const noexcept { return hot.dtbTagScratch.raw; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 789
SIGNATURE:
    inline void setDtb_Tag_Vpn(quint64 vpn) noexcept

BODY (preview):
    inline void setDtb_Tag_Vpn(quint64 vpn) noexcept { hot.dtbTagScratch.vpn = vpn; }
    inline quint64 getDtb_Tag_Vpn() const noexcept { return hot.dtbTagScratch.vpn; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 792
SIGNATURE:
    inline void setDtb_Tag_Asn(quint8 asn) noexcept

BODY (preview):
    inline void setDtb_Tag_Asn(quint8 asn) noexcept { hot.dtbTagScratch.asn = asn; }
    inline quint8 getDtb_Tag_Asn() const noexcept { return hot.dtbTagScratch.asn; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 795
SIGNATURE:
    inline void setDtb_Tag_Gh(quint8 gh) noexcept

BODY (preview):
    inline void setDtb_Tag_Gh(quint8 gh) noexcept { hot.dtbTagScratch.gh = gh; }
    inline quint8 getDtb_Tag_Gh() const noexcept { return hot.dtbTagScratch.gh; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 798
SIGNATURE:
	inline void setItb_Tag_Va(VAType tag) noexcept

BODY (preview):
	inline void setItb_Tag_Va(VAType tag) noexcept { hot.itbTagScratch.va = tag; }
	inline VAType getItb_Tag_Va() const noexcept { return hot.itbTagScratch.va; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 801
SIGNATURE:
	inline void setItb_Tag_Asn(ASNType tag) noexcept

BODY (preview):
	inline void setItb_Tag_Asn(ASNType tag) noexcept { hot.itbTagScratch.asn = tag; }
	inline ASNType getItb_Tag_Asn() const noexcept { return hot.itbTagScratch.asn; }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 805
SIGNATURE:
    inline void setDtb_Tag_Bank(quint8 bank_) noexcept

BODY (preview):
    inline void setDtb_Tag_Bank(quint8 bank_) noexcept {
        hot.dtbTagScratch.bank1 = (bank_ != 0);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 814
SIGNATURE:
	inline void setMM_STAT(quint64 rawValue) noexcept

BODY (preview):
	inline void setMM_STAT(quint64 rawValue) noexcept {
		hot.mm_stat = rawValue;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 822
SIGNATURE:
    static constexpr qsizetype getHotSize() 

BODY (preview):
    static constexpr qsizetype getHotSize() {
        return static_cast<qsizetype>(sizeof(IPRStorage_Hot));
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 826
SIGNATURE:
    static constexpr qsizetype getColdSize() 

BODY (preview):
    static constexpr qsizetype getColdSize() {
        return static_cast<qsizetype>(sizeof(IPRStorage_Cold));
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IPR_Storage.h
LINE: 830
SIGNATURE:
    static constexpr qsizetype getTotalSize() 

BODY (preview):
    static constexpr qsizetype getTotalSize() {
        return static_cast<qsizetype>(sizeof(IPRStorage));
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 38
SIGNATURE:
 for(qint32 cpuId = 0; cpuId < m_numCpus; ++cpuId) 

BODY (preview):
		for (qint32 cpuId = 0; cpuId < m_numCpus; ++cpuId) {
			CPUIRQState& cpu = m_cpuStates[cpuId];
			cpu.currentIPL = 0;
			cpu.interruptsEnabled.store(true, std::memory_order_release);
			cpu.pendingIPLMask.store(0u, std::memory_order_release);
			// vectors[] already default-constructed (empty QVectors)
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 69
SIGNATURE:
 if(numCpus <= 0 || numCpus > MAX_CPUS) 

BODY (preview):
		if (numCpus <= 0 || numCpus > MAX_CPUS) {
			ERROR_LOG(QString("IRQController::reinitialize: Invalid CPU count %1").arg(numCpus));
			return;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 82
SIGNATURE:
 for(qint32 cpuId = 0; cpuId < m_numCpus; ++cpuId) 

BODY (preview):
		for (qint32 cpuId = 0; cpuId < m_numCpus; ++cpuId) {
			CPUIRQState& cpuIRQState = m_cpuStates[cpuId];

			cpuIRQState.currentIPL = 0;
			cpuIRQState.interruptsEnabled.store(true, std::memory_order_release);
			cpuIRQState.pendingIPLMask.store(0u, std::memory_order_release);

			// Clear each IPL queue
			for (int ipl = 0; ipl < NUM_IPL_LEVELS; ++ipl) {
				cpuIRQState.vectors[ipl].clear();
				cpuIRQState.vectors[ipl].squeeze();    // release unused memory
			}
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 90
SIGNATURE:
	 for(int ipl = 0; ipl < NUM_IPL_LEVELS; ++ipl) 

BODY (preview):
			for (int ipl = 0; ipl < NUM_IPL_LEVELS; ++ipl) {
				cpuIRQState.vectors[ipl].clear();
				cpuIRQState.vectors[ipl].squeeze();    // release unused memory
			}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 163
SIGNATURE:
	void recalculateInterruptPriorities(quint8 cpuId, quint8 newIer) 

BODY (preview):
	void recalculateInterruptPriorities(quint8 cpuId, quint8 newIer) {
		

		// TODO: If you later derive any per-CPU cached view of "effective IPL"
		// or AST visibility from PS + CM, update it here.
		// For now, nothing to do - OS writes IPL explicitly via IPRs.

	}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 198
SIGNATURE:
	inline void clearPendingIPL(CPUIRQState& st, quint8 ipl) noexcept

BODY (preview):
	inline void clearPendingIPL(CPUIRQState& st, quint8 ipl) noexcept {
		st.pendingIPLMask.fetch_and(~(1u << ipl), std::memory_order_release);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 271
SIGNATURE:
	 if(!it->shareable || !shareable) 

BODY (preview):
			if (!it->shareable || !shareable) {
				ERROR_LOG(QString("registerIRQVector: Vector 0x%1 already registered")
					.arg(vector, 3, 16, QChar('0')));
				return false;
			}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 299
SIGNATURE:
 if(shareable) 

BODY (preview):
		if (shareable) {
			irqState.sharedDeviceUIDs.append(deviceUid);
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 324
SIGNATURE:
 if(it->shareable) 

BODY (preview):
		if (it->shareable) {
			it->sharedDeviceUIDs.removeAll(deviceUid);
			if (!it->sharedDeviceUIDs.isEmpty()) {
				DEBUG_LOG(QString("Removed device UID=%1 from shared vector 0x%2")
					.arg(deviceUid)
					.arg(vector, 3, 16, QChar('0')));
				return true;
			}
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 407
SIGNATURE:
 if(irqState.hoseId != hoseId) 

BODY (preview):
		if (irqState.hoseId != hoseId) {
			ERROR_LOG(QString("postInterrupt: Vector 0x%1 hose mismatch")
				.arg(vector, 3, 16, QChar('0')));
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 413
SIGNATURE:
 if(irqState.masked) 

BODY (preview):
		if (irqState.masked) {
			DEBUG_LOG(QString("postInterrupt: Vector 0x%1 masked")
				.arg(vector, 3, 16, QChar('0')));
			return true;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 421
SIGNATURE:
 if(irqState.triggerMode == IRQTrigger::LEVEL) 

BODY (preview):
		if (irqState.triggerMode == IRQTrigger::LEVEL) {
			if (irqState.asserted) return true;
			irqState.asserted = true;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 443
SIGNATURE:
 if(level < 1 || level > 15) 

BODY (preview):
		if (level < 1 || level > 15) {
			WARN_LOG(QString("postSoftwareInterrupt: Invalid level %1").arg(level));
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 467
SIGNATURE:
 if(irqState.hoseId != hoseId) 

BODY (preview):
		if (irqState.hoseId != hoseId) {
			ERROR_LOG(QString("clearInterrupt: Vector 0x%1 hose mismatch")
				.arg(vector, 3, 16, QChar('0')));
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 473
SIGNATURE:
 if(irqState.triggerMode != IRQTrigger::LEVEL) 

BODY (preview):
		if (irqState.triggerMode != IRQTrigger::LEVEL) {
			WARN_LOG(QString("clearInterrupt: Vector 0x%1 is edge-triggered")
				.arg(vector, 3, 16, QChar('0')));
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 580
SIGNATURE:
 if(irqState.triggerMode == IRQTrigger::EDGE) 

BODY (preview):
		if (irqState.triggerMode == IRQTrigger::EDGE) {
			irqState.pending = false;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 707
SIGNATURE:
 if(it->asserted || it->pending) 

BODY (preview):
		if (it->asserted || it->pending) {
			qint32 targetCPU = selectTargetCPU(*it);
			deliverToCPU(targetCPU, vector, it->ipl);

			DEBUG_LOG(QString("Re-posting previously masked IRQ vector 0x%1 -> CPU%2")
				.arg(vector, 3, 16, QChar('0'))
				.arg(targetCPU));
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 743
SIGNATURE:
 if(targetCPU == -1) 

BODY (preview):
		if (targetCPU == -1) {
			for (qint32 cpuId = 0; cpuId < m_numCpus; ++cpuId) {
				if (cpuId == sourceCPU) continue;
				deliverToCPU(cpuId, vector, ipl);
			}

			DEBUG_LOG(QString("CPU%1: Sent IPI broadcast vector=0x%2, IPL=%3")
				.arg(sourceCPU)
				.arg(vector, 3, 16, QChar('0'))
				.arg(ipl));

			return true;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 744
SIGNATURE:
	 for(qint32 cpuId = 0; cpuId < m_numCpus; ++cpuId) 

BODY (preview):
			for (qint32 cpuId = 0; cpuId < m_numCpus; ++cpuId) {
				if (cpuId == sourceCPU) continue;
				deliverToCPU(cpuId, vector, ipl);
			}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 791
SIGNATURE:
 for(qint32 cpuId = 0; cpuId < m_numCpus; ++cpuId) 

BODY (preview):
		for (qint32 cpuId = 0; cpuId < m_numCpus; ++cpuId) {
			const CPUIRQState& cpuIRQState = m_cpuStates[cpuId];

			bool enabled =
				cpuIRQState.interruptsEnabled.load(std::memory_order_acquire);
			quint32 mask =
				cpuIRQState.pendingIPLMask.load(std::memory_order_acquire);

			lines << QString("  CPU%1: IPL=%2, Interrupts=%3")
				.arg(cpuId)
				.arg(cpuIRQState.currentIPL)
				.arg(enabled ? "ENABLED" : "DISABLED");

			if (mask != 0) {
				QStringList pendingIPLs;

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 804
SIGNATURE:
	 if(mask != 0) 

BODY (preview):
			if (mask != 0) {
				QStringList pendingIPLs;
				for (quint8 ipl = 0; ipl < NUM_IPL_LEVELS; ++ipl) {
					if (mask & (1u << ipl)) {
						int count = cpuIRQState.vectors[ipl].size();
						pendingIPLs
							<< QString("IPL%1(%2)").arg(ipl).arg(count);
					}
				}
				lines << QString("    Pending: %1")
					.arg(pendingIPLs.join(", "));
			}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 806
SIGNATURE:
		 for(quint8 ipl = 0; ipl < NUM_IPL_LEVELS; ++ipl) 

BODY (preview):
				for (quint8 ipl = 0; ipl < NUM_IPL_LEVELS; ++ipl) {
					if (mask & (1u << ipl)) {
						int count = cpuIRQState.vectors[ipl].size();
						pendingIPLs
							<< QString("IPL%1(%2)").arg(ipl).arg(count);
					}
				}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 839
SIGNATURE:
 for(qint32 cpuId = 0; cpuId < m_numCpus; ++cpuId) 

BODY (preview):
		for (qint32 cpuId = 0; cpuId < m_numCpus; ++cpuId) {
			const CPUIRQState& cpuIRQState = m_cpuStates[cpuId];
			for (int ipl = 0; ipl < NUM_IPL_LEVELS; ++ipl) {
				outPendingCount += cpuIRQState.vectors[ipl].count(vector);
			}
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 841
SIGNATURE:
	 for(int ipl = 0; ipl < NUM_IPL_LEVELS; ++ipl) 

BODY (preview):
			for (int ipl = 0; ipl < NUM_IPL_LEVELS; ++ipl) {
				outPendingCount += cpuIRQState.vectors[ipl].count(vector);
			}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 867
SIGNATURE:
 for(auto& irqState : m_irqStates) 

BODY (preview):
		for (auto& irqState : m_irqStates) {
			irqState.asserted = false;
			irqState.pending = false;
			irqState.assertCount = 0;
			irqState.lastServicedCPU = -1;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 874
SIGNATURE:
 for(qint32 cpuId = 0; cpuId < m_numCpus; ++cpuId) 

BODY (preview):
		for (qint32 cpuId = 0; cpuId < m_numCpus; ++cpuId) {
			CPUIRQState& cpuIRQState = m_cpuStates[cpuId];
			cpuIRQState.currentIPL = 0;
			cpuIRQState.interruptsEnabled.store(true,
				std::memory_order_release);
			cpuIRQState.pendingIPLMask.store(0u,
				std::memory_order_release);

			for (int ipl = 0; ipl < NUM_IPL_LEVELS; ++ipl) {
				cpuIRQState.vectors[ipl].clear();
			}
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 882
SIGNATURE:
	 for(int ipl = 0; ipl < NUM_IPL_LEVELS; ++ipl) 

BODY (preview):
			for (int ipl = 0; ipl < NUM_IPL_LEVELS; ++ipl) {
				cpuIRQState.vectors[ipl].clear();
			}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 924
SIGNATURE:
 switch(irqState.routingPolicy) 

BODY (preview):
		switch (irqState.routingPolicy) {
		case IRQRoutingPolicy::FIXED_CPU:
			if (irqState.affinityCPU >= 0 &&
				irqState.affinityCPU < m_numCpus) {
				return irqState.affinityCPU;
			}
			return 0;

		case IRQRoutingPolicy::ROUND_ROBIN: {
			qint32 cpuOfInterest =
				m_nextCPU.fetchAndAddOrdered(1) % m_numCpus;
			irqState.lastServicedCPU = cpuOfInterest;
			return cpuOfInterest;
		}


================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 943
SIGNATURE:
	 for(qint32 cpuId = 1; cpuId < m_numCpus; ++cpuId) 

BODY (preview):
			for (qint32 cpuId = 1; cpuId < m_numCpus; ++cpuId) {
				const CPUIRQState& cpu = m_cpuStates[cpuId];
				bool enabled =
					cpu.interruptsEnabled.load(std::memory_order_acquire);
				if (enabled && cpu.currentIPL < lowestIPL) {
					lowestIPL = cpu.currentIPL;
					bestCPU = cpuId;
				}
			}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 947
SIGNATURE:
		 if(enabled && cpu.currentIPL < lowestIPL) 

BODY (preview):
				if (enabled && cpu.currentIPL < lowestIPL) {
					lowestIPL = cpu.currentIPL;
					bestCPU = cpuId;
				}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 984
SIGNATURE:
           if(m_interruptHook) 

BODY (preview):
            if (m_interruptHook) {
                m_interruptHook(it->hoseId, vector, ipl, cpuId);
            }

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 1020
SIGNATURE:
 if(callback) 

BODY (preview):
		if (callback) {
			callback(cpuId);
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQController.h
LINE: 1027
SIGNATURE:
 for(int level = 1; level <= 15; ++level) 

BODY (preview):
		for (int level = 1; level <= 15; ++level) {
			const quint32 vec = mmioSpace_VectorPolicy::SWI_BASE + level;
			const quint8  ipl = static_cast<quint8>(level);

			registerIRQVector(
				vec,
				ipl,
				HOSE_SW_INT,
				0xFFFF0001u,
				"SWI",
				IRQTrigger::EDGE,
				true);

			IrqRoutingConfig cfg;
			cfg.policy = IRQRoutingPolicy::ROUND_ROBIN;

================================================================================
FILE: z:\EmulatRApp\coreLib\IRQ_core.h
LINE: 91
SIGNATURE:
		void clear() noexcept

BODY (preview):
		void clear() noexcept {
			count = 0;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\MCES_helpers.h
LINE: 140
SIGNATURE:
   switch(reason) 

BODY (preview):
    switch (reason) {

    case MachineCheckReason::SYSTEM_CORRECTABLE_ERROR:
        // System-level correctable error (memory / bus).
        newMCES |= MCES_MASK_MIP;
        newMCES |= MCES_MASK_SCE;
        break;

    case MachineCheckReason::PROCESSOR_CORRECTABLE_ERROR:
        // CPU-local correctable error (cache / pipeline).
        newMCES |= MCES_MASK_MIP;
        newMCES |= MCES_MASK_PCE;
        break;

    case MachineCheckReason::BUFFER_WRITE_ERROR:

================================================================================
FILE: z:\EmulatRApp\coreLib\mmio_core.h
LINE: 67
SIGNATURE:
	inline bool isReserved(quint32 vec) 

BODY (preview):
	inline bool isReserved(quint32 vec) {
		return (vec >= EXC_BASE && vec < EXC_LIMIT) ||
			(vec >= SWI_BASE && vec < SWI_LIMIT) ||
			(vec >= AST_BASE && vec < AST_LIMIT);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\mmio_core.h
LINE: 209
SIGNATURE:
 : hoseId(id) 

BODY (preview):
	Hose(quint16 id) : hoseId(id) {
		mmio32.base = 0;
		mmio32.size = 0;
		mmio32.cursor = 0;
		mmio32.allocated = 0;

		mmio64.base = 0;
		mmio64.size = 0;
		mmio64.cursor = 0;
		mmio64.allocated = 0;

		irqDomain.base = 0;
		irqDomain.limit = 0;
		irqDomain.cursor = 0;
		irqDomain.allocated = 0;

================================================================================
FILE: z:\EmulatRApp\coreLib\onIPLChanged_inl.h
LINE: 7
SIGNATURE:
inline void onIPLChanged(CPUIdType cpuId, quint8 oldIPL, quint8 newIPL) noexcept

BODY (preview):
inline void onIPLChanged(CPUIdType cpuId, quint8 oldIPL, quint8 newIPL) noexcept{
	auto& irqq = global_IRQController();
	irqq.setCPUIpl(static_cast<qint32>(cpuId), newIPL);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\PCTX_helpers.h
LINE: 213
SIGNATURE:
 if(fpe) 

BODY (preview):
// 	if (fpe) {
// 		p |= PCTX_FPE_MASK;
// 	}

================================================================================
FILE: z:\EmulatRApp\coreLib\PCTX_helpers.h
LINE: 223
SIGNATURE:
 if(ppce) 

BODY (preview):
// 	if (ppce) {
// 		p |= PCTX_PPCE_MASK;
// 	}

================================================================================
FILE: z:\EmulatRApp\coreLib\PCTX_helpers.h
LINE: 240
SIGNATURE:
 if(fpeOnReset) 

BODY (preview):
// 	if (fpeOnReset) {
// 		iprs.pctx |= PCTX_FPE_MASK;
// 	}

================================================================================
FILE: z:\EmulatRApp\coreLib\permissions_helper.h
LINE: 11
SIGNATURE:
static constexpr quint64 pageShift(PageSizeCode code) noexcept

BODY (preview):
static constexpr quint64 pageShift(PageSizeCode code) noexcept {
	switch (code) {
	case PageSizeCode::PageSize_4K:  return 12;
	case PageSizeCode::PageSize_8K:  return 13;
	case PageSizeCode::PageSize_64K: return 16;
	default: return 12;  // Default 4K
	}
}

================================================================================
FILE: z:\EmulatRApp\coreLib\permissions_helper.h
LINE: 20
SIGNATURE:
static constexpr quint64 pageSizeBytes(PageSizeCode code) noexcept

BODY (preview):
static constexpr quint64 pageSizeBytes(PageSizeCode code) noexcept {
	return 1ULL << pageShift(code);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\permissions_helper.h
LINE: 26
SIGNATURE:
static constexpr bool allowRead(AccessPerm perm, bool userMode) noexcept

BODY (preview):
static constexpr bool allowRead(AccessPerm perm, bool userMode) noexcept {
	switch (perm) {
	case AccessPerm::Read:
	case AccessPerm::ReadExec:
	case AccessPerm::ReadWrite:
	case AccessPerm::Full:
		return true;
	default:
		return false;
	}
}

================================================================================
FILE: z:\EmulatRApp\coreLib\permissions_helper.h
LINE: 38
SIGNATURE:
static constexpr bool allowWrite(AccessPerm perm, bool userMode) noexcept

BODY (preview):
static constexpr bool allowWrite(AccessPerm perm, bool userMode) noexcept {
	switch (perm) {
	case AccessPerm::Write:
	case AccessPerm::WriteExec:
	case AccessPerm::ReadWrite:
	case AccessPerm::Full:
		return true;
	default:
		return false;
	}
}

================================================================================
FILE: z:\EmulatRApp\coreLib\permissions_helper.h
LINE: 50
SIGNATURE:
static constexpr bool allowExecute(AccessPerm perm, bool userMode) noexcept

BODY (preview):
static constexpr bool allowExecute(AccessPerm perm, bool userMode) noexcept {
	switch (perm) {
	case AccessPerm::Execute:
	case AccessPerm::ReadExec:
	case AccessPerm::WriteExec:
	case AccessPerm::Full:
		return true;
	default:
		return false;
	}
}

================================================================================
FILE: z:\EmulatRApp\coreLib\permissions_helper.h
LINE: 61
SIGNATURE:
inline bool canUserRead(quint8 perms) 

BODY (preview):
inline bool canUserRead(quint8 perms) { return perms & USER_READ; }
inline bool canUserWrite(quint8 perms) { return perms & USER_WRITE; }

================================================================================
FILE: z:\EmulatRApp\coreLib\permissions_helper.h
LINE: 62
SIGNATURE:
inline bool canUserWrite(quint8 perms) 

BODY (preview):
inline bool canUserWrite(quint8 perms) { return perms & USER_WRITE; }
inline bool canUserExec(quint8 perms) { return perms & USER_EXEC; }

================================================================================
FILE: z:\EmulatRApp\coreLib\permissions_helper.h
LINE: 63
SIGNATURE:
inline bool canUserExec(quint8 perms) 

BODY (preview):
inline bool canUserExec(quint8 perms) { return perms & USER_EXEC; }
inline bool canKernelRead(quint8 perms) { return perms & KERNEL_READ; }

================================================================================
FILE: z:\EmulatRApp\coreLib\permissions_helper.h
LINE: 64
SIGNATURE:
inline bool canKernelRead(quint8 perms) 

BODY (preview):
inline bool canKernelRead(quint8 perms) { return perms & KERNEL_READ; }


================================================================================
FILE: z:\EmulatRApp\coreLib\permissions_helper.h
LINE: 66
SIGNATURE:
inline bool hasPermission(quint8 perms, AccessType type, PrivilegeLevel level) 

BODY (preview):
inline bool hasPermission(quint8 perms, AccessType type, PrivilegeLevel level) {
	switch (type) {
	case Read:
		return (level == (PrivilegeLevel)Mode_Privilege::User) ? (perms & USER_READ) : (perms & KERNEL_READ);
	case Write:
		return (level == (PrivilegeLevel)Mode_Privilege::User) ? (perms & USER_WRITE) : (perms & KERNEL_WRITE);
	case Execute:
		return (level == (PrivilegeLevel)Mode_Privilege::User) ? (perms & USER_EXEC) : (perms & KERNEL_EXEC);
	}
	return false;
}

================================================================================
FILE: z:\EmulatRApp\coreLib\QtRandomCompat.h
LINE: 20
SIGNATURE:
inline void seedEmulatrRandom() 

BODY (preview):
inline void seedEmulatrRandom() {
	qsrand(static_cast<uint>(QTime::currentTime().msec()));
}

================================================================================
FILE: z:\EmulatRApp\coreLib\QtRandomCompat.h
LINE: 24
SIGNATURE:
inline void seedEmulatrRandom() 

BODY (preview):
inline void seedEmulatrRandom() {} // No-op for QRandomGenerator
#endif

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 74
SIGNATURE:
	static ReservationManager& instance() 

BODY (preview):
	static ReservationManager& instance() {
		static ReservationManager mgr;
		return mgr;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 83
SIGNATURE:
 : m_numCpus(numCpus) 

BODY (preview):
	explicit ReservationManager(quint16 numCpus) : m_numCpus(numCpus) {
		m_reservations.resize(numCpus);
		m_ts.reset(new QAtomicInteger<quint64>[numCpus]);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 88
SIGNATURE:
	void setTimestamp(quint16 cpuId, quint64 v) noexcept

BODY (preview):
	void setTimestamp(quint16 cpuId, quint64 v) noexcept {
		if (cpuId >= m_numCpus || !m_ts) return;
		m_ts[cpuId].storeRelease(v);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 113
SIGNATURE:
	inline bool setReservation(quint16 cpuId, quint64 pa) 

BODY (preview):
	inline bool setReservation(quint16 cpuId, quint64 pa) {
		return reserve(cpuId, pa);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 139
SIGNATURE:
	inline void clearReservation(quint16 cpuId, quint64 pa) 

BODY (preview):
	inline void clearReservation(quint16 cpuId, quint64 pa) {
		Q_UNUSED(pa);  // Your implementation clears entire CPU reservation
		clearReservation(cpuId);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 149
SIGNATURE:
	inline void clearAllReservationForCpu(quint16 cpuId) 

BODY (preview):
	inline void clearAllReservationForCpu(quint16 cpuId) {
		clearReservation(cpuId);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 165
SIGNATURE:
	void setOnInvalidatedCallback(const OnReservationInvalidatedFn& fn) 

BODY (preview):
	void setOnInvalidatedCallback(const OnReservationInvalidatedFn& fn) {
		m_onInvalidated = fn;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 183
SIGNATURE:
	bool reserve(quint16 cpuId, quint64 pa) 

BODY (preview):
	bool reserve(quint16 cpuId, quint64 pa) {
		if (cpuId >= m_numCpus) {
			qWarning() << "ReservationManager: reserve() invalid CPU" << cpuId;
			return false;
		}

		QWriteLocker locker(&m_lock);

		quint64 alignedPa = alignToCacheLine(pa);
		m_reservations[cpuId].pa = alignedPa;
		m_reservations[cpuId].valid = true;
		// 		m_timestamps[cpuId].store(
		// 			std::chrono::system_clock::now().time_since_epoch().count(),
		// 			std::memory_order_relaxed
		// 		);

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 184
SIGNATURE:
 if(cpuId >= m_numCpus) 

BODY (preview):
		if (cpuId >= m_numCpus) {
			qWarning() << "ReservationManager: reserve() invalid CPU" << cpuId;
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 219
SIGNATURE:
	bool tryStoreConditional(quint16 cpuId, quint64 pa) 

BODY (preview):
	bool tryStoreConditional(quint16 cpuId, quint64 pa) {
		if (cpuId >= m_numCpus) {
			qWarning() << "ReservationManager: tryStoreConditional() invalid CPU" << cpuId;
			return false;
		}

		QWriteLocker locker(&m_lock);

		const Reservation& res = m_reservations[cpuId];
		quint64 alignedPa = alignToCacheLine(pa);

		// Check if reservation is still valid on this address
		if (!res.valid || res.pa != alignedPa) {
			qDebug() << "ReservationManager: CPU" << cpuId << "SC failed at" << pa
				<< "(reservation:" << (res.valid ? "valid" : "invalid")

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 220
SIGNATURE:
 if(cpuId >= m_numCpus) 

BODY (preview):
		if (cpuId >= m_numCpus) {
			qWarning() << "ReservationManager: tryStoreConditional() invalid CPU" << cpuId;
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 231
SIGNATURE:
 if(!res.valid || res.pa != alignedPa) 

BODY (preview):
		if (!res.valid || res.pa != alignedPa) {
			qDebug() << "ReservationManager: CPU" << cpuId << "SC failed at" << pa
				<< "(reservation:" << (res.valid ? "valid" : "invalid")
				<< "PA:" << res.pa << ")";
			return false;  // SC fails
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 263
SIGNATURE:
	void conflictWrite(quint64 pa) 

BODY (preview):
	void conflictWrite(quint64 pa) {
		QWriteLocker locker(&m_lock);

		quint64 alignedPa = alignToCacheLine(pa);
		bool anyInvalidated = false;

		for (quint16 cpuId = 0; cpuId < m_numCpus; ++cpuId) {
			Reservation& res = m_reservations[cpuId];

			if (res.valid && samecacheLine(res.pa, alignedPa)) {
				res.valid = false;
				anyInvalidated = true;
				m_conflictCount.fetch_add(1, std::memory_order_relaxed);

				// Trigger callback for this CPU

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 269
SIGNATURE:
 for(quint16 cpuId = 0; cpuId < m_numCpus; ++cpuId) 

BODY (preview):
		for (quint16 cpuId = 0; cpuId < m_numCpus; ++cpuId) {
			Reservation& res = m_reservations[cpuId];

			if (res.valid && samecacheLine(res.pa, alignedPa)) {
				res.valid = false;
				anyInvalidated = true;
				m_conflictCount.fetch_add(1, std::memory_order_relaxed);

				// Trigger callback for this CPU
				if (m_onInvalidated) {
					// Invoke callback (outside lock would be better, but this is acceptable)
					m_onInvalidated(cpuId, pa);
				}

				qDebug() << "ReservationManager: CPU" << cpuId << "reservation invalidated by write to" << pa;

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 278
SIGNATURE:
		 if(m_onInvalidated) 

BODY (preview):
				if (m_onInvalidated) {
					// Invoke callback (outside lock would be better, but this is acceptable)
					m_onInvalidated(cpuId, pa);
				}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 287
SIGNATURE:
 if(anyInvalidated) 

BODY (preview):
		if (anyInvalidated) {
			qDebug() << "ReservationManager: conflict write at" << pa << "invalidated reservation(s)";
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 301
SIGNATURE:
	void clearReservation(quint16 cpuId) 

BODY (preview):
	void clearReservation(quint16 cpuId) {
		if (cpuId >= m_numCpus) {
			qWarning() << "ReservationManager: clearReservation() invalid CPU" << cpuId;
			return;
		}

		QWriteLocker locker(&m_lock);

		if (m_reservations[cpuId].valid) {
			quint64 pa = m_reservations[cpuId].pa;
			m_reservations[cpuId].valid = false;
			qDebug() << "ReservationManager: CPU" << cpuId << "reservation cleared (was at" << pa << ")";
		}
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 302
SIGNATURE:
 if(cpuId >= m_numCpus) 

BODY (preview):
		if (cpuId >= m_numCpus) {
			qWarning() << "ReservationManager: clearReservation() invalid CPU" << cpuId;
			return;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 309
SIGNATURE:
 if(m_reservations[cpuId].valid) 

BODY (preview):
		if (m_reservations[cpuId].valid) {
			quint64 pa = m_reservations[cpuId].pa;
			m_reservations[cpuId].valid = false;
			qDebug() << "ReservationManager: CPU" << cpuId << "reservation cleared (was at" << pa << ")";
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 319
SIGNATURE:
	void clearAllReservationForCpu() 

BODY (preview):
	void clearAllReservationForCpu() {
		QWriteLocker locker(&m_lock);

		for (auto& res : m_reservations) {
			res.valid = false;
		}

		qDebug() << "ReservationManager: all reservations cleared";
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 322
SIGNATURE:
 for(auto& res : m_reservations) 

BODY (preview):
		for (auto& res : m_reservations) {
			res.valid = false;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 341
SIGNATURE:
 if(cpuId >= m_numCpus) 

BODY (preview):
		if (cpuId >= m_numCpus) {
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 361
SIGNATURE:
 if(cpuId >= m_numCpus) 

BODY (preview):
		if (cpuId >= m_numCpus) {
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 368
SIGNATURE:
 if(!res.valid) 

BODY (preview):
		if (!res.valid) {
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 377
SIGNATURE:
	inline void invalidateRange(quint64 pa, quint64 size) 

BODY (preview):
	inline void invalidateRange(quint64 pa, quint64 size) {
		if (size == 0) return;

		// Align start down to cache line; walk lines until we cover the span
		const quint64 lineSize = CACHE_LINE_SIZE;          // 64
		quint64 start = pa & CACHE_LINE_MASK;              // alignDown
		const quint64 end = pa + size;                     // non-inclusive

		for (quint64 p = start; p < end; p += lineSize) {
			conflictWrite(p);                              // existing per-line invalidation
		}
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 385
SIGNATURE:
 for(quint64 p = start; p < end; p += lineSize) 

BODY (preview):
		for (quint64 p = start; p < end; p += lineSize) {
			conflictWrite(p);                              // existing per-line invalidation
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 390
SIGNATURE:
	bool isValid(quint16 cpuId) 

BODY (preview):
	bool isValid(quint16 cpuId) {

		if (cpuId >= m_numCpus) {
			return false;
		}
		QReadLocker locker(&m_lock);
		const Reservation& res = m_reservations[cpuId];
		return res.valid;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 392
SIGNATURE:
 if(cpuId >= m_numCpus) 

BODY (preview):
		if (cpuId >= m_numCpus) {
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 400
SIGNATURE:
	quint64 pa(quint16 cpuId) 

BODY (preview):
	quint64 pa(quint16 cpuId) {

		if (cpuId >= m_numCpus) {
			return false;
		}
		QReadLocker locker(&m_lock);
		const Reservation& res = m_reservations[cpuId];
		return res.pa;
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 402
SIGNATURE:
 if(cpuId >= m_numCpus) 

BODY (preview):
		if (cpuId >= m_numCpus) {
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 422
SIGNATURE:
 for(const auto& res : m_reservations) 

BODY (preview):
		for (const auto& res : m_reservations) {
			if (res.valid) {
				activeCount++;
			}
		}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 423
SIGNATURE:
	 if(res.valid) 

BODY (preview):
			if (res.valid) {
				activeCount++;
			}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 484
SIGNATURE:
inline bool resReserve(ReservationManager* resMgr, quint16 cpuId, quint64 pa) 

BODY (preview):
inline bool resReserve(ReservationManager* resMgr, quint16 cpuId, quint64 pa) {
	if (!resMgr) return true;  // No reservation mgr; allow SC to succeed
	return resMgr->reserve(cpuId, pa);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 492
SIGNATURE:
inline bool resCheckSC(ReservationManager* resMgr, quint16 cpuId, quint64 pa) 

BODY (preview):
inline bool resCheckSC(ReservationManager* resMgr, quint16 cpuId, quint64 pa) {
	if (!resMgr) return true;  // No reservation mgr; SC always succeeds
	return resMgr->tryStoreConditional(cpuId, pa);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\reservationManager_core.h
LINE: 500
SIGNATURE:
inline void resConflictWrite(ReservationManager* resMgr, quint64 pa) 

BODY (preview):
inline void resConflictWrite(ReservationManager* resMgr, quint64 pa) {
	if (resMgr) resMgr->conflictWrite(pa);
}

================================================================================
FILE: z:\EmulatRApp\coreLib\TraceConvert.h
LINE: 7
SIGNATURE:
inline std::string toStdString(const std::string& s) 

BODY (preview):
inline std::string toStdString(const std::string& s) {
    return s;
}

================================================================================
FILE: z:\EmulatRApp\coreLib\TraceConvert.h
LINE: 11
SIGNATURE:
inline std::string toStdString(const char* s) 

BODY (preview):
inline std::string toStdString(const char* s) {
    return std::string{s};
}

================================================================================
FILE: z:\EmulatRApp\coreLib\TraceConvert.h
LINE: 15
SIGNATURE:
inline std::string toStdString(const QString& s) 

BODY (preview):
inline std::string toStdString(const QString& s) {
    return s.toStdString();
}

================================================================================
FILE: z:\EmulatRApp\coreLib\TraceCore.h
LINE: 14
SIGNATURE:
    static void installSink(SinkFn fn) 

BODY (preview):
    static void installSink(SinkFn fn) {
        getSink() = std::move(fn);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\TraceCore.h
LINE: 18
SIGNATURE:
    static void log(Level lvl, const std::string& msg) 

BODY (preview):
    static void log(Level lvl, const std::string& msg) {
        auto& sink = getSink();
        if (sink) sink(lvl, msg);
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\TraceCore.h
LINE: 24
SIGNATURE:
    static SinkFn& getSink() 

BODY (preview):
    static SinkFn& getSink() {
        static SinkFn sink;
        return sink;
    }

================================================================================
FILE: z:\EmulatRApp\coreLib\types_core.h
LINE: 208
SIGNATURE:
	inline constexpr bool kre(PermMask pm) noexcept

BODY (preview):
	inline constexpr bool kre(PermMask pm) noexcept { return extractBit(pm, PTE_BIT_KRE); }
	inline constexpr bool ere(PermMask pm) noexcept { return extractBit(pm, PTE_BIT_ERE); }

================================================================================
FILE: z:\EmulatRApp\coreLib\types_core.h
LINE: 209
SIGNATURE:
	inline constexpr bool ere(PermMask pm) noexcept

BODY (preview):
	inline constexpr bool ere(PermMask pm) noexcept { return extractBit(pm, PTE_BIT_ERE); }
	inline constexpr bool sre(PermMask pm) noexcept { return extractBit(pm, PTE_BIT_SRE); }

================================================================================
FILE: z:\EmulatRApp\coreLib\types_core.h
LINE: 210
SIGNATURE:
	inline constexpr bool sre(PermMask pm) noexcept

BODY (preview):
	inline constexpr bool sre(PermMask pm) noexcept { return extractBit(pm, PTE_BIT_SRE); }
	inline constexpr bool ure(PermMask pm) noexcept { return extractBit(pm, PTE_BIT_URE); }

================================================================================
FILE: z:\EmulatRApp\coreLib\types_core.h
LINE: 211
SIGNATURE:
	inline constexpr bool ure(PermMask pm) noexcept

BODY (preview):
	inline constexpr bool ure(PermMask pm) noexcept { return extractBit(pm, PTE_BIT_URE); }


================================================================================
FILE: z:\EmulatRApp\coreLib\types_core.h
LINE: 214
SIGNATURE:
	inline constexpr bool kwe(PermMask pm) noexcept

BODY (preview):
	inline constexpr bool kwe(PermMask pm) noexcept { return extractBit(pm, PTE_BIT_KWE); }
	inline constexpr bool ewe(PermMask pm) noexcept { return extractBit(pm, PTE_BIT_EWE); }

================================================================================
FILE: z:\EmulatRApp\coreLib\types_core.h
LINE: 215
SIGNATURE:
	inline constexpr bool ewe(PermMask pm) noexcept

BODY (preview):
	inline constexpr bool ewe(PermMask pm) noexcept { return extractBit(pm, PTE_BIT_EWE); }
	inline constexpr bool swe(PermMask pm) noexcept { return extractBit(pm, PTE_BIT_SWE); }

================================================================================
FILE: z:\EmulatRApp\coreLib\types_core.h
LINE: 216
SIGNATURE:
	inline constexpr bool swe(PermMask pm) noexcept

BODY (preview):
	inline constexpr bool swe(PermMask pm) noexcept { return extractBit(pm, PTE_BIT_SWE); }
	inline constexpr bool uwe(PermMask pm) noexcept { return extractBit(pm, PTE_BIT_UWE); }

================================================================================
FILE: z:\EmulatRApp\coreLib\types_core.h
LINE: 217
SIGNATURE:
	inline constexpr bool uwe(PermMask pm) noexcept

BODY (preview):
	inline constexpr bool uwe(PermMask pm) noexcept { return extractBit(pm, PTE_BIT_UWE); }


================================================================================
FILE: z:\EmulatRApp\coreLib\types_core.h
LINE: 257
SIGNATURE:
	inline constexpr bool canReadKernel(PermMask pm) noexcept

BODY (preview):
	inline constexpr bool canReadKernel(PermMask pm) noexcept {
		return kre(pm) || ere(pm) || sre(pm);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\types_core.h
LINE: 261
SIGNATURE:
	inline constexpr bool canWriteKernel(PermMask pm) noexcept

BODY (preview):
	inline constexpr bool canWriteKernel(PermMask pm) noexcept {
		return kwe(pm) || ewe(pm) || swe(pm);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\types_core.h
LINE: 265
SIGNATURE:
	inline constexpr bool canReadUser(PermMask pm) noexcept

BODY (preview):
	inline constexpr bool canReadUser(PermMask pm) noexcept {
		return ure(pm);
	}

================================================================================
FILE: z:\EmulatRApp\coreLib\types_core.h
LINE: 269
SIGNATURE:
	inline constexpr bool canWriteUser(PermMask pm) noexcept

BODY (preview):
	inline constexpr bool canWriteUser(PermMask pm) noexcept {
		return uwe(pm);
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 142
SIGNATURE:
	AXP_FLATTEN bool hasStagedDTBUpdate() 

BODY (preview):
	AXP_FLATTEN bool hasStagedDTBUpdate() { return m_hasStagedDTBUpdate; }


================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 151
SIGNATURE:
	AXP_FLATTEN void stageDTBUpdate(const Ev6TLBTag& tag, const AlphaPTE& pte) noexcept

BODY (preview):
	AXP_FLATTEN void stageDTBUpdate(const Ev6TLBTag& tag, const AlphaPTE& pte) noexcept {
		m_stagedDTBTAG = tag;
		m_stagedDTBPTE = pte;
		m_hasStagedDTBUpdate = true;
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 156
SIGNATURE:
	AXP_FLATTEN void clearStagedDTBUpdate() noexcept

BODY (preview):
	AXP_FLATTEN void clearStagedDTBUpdate() noexcept {
		m_stagedDTBTAG = Ev6TLBTag{};
		m_stagedDTBPTE = AlphaPTE{};
		m_hasStagedDTBUpdate = false;
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 165
SIGNATURE:
	AXP_FLATTEN void stageITBUpdate(const Ev6TLBTag& tag, const AlphaPTE& pte) noexcept

BODY (preview):
	AXP_FLATTEN void stageITBUpdate(const Ev6TLBTag& tag, const AlphaPTE& pte) noexcept {
		m_stagedITBTAG = tag;
		m_stagedITBPTE = pte;
		m_hasStagedITBUpdate = true;
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 170
SIGNATURE:
	AXP_FLATTEN void clearStagedITBUpdate() noexcept

BODY (preview):
	AXP_FLATTEN void clearStagedITBUpdate() noexcept {
		m_stagedITBTAG = Ev6TLBTag{};
		m_stagedITBPTE = AlphaPTE{};
		m_hasStagedITBUpdate = false;
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 179
SIGNATURE:
	AXP_FLATTEN void stageDTB0PTE(quint64 rawPte) noexcept

BODY (preview):
	AXP_FLATTEN void stageDTB0PTE(quint64 rawPte) noexcept {
		AlphaPTE pte(rawPte);
		m_stagedDTBPTE0 = pte;
		m_hasStagedDTBUpdate = true;
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 184
SIGNATURE:
	AXP_FLATTEN void stageDTB1PTE(quint64 rawPte) noexcept

BODY (preview):
	AXP_FLATTEN void stageDTB1PTE(quint64 rawPte) noexcept {
		AlphaPTE pte(rawPte);
		m_stagedDTBPTE1 = pte;
		m_hasStagedDTBUpdate = true;
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 189
SIGNATURE:
	AXP_FLATTEN void stageDTBTag(const Ev6TLBTag& tag) noexcept

BODY (preview):
	AXP_FLATTEN void stageDTBTag(const Ev6TLBTag& tag) noexcept {
		m_stagedDTBTAG = tag;
		m_hasStagedDTBUpdate = true;
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 194
SIGNATURE:
	AXP_FLATTEN void stageDTBPTE(quint64 rawPte) noexcept

BODY (preview):
	AXP_FLATTEN void stageDTBPTE(quint64 rawPte) noexcept {
		AlphaPTE pte(rawPte);
		m_stagedDTBPTE = pte;
		m_hasStagedDTBUpdate = true;
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 199
SIGNATURE:
	AXP_FLATTEN void stageITBPTE(quint64 rawPte) noexcept

BODY (preview):
	AXP_FLATTEN void stageITBPTE(quint64 rawPte) noexcept {

		Q_ASSERT(iprs.itbTagScratch.valid && "ITB_TAG not staged before ITB_PTE");

		AlphaPTE pte(rawPte);
		m_stagedITBPTE = pte;

		auto& iprs = globalIPRBank()[m_cpuId];
		VAType va = iprs.getItb_Tag_Va();
		ASNType asn = iprs.getItb_Tag_Asn();
		quint8 gh = pte.pteGH(pte.raw);
		PFNType pfn = pte.pfn();
		bool isGlobal = pte.isGlobal();

		onStageITBPTE(m_cpuId, Realm::I, gh, va, pfn, asn, isGlobal);

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 219
SIGNATURE:
	AXP_FLATTEN void clearStagedDTBUpdate() 

BODY (preview):
	AXP_FLATTEN void clearStagedDTBUpdate() {
		m_stagedDTBPTE = AlphaPTE{};
		m_stagedDTBPTE0 = AlphaPTE{};
		m_stagedDTBPTE1 = AlphaPTE{};
		m_stagedITBPTE = AlphaPTE{};
		m_stagedDTBTAG = Ev6TLBTag{};

		m_hasStagedDTBUpdate = false;

	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 229
SIGNATURE:
	AXP_FLATTEN void clearStagedITBUpdate() 

BODY (preview):
	AXP_FLATTEN void clearStagedITBUpdate() {
		m_stagedITBPTE.clear();
		m_stagedITBTAG.clear();
		m_hasStagedITBUpdate = false;
		m_hasStagedITBTagUpdate = false;
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 366
SIGNATURE:
	AXP_FLATTEN void Halt() noexcept

BODY (preview):
	AXP_FLATTEN void Halt() noexcept {  // TODO

	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 373
SIGNATURE:
	inline void notifyHalt() noexcept

BODY (preview):
	inline void notifyHalt() noexcept {
		//todo
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 377
SIGNATURE:
	AXP_FLATTEN void syncMemoryBarrier() noexcept

BODY (preview):
	AXP_FLATTEN void syncMemoryBarrier() noexcept { //TODO

	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 401
SIGNATURE:
	void writeFpReg(quint8 index, quint64 value) noexcept

BODY (preview):
	void writeFpReg(quint8 index, quint64 value) noexcept {
		m_fBox->writeFpReg(index, value);
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 405
SIGNATURE:
	AXP_FLATTEN quint64 getFPCRRaw() noexcept

BODY (preview):
	AXP_FLATTEN quint64 getFPCRRaw()  noexcept  { return m_fBox->getFPCRRaw(); }


================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 411
SIGNATURE:
	AXP_FLATTEN bool fpcrLT() noexcept

BODY (preview):
	AXP_FLATTEN bool fpcrLT() noexcept {
		constexpr quint64 FPCR_LT = (1ULL << AlphaFPCR::FPCC_LT_BIT);
		return (m_fBox->getFPCRRaw() & FPCR_LT) != 0;
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 444
SIGNATURE:
	AXP_FLATTEN FpcrRegister& getFPCRRegister() noexcept

BODY (preview):
	AXP_FLATTEN FpcrRegister& getFPCRRegister()  noexcept  { return m_fBox->getFPCRegister(); }


================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 484
SIGNATURE:
 catch(const std::exception& ex) 

BODY (preview):
		catch (const std::exception& ex) {
			ERROR_LOG(std::format("Exception during instruction execution: {}", ex.what()));
			return;
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 520
SIGNATURE:
 if(newIPL < oldIPL) 

BODY (preview):
		if (newIPL < oldIPL) {
			// IPL was lowered - interrupts may now be unmasked

			// 1. Check hardware interrupts at all levels between old and new IPL
			global_IRQController().checkPendingInterrupts(m_cpuId);

			// 2. Check ASTs if we dropped to IPL 2 or below
			if (newIPL <= 2 && oldIPL > 2) {
				checkPendingAST(m_cpuId,isInPalMode());
			}
			// 3. Optional: Log for debugging
			TRACE_LOG(QString( "IPL lowered from %1 to %2 - Checking pending interrupts").arg(oldIPL).arg(newIPL));
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 527
SIGNATURE:
	 if(newIPL <= 2 && oldIPL > 2) 

BODY (preview):
			if (newIPL <= 2 && oldIPL > 2) {
				checkPendingAST(m_cpuId,isInPalMode());
			}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 560
SIGNATURE:
	void setCurrentIPL(quint8 newIPL) 

BODY (preview):
	void setCurrentIPL(quint8 newIPL) {
		if (newIPL > 7) {
			qWarning() << "Invalid IPL:" << newIPL << "(must be 0-7)";
			return;
		}

		quint8 oldIPL = getCurrentIPL();

		if (oldIPL == newIPL) {
			return;  // No change needed
		}

		// 1. Update PS register (read-modify-write)
		quint64 ps = getPS_Active(m_cpuId);
		ps = (ps & ~0x7ULL) | (newIPL & 0x7ULL);  // Clear bits 2:0, set new IPL

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 561
SIGNATURE:
 if(newIPL > 7) 

BODY (preview):
		if (newIPL > 7) {
			qWarning() << "Invalid IPL:" << newIPL << "(must be 0-7)";
			return;
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 568
SIGNATURE:
 if(oldIPL == newIPL) 

BODY (preview):
		if (oldIPL == newIPL) {
			return;  // No change needed
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 590
SIGNATURE:
	inline void setCPUFamily(CPUFamily fam) noexcept

BODY (preview):
	inline void setCPUFamily(CPUFamily fam)        noexcept { m_family = fam; }


================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 592
SIGNATURE:
	inline void start() noexcept

BODY (preview):
	inline void start() noexcept { m_running = true; }
	inline void stop()  noexcept { m_running = false; }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 593
SIGNATURE:
	inline void stop() noexcept

BODY (preview):
	inline void stop()  noexcept { m_running = false; }


================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 638
SIGNATURE:
	AXP_FLATTEN void setKernelStackPointer(quint64 sp) noexcept

BODY (preview):
	AXP_FLATTEN void setKernelStackPointer(quint64 sp) noexcept {
		setKSP_Active(m_cpuId, sp);
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 773
SIGNATURE:
	inline bool pal() noexcept

BODY (preview):
	inline bool pal()  noexcept { return globalIPRHot(m_cpuId).isInPalMode(); }


================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 782
SIGNATURE:
 if(m_iBox) 

BODY (preview):
		if (m_iBox) {
			m_iBox->flushAll();   // 
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 793
SIGNATURE:
	void handlePendingFault() 

BODY (preview):
	void handlePendingFault() {
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 799
SIGNATURE:
	inline void flushPendingTraps(bool bFlush) noexcept

BODY (preview):
	inline void flushPendingTraps(bool bFlush) noexcept {
	
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 853
SIGNATURE:
		 if(tag.vpn == 0) 

BODY (preview):
				if (tag.vpn == 0) {
					clearStagedDTBUpdate();
					return;
				}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaCPU.h
LINE: 884
SIGNATURE:
		 if(tag.vpn == 0) 

BODY (preview):
				if (tag.vpn == 0) {
					clearStagedITBUpdate();
					return;
				}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaPipeline.h
LINE: 83
SIGNATURE:
 for(auto& s : m_slots) 

BODY (preview):
		for (auto& s : m_slots) {
			s.clear();
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaPipeline.h
LINE: 124
SIGNATURE:
		void setRealm(Realm r) noexcept

BODY (preview):
		void setRealm(Realm r) noexcept {
		m_realm = static_cast<quint8>(r);
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaPipeline.h
LINE: 200
SIGNATURE:
 for(auto& s : m_slots) 

BODY (preview):
		for (auto& s : m_slots) {
			s.clear();
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaPipeline.h
LINE: 235
SIGNATURE:
 if(!m_pendingFetch.valid) 

BODY (preview):
		if (!m_pendingFetch.valid) {
			s.valid = false;
			return;
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaPipeline.h
LINE: 263
SIGNATURE:
 if(s.grain != nullptr) 

BODY (preview):
		if (s.grain != nullptr) {
			switch (executionBoxDecoder(s.di)) {
			case ExecutionBox::EBox:
			case ExecutionBox::IBox:
				s.execUnit = ExecUnit::EBOX;
				break;
			case ExecutionBox::MBox:
				s.execUnit = ExecUnit::MBOX;
				break;
			case ExecutionBox::FBox:
				s.execUnit = ExecUnit::FBOX;
				break;
			case ExecutionBox::CBox:
				s.execUnit = ExecUnit::PALBOX;
				break;

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaPipeline.h
LINE: 296
SIGNATURE:
 if(!s1.valid || s1.stalled) 

BODY (preview):
		if (!s1.valid || s1.stalled) {
			return ;
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaPipeline.h
LINE: 323
SIGNATURE:
 if(di1.rc != 31) 

BODY (preview):
		if (di1.rc != 31) {
			markRegisterDirty(di1);
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaPipeline.h
LINE: 331
SIGNATURE:
 if(!s2.valid) 

BODY (preview):
		if (!s2.valid) {
			return ;
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaPipeline.h
LINE: 360
SIGNATURE:
 if(di2.rc != 31) 

BODY (preview):
		if (di2.rc != 31) {
			markRegisterDirty(di2);
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaPipeline.h
LINE: 446
SIGNATURE:
 if(s.faultPending) 

BODY (preview):
		if (s.faultPending) {
			m_ctx->raiseTrap(s.trapCode, s.faultVA, extra);
			flush();
			return;
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaPipeline.h
LINE: 454
SIGNATURE:
 if(s.di.rc != 31) 

BODY (preview):
		if (s.di.rc != 31) {
			if (s.execUnit == ExecUnit::FBOX) {
				// Write to FRF
				m_ctx->writeFpReg(s.di.rc, s.resultFP);
				clearRegisterDirty(s.di);
			}
			else if (s.execUnit == ExecUnit::EBOX ||
				(s.execUnit == ExecUnit::MBOX && isLoad(s.di))) {
				// Write to IRF
				quint64 writeValue = isLoad(s.di) ? s.resultInt : s.resultInt;
				m_ctx->writeIntReg(s.di.rc, writeValue);
				clearRegisterDirty(s.di);
			}
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaPipeline.h
LINE: 455
SIGNATURE:
	 if(s.execUnit == ExecUnit::FBOX) 

BODY (preview):
			if (s.execUnit == ExecUnit::FBOX) {
				// Write to FRF
				m_ctx->writeFpReg(s.di.rc, s.resultFP);
				clearRegisterDirty(s.di);
			}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaPipeline.h
LINE: 509
SIGNATURE:
 if(isFloat) 

BODY (preview):
		if (isFloat) {
			m_fpRegisterDirty |= mask;
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaPipeline.h
LINE: 741
SIGNATURE:
 if(di1.rc == di2.ra || di1.rc == di2.rb) 

BODY (preview):
		if (di1.rc == di2.ra || di1.rc == di2.rb) {
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaPipeline.h
LINE: 746
SIGNATURE:
 if(di1.rc == di2.rc && di1.rc != 31) 

BODY (preview):
		if (di1.rc == di2.rc && di1.rc != 31) {
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\AlphaProcessorContext.h
LINE: 35
SIGNATURE:
 : m_cpuId(cpuId) 

BODY (preview):
    AlphaProcessorContext(CPUIdType cpuId) : m_cpuId(cpuId) {}
    virtual ~AlphaProcessorContext() = default;

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\barrier_hooks.h
LINE: 8
SIGNATURE:
void hostMB(CPUStateIPRInterface* cpu) noexcept

BODY (preview):
void hostMB(CPUStateIPRInterface* cpu) noexcept {
	std::atomic_thread_fence(std::memory_order_seq_cst);
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\barrier_hooks.h
LINE: 13
SIGNATURE:
void hostWMB(CPUStateIPRInterface* cpu) noexcept

BODY (preview):
void hostWMB(CPUStateIPRInterface* cpu) noexcept {
	std::atomic_thread_fence(std::memory_order_release);
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\barrier_hooks.h
LINE: 18
SIGNATURE:
void hostRMB(CPUStateIPRInterface* cpu) noexcept

BODY (preview):
void hostRMB(CPUStateIPRInterface* cpu) noexcept {
	std::atomic_thread_fence(std::memory_order_acquire);
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\barrier_hooks.h
LINE: 23
SIGNATURE:
void hostSCPublish(CPUStateIPRInterface* cpuState) noexcept

BODY (preview):
void hostSCPublish(CPUStateIPRInterface* cpuState) noexcept {
	// Typically involves atomic compare-and-swap semantics
	if (cpuState) {
		cpuState->markStoreConditionalComplete();
	}
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\barrier_hooks.h
LINE: 31
SIGNATURE:
void hostClearReservation(CPUStateIPRInterface* cpuState) noexcept

BODY (preview):
void hostClearReservation(CPUStateIPRInterface* cpuState) noexcept {
	quint8 cpuId = cpuState->cpuId();
	if (cpuState) {
		cpuState->clearReservationSet();
		globalReservationManager::instance().clearAll(cpuId);  // global invalidation
	}
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\barrier_hooks.h
LINE: 41
SIGNATURE:
	void hostMB(CPUStateIPRInterface* cpu) noexcept

BODY (preview):
	void hostMB(CPUStateIPRInterface* cpu) noexcept {
		std::atomic_thread_fence(std::memory_order_seq_cst);
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\barrier_hooks.h
LINE: 46
SIGNATURE:
	void hostWMB(CPUStateIPRInterface* cpu) noexcept

BODY (preview):
	void hostWMB(CPUStateIPRInterface* cpu) noexcept {
		std::atomic_thread_fence(std::memory_order_release);
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\barrier_hooks.h
LINE: 51
SIGNATURE:
	void hostRMB(CPUStateIPRInterface* cpu) noexcept

BODY (preview):
	void hostRMB(CPUStateIPRInterface* cpu) noexcept {
		std::atomic_thread_fence(std::memory_order_acquire);
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\barrier_hooks.h
LINE: 56
SIGNATURE:
	void hostSCPublish(CPUStateIPRInterface* cpu) noexcept

BODY (preview):
	void hostSCPublish(CPUStateIPRInterface* cpu) noexcept {
		// Typically involves atomic compare-and-swap semantics
		if (cpu) {
			cpu->markStoreConditionalComplete();
		}
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\barrier_hooks.h
LINE: 58
SIGNATURE:
 if(cpu) 

BODY (preview):
		if (cpu) {
			cpu->markStoreConditionalComplete();
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\barrier_hooks.h
LINE: 64
SIGNATURE:
	void hostClearReservation(CPUStateIPRInterface* cpu) noexcept

BODY (preview):
	void hostClearReservation(CPUStateIPRInterface* cpu) noexcept {
		if (cpu) {
			cpu->clearReservationSet();
		}
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\barrier_hooks.h
LINE: 65
SIGNATURE:
 if(cpu) 

BODY (preview):
		if (cpu) {
			cpu->clearReservationSet();
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\checkPendingInterrupt_inl.h
LINE: 51
SIGNATURE:
       if(irqLevel > currentIPL) 

BODY (preview):
        if (irqLevel > currentIPL) {
            PendingEvent ev{};
            ev.kind = PendingEventKind::HardwareIRQ;
            ev.exceptionClass = ExceptionClass::Interrupt;
            ev.palVectorId = PalVectorId::INTERRUPT;
            ev.hwIPL = irqLevel;
            ev.hwVector = irqCtrl.getIRQVector(cpuId, irqLevel);

            disp.setPendingEvent(ev);
            return true;
        }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\checkPendingInterrupt_inl.h
LINE: 68
SIGNATURE:
   if(swiPending != 0) 

BODY (preview):
    if (swiPending != 0) {
        quint8 swiLevel = highestSetBit(swiPending);

        PendingEvent ev{};
        ev.kind = PendingEventKind::SoftwareIRQ;
        ev.exceptionClass = ExceptionClass::SWI;
        ev.palVectorId = PalVectorId::SWI;
        ev.swiLevel = swiLevel;

        disp.setPendingEvent(ev);
        return true;
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\clearInterruptEligibilityDirty_inl.h
LINE: 6
SIGNATURE:
inline void clearInterruptEligibilityDirty(CPUIdType cpudId) 

BODY (preview):
inline void clearInterruptEligibilityDirty(CPUIdType cpudId){


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\Counter_core_inl.h
LINE: 5
SIGNATURE:
inline void setProcessorPerformanceCounterEnable(CPUStateIPRInterface* cpuState, quint8 value) noexcept

BODY (preview):
inline void setProcessorPerformanceCounterEnable(CPUStateIPRInterface* cpuState, quint8 value) noexcept{

	quint8 cpuId = cpuState->cpuId();
	auto& iprs = globalIPRBank()[cpuId];
	//iprs.ppce = value; // we need to set the enable switch?
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Descriptors.h
LINE: 194
SIGNATURE:
    inline quint16 extractSelector(quint32 instructionWord) 

BODY (preview):
    inline quint16 extractSelector(quint32 instructionWord) {
        return static_cast<quint8>((instructionWord >> 13) & 0xFF);
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Descriptors.h
LINE: 199
SIGNATURE:
    inline EV6Encoding::Box inferBox(quint8 sel) 

BODY (preview):
    inline EV6Encoding::Box inferBox(quint8 sel) {
        if (sel >= 0xC0 && sel <= 0xCF) return EV6Encoding::Box::EBOX;
        if (sel >= 0xA0 && sel <= 0xAF) return EV6Encoding::Box::MBOX1;
        if (sel >= 0x20 && sel <= 0x2F) return EV6Encoding::Box::MBOX0; // overlaps CBOX in some docs
        if (sel <= 0x1F)                return EV6Encoding::Box::IBOX;
        return EV6Encoding::Box::IBOX; // default (safe)
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Descriptors.h
LINE: 208
SIGNATURE:
    inline EV6Encoding::Pipe inferPipe(quint8 sel) 

BODY (preview):
    inline EV6Encoding::Pipe inferPipe(quint8 sel) {
        return (sel & 0x80) ? EV6Encoding::Pipe::L1 : EV6Encoding::Pipe::L0;
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Descriptors.h
LINE: 213
SIGNATURE:
    inline const char* boxName(EV6Encoding::Box b) 

BODY (preview):
    inline const char* boxName(EV6Encoding::Box b) {
        switch (b) {
        case EV6Encoding::Box::IBOX:  return "IBOX";
        case EV6Encoding::Box::MBOX0: return "MBOX0";
        case EV6Encoding::Box::MBOX1: return "MBOX1";
        case EV6Encoding::Box::EBOX:  return "EBOX";
        case EV6Encoding::Box::CBOX:  return "CBOX";
        default: return "UNKNOWN";
        }
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Descriptors.h
LINE: 214
SIGNATURE:
       switch(b) 

BODY (preview):
        switch (b) {
        case EV6Encoding::Box::IBOX:  return "IBOX";
        case EV6Encoding::Box::MBOX0: return "MBOX0";
        case EV6Encoding::Box::MBOX1: return "MBOX1";
        case EV6Encoding::Box::EBOX:  return "EBOX";
        case EV6Encoding::Box::CBOX:  return "CBOX";
        default: return "UNKNOWN";
        }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Descriptors.h
LINE: 223
SIGNATURE:
    inline const char* pipeName(EV6Encoding::Pipe p) 

BODY (preview):
    inline const char* pipeName(EV6Encoding::Pipe p) { return (p == EV6Encoding::Pipe::L0) ? "0L" : "1L"; }


================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Descriptors.h
LINE: 229
SIGNATURE:
    inline bool alwaysAllowed(const CPUStateIPRInterface* cpu) 

BODY (preview):
    inline bool alwaysAllowed(const CPUStateIPRInterface* cpu) {
        Q_UNUSED(cpu);
        return true;
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Descriptors.h
LINE: 233
SIGNATURE:
    inline bool palModeRequired(const CPUStateIPRInterface* cpuState) 

BODY (preview):
    inline bool palModeRequired(const CPUStateIPRInterface* cpuState)  {
		IPRBank& ipr = globalIPRBank();
        return cpuState && cpuState->isInPalMode();
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Descriptors.h
LINE: 1897
SIGNATURE:
	static inline const IPRDescriptor* getEV6PalTempBySlot(quint16 iprIndex) 

BODY (preview):
	static inline const IPRDescriptor* getEV6PalTempBySlot(quint16 iprIndex) {
		// iprIndex is 0x140..0x157
		if (iprIndex < 0x140 || iprIndex > 0x157)
			return nullptr;
		return ev6PalTempMap[iprIndex - 0x140];
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 79
SIGNATURE:
 	void invalidateDTB0All() 

BODY (preview):
// 	void invalidateDTB0All() {
// 		// Base class m_dtb is DTB0
// 		for (auto& entry : m_dtb) {
// 			entry.invalidate();
// 		}
// 		m_stats.invalidateAllCount++;
// 	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 81
SIGNATURE:
  for(auto& entry : m_dtb) 

BODY (preview):
// 		for (auto& entry : m_dtb) {
// 			entry.invalidate();
// 		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 88
SIGNATURE:
 	void invalidateDTB0Process(quint8 asn) 

BODY (preview):
// 	void invalidateDTB0Process(quint8 asn) {
// 		for (auto& entry : m_dtb) {
// 			if (entry.valid && entry.asn == asn && entry.asm_field == 0) {
// 				entry.invalidate();
// 			}
// 		}
// 		m_stats.invalidateProcessCount++;
// 	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 89
SIGNATURE:
  for(auto& entry : m_dtb) 

BODY (preview):
// 		for (auto& entry : m_dtb) {
// 			if (entry.valid && entry.asn == asn && entry.asm_field == 0) {
// 				entry.invalidate();
// 			}
// 		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 90
SIGNATURE:
 	 if(entry.valid && entry.asn == asn && entry.asm_field == 0) 

BODY (preview):
// 			if (entry.valid && entry.asn == asn && entry.asm_field == 0) {
// 				entry.invalidate();
// 			}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 98
SIGNATURE:
 	void invalidateDTB0Single(quint64 va, quint8 currentASN) 

BODY (preview):
// 	void invalidateDTB0Single(quint64 va, quint8 currentASN) {
// 		quint64 vpn = va >> 13;
// 
// 		for (auto& entry : m_dtb) {
// 			if (entry.valid && entry.vpn == vpn) {
// 				if (entry.asm_field == 1 || entry.asn == currentASN) {
// 					entry.invalidate();
// 					m_stats.invalidateSingleCount++;
// 					return;
// 				}
// 			}
// 		}
// 	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 101
SIGNATURE:
  for(auto& entry : m_dtb) 

BODY (preview):
// 		for (auto& entry : m_dtb) {
// 			if (entry.valid && entry.vpn == vpn) {
// 				if (entry.asm_field == 1 || entry.asn == currentASN) {
// 					entry.invalidate();
// 					m_stats.invalidateSingleCount++;
// 					return;
// 				}
// 			}
// 		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 102
SIGNATURE:
 	 if(entry.valid && entry.vpn == vpn) 

BODY (preview):
// 			if (entry.valid && entry.vpn == vpn) {
// 				if (entry.asm_field == 1 || entry.asn == currentASN) {
// 					entry.invalidate();
// 					m_stats.invalidateSingleCount++;
// 					return;
// 				}
// 			}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 103
SIGNATURE:
 		 if(entry.asm_field == 1 || entry.asn == currentASN) 

BODY (preview):
// 				if (entry.asm_field == 1 || entry.asn == currentASN) {
// 					entry.invalidate();
// 					m_stats.invalidateSingleCount++;
// 					return;
// 				}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 117
SIGNATURE:
 	void invalidateDTB1All() 

BODY (preview):
// 	void invalidateDTB1All() {
// 		for (auto& entry : m_dtb1) {
// 			entry.invalidate();
// 		}
// 		m_statsDTB1.invalidateAllCount++;
// 	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 118
SIGNATURE:
  for(auto& entry : m_dtb1) 

BODY (preview):
// 		for (auto& entry : m_dtb1) {
// 			entry.invalidate();
// 		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 125
SIGNATURE:
 	void invalidateDTB1Process(quint8 asn) 

BODY (preview):
// 	void invalidateDTB1Process(quint8 asn) {
// 		for (auto& entry : m_dtb1) {
// 			if (entry.valid && entry.asn == asn && entry.asm_field == 0) {
// 				entry.invalidate();
// 			}
// 		}
// 		m_statsDTB1.invalidateProcessCount++;
// 	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 126
SIGNATURE:
  for(auto& entry : m_dtb1) 

BODY (preview):
// 		for (auto& entry : m_dtb1) {
// 			if (entry.valid && entry.asn == asn && entry.asm_field == 0) {
// 				entry.invalidate();
// 			}
// 		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 127
SIGNATURE:
 	 if(entry.valid && entry.asn == asn && entry.asm_field == 0) 

BODY (preview):
// 			if (entry.valid && entry.asn == asn && entry.asm_field == 0) {
// 				entry.invalidate();
// 			}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 135
SIGNATURE:
 	void invalidateDTB1Single(quint64 va, quint8 currentASN) 

BODY (preview):
// 	void invalidateDTB1Single(quint64 va, quint8 currentASN) {
// 		quint64 vpn = va >> 13;
// 
// 		for (auto& entry : m_dtb1) {
// 			if (entry.valid && entry.vpn == vpn) {
// 				if (entry.asm_field == 1 || entry.asn == currentASN) {
// 					entry.invalidate();
// 					m_statsDTB1.invalidateSingleCount++;
// 					return;
// 				}
// 			}
// 		}
// 	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 138
SIGNATURE:
  for(auto& entry : m_dtb1) 

BODY (preview):
// 		for (auto& entry : m_dtb1) {
// 			if (entry.valid && entry.vpn == vpn) {
// 				if (entry.asm_field == 1 || entry.asn == currentASN) {
// 					entry.invalidate();
// 					m_statsDTB1.invalidateSingleCount++;
// 					return;
// 				}
// 			}
// 		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 139
SIGNATURE:
 	 if(entry.valid && entry.vpn == vpn) 

BODY (preview):
// 			if (entry.valid && entry.vpn == vpn) {
// 				if (entry.asm_field == 1 || entry.asn == currentASN) {
// 					entry.invalidate();
// 					m_statsDTB1.invalidateSingleCount++;
// 					return;
// 				}
// 			}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 140
SIGNATURE:
 		 if(entry.asm_field == 1 || entry.asn == currentASN) 

BODY (preview):
// 				if (entry.asm_field == 1 || entry.asn == currentASN) {
// 					entry.invalidate();
// 					m_statsDTB1.invalidateSingleCount++;
// 					return;
// 				}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 177
SIGNATURE:
 	TLBEntry* lookupDTBDual(quint64 va, quint8 currentASN) 

BODY (preview):
// 	TLBEntry* lookupDTBDual(quint64 va, quint8 currentASN) {
// 		// Try DTB0 first (primary array)
// 		TLBEntry* entry0 = lookupDTB(va, currentASN);
// 		if (entry0) {
// 			m_statsDTB0Hits++;
// 			return entry0;
// 		}
// 
// 		// Try DTB1 (secondary array)
// 		for (auto& entry : m_dtb1) {
// 			if (entry.matches(va, currentASN)) {
// 				entry.lastUsed = m_cycleCounter++;
// 				m_statsDTB1Hits++;
// 				return &entry;
// 			}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 180
SIGNATURE:
  if(entry0) 

BODY (preview):
// 		if (entry0) {
// 			m_statsDTB0Hits++;
// 			return entry0;
// 		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 186
SIGNATURE:
  for(auto& entry : m_dtb1) 

BODY (preview):
// 		for (auto& entry : m_dtb1) {
// 			if (entry.matches(va, currentASN)) {
// 				entry.lastUsed = m_cycleCounter++;
// 				m_statsDTB1Hits++;
// 				return &entry;
// 			}
// 		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 250
SIGNATURE:
  DualDTBStatistics() 

BODY (preview):
// 		DualDTBStatistics() {
// 			itbHits = itbMisses = 0;
// 			dtb0Hits = dtb0Misses = dtb0Fills = 0;
// 			dtb1Hits = dtb1Misses = dtb1Fills = 0;
// 			dtbHitsCombined = dtbMissesCombined = 0;
// 			invalidateAllCount = invalidateProcessCount = invalidateSingleCount = 0;
// 		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 289
SIGNATURE:
 	void resetDualStatistics() 

BODY (preview):
// 	void resetDualStatistics() {
// 		resetStatistics();  // Base class stats
// 		m_statsDTB1 = TLBManager::Statistics();
// 		m_statsDTB0Hits = m_statsDTB1Hits = m_statsDTBMisses = 0;
// 		m_statsDTB1Fills = 0;
// 	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 312
SIGNATURE:
  for(const auto& entry : m_dtb1) 

BODY (preview):
// 		for (const auto& entry : m_dtb1) {
// 			if (entry.valid) count++;
// 		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 338
SIGNATURE:
 	TLBEntry* findLRUEntry(std::vector<TLBEntry>& tlb) 

BODY (preview):
// 	TLBEntry* findLRUEntry(std::vector<TLBEntry>& tlb) {
// 		TLBEntry* lru = &tlb[0];
// 		quint64 oldestTime = lru->lastUsed;
// 
// 		for (auto& entry : tlb) {
// 			if (!entry.valid) {
// 				return &entry;  // Use invalid entry first
// 			}
// 			if (entry.lastUsed < oldestTime) {
// 				lru = &entry;
// 				oldestTime = entry.lastUsed;
// 			}
// 		}
// 
// 		return lru;

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 342
SIGNATURE:
  for(auto& entry : tlb) 

BODY (preview):
// 		for (auto& entry : tlb) {
// 			if (!entry.valid) {
// 				return &entry;  // Use invalid entry first
// 			}
// 			if (entry.lastUsed < oldestTime) {
// 				lru = &entry;
// 				oldestTime = entry.lastUsed;
// 			}
// 		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 343
SIGNATURE:
 	 if(!entry.valid) 

BODY (preview):
// 			if (!entry.valid) {
// 				return &entry;  // Use invalid entry first
// 			}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 346
SIGNATURE:
 	 if(entry.lastUsed < oldestTime) 

BODY (preview):
// 			if (entry.lastUsed < oldestTime) {
// 				lru = &entry;
// 				oldestTime = entry.lastUsed;
// 			}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 366
SIGNATURE:
 	inline void onDTB0_FLUSHWrite(CPUStateIPRInterface* cpu, quint64 oldValue, quint64 newValue) 

BODY (preview):
// 	inline void onDTB0_FLUSHWrite(CPUStateIPRInterface* cpu, quint64 oldValue, quint64 newValue) {
// 		(void)oldValue;
// 		(void)newValue;
// 		(void)cpu;
// 
// 		printf("[CPU] DTB0: Flushing all entries\n");
// 	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 375
SIGNATURE:
 	inline void onDTB1_FLUSHWrite(CPUStateIPRInterface* cpu, quint64 oldValue, quint64 newValue) 

BODY (preview):
// 	inline void onDTB1_FLUSHWrite(CPUStateIPRInterface* cpu, quint64 oldValue, quint64 newValue) {
// 		(void)oldValue;
// 		(void)newValue;
// 		(void)cpu;
// 
// 		printf("[CPU] DTB1: Flushing all entries\n");
// 	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 384
SIGNATURE:
 	inline void onDTB0_ASN_FLUSHWrite(CPUStateIPRInterface* cpu, quint64 oldValue, quint64 newValue) 

BODY (preview):
// 	inline void onDTB0_ASN_FLUSHWrite(CPUStateIPRInterface* cpu, quint64 oldValue, quint64 newValue) {
// 		(void)oldValue;
// 
// 		quint8 asn = newValue & 0xFF;
// 		(void)cpu;
// 		(void)asn;
// 
// 		printf("[CPU] DTB0: Flushing entries for ASN=%u\n", asn);
// 	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_DualDTB.h
LINE: 395
SIGNATURE:
 	inline void onDTB1_ASN_FLUSHWrite(CPUStateIPRInterface* cpu, quint64 oldValue, quint64 newValue) 

BODY (preview):
// 	inline void onDTB1_ASN_FLUSHWrite(CPUStateIPRInterface* cpu, quint64 oldValue, quint64 newValue) {
// 		(void)oldValue;
// 
// 		quint8 asn = newValue & 0xFF;
// 		(void)cpu;
// 		(void)asn;
// 
// 		printf("[CPU] DTB1: Flushing entries for ASN=%u\n", asn);
// 	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Encoding.h
LINE: 109
SIGNATURE:
	static inline Box inferBox(quint8 index16) 

BODY (preview):
	static inline Box inferBox(quint8 index16) {
		if (index16 >= 0xC0 && index16 <= 0xCF) return Box::EBOX;
		if (index16 >= 0xA0 && index16 <= 0xAF) return Box::MBOX1;
		if (index16 >= 0x20 && index16 <= 0x2F) return Box::MBOX0; // or CBOX
		if (index16 >= 0x00 && index16 <= 0x1F) return Box::IBOX;
		return Box::IBOX; // Default
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Encoding.h
LINE: 118
SIGNATURE:
	static inline Pipe inferPipe(quint8 index16) 

BODY (preview):
	static inline Pipe inferPipe(quint8 index16) {
		return (index16 & 0x80) ? Pipe::L1 : Pipe::L0;
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Hooks.h
LINE: 86
SIGNATURE:
void onPCTX_ASTERWrite(AlphaCPU* argCpu, quint64 oldValue, quint64 newValue) 

BODY (preview):
void onPCTX_ASTERWrite(AlphaCPU* argCpu, quint64 oldValue, quint64 newValue) {
	(void)oldValue;

	CPUIdType cpuId = argCpu->cpuId();

	// Write ASTER part of PCTX
	quint8 aster = newValue & 0xF;
	setASTER_Active(cpuId,aster);
	checkPendingAST(cpuId, argCpu->isInPalMode());

	TRACE_LOG(QString("EV6_PCTX_ASTER : oldValue %1, newValue %2").arg(oldValue).arg(newValue));

}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Hooks.h
LINE: 130
SIGNATURE:
void onPCTX_FPEWrite(AlphaCPU* argCpu, quint64 oldValue, quint64 newValue) 

BODY (preview):
void onPCTX_FPEWrite(AlphaCPU* argCpu, quint64 oldValue, quint64 newValue) {
	(void)oldValue;

	quint8 cpuId = argCpu->cpuId();
	// Write FPE part of PCTX
	bool fpe = newValue & 0x1;
	setFPE_Active(cpuId, fpe);

	if (!fpe) {
		// Disabling FP may require flushing FP pipeline
		flushFPPipeline(); // pipeline_inl_headers.h
	}
	TRACE_LOG(QString("EV6_PCTX_FPE : oldValue %1, newValue %2").arg(oldValue).arg(newValue));
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Hooks.h
LINE: 207
SIGNATURE:
bool onVARead(CPUIdType cpuId, quint64* outValue) 

BODY (preview):
bool onVARead(CPUIdType cpuId, quint64* outValue) {
	auto& iprs = globalIPRBank()[cpuId];
	*outValue = iprs.hot.va;	// TODO - does VA require additional processing?  I have an EBOX implementation that processes an EBOX to ensure it is well formed.
	return true;
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Hooks.h
LINE: 386
SIGNATURE:
 if(!newFPE) 

BODY (preview):
		if (!newFPE) {
			// FP disabled: next FP instruction will trap to PALcode FEN handler
			TRACE_LOG(std::format("CPU{} FP disabled - will trap on FP ops", cpuId));
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Hooks.h
LINE: 601
SIGNATURE:
  if(itb1) 

BODY (preview):
// 		if (itb1) {
// 			cpuState->incrementTLBInvalidationCounter(TLBType::ITB1, InvalidationType::ALL);
// 		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Hooks.h
LINE: 615
SIGNATURE:
  if(itb1) 

BODY (preview):
// 		if (itb1) {
// 			cpuState->incrementTLBInvalidationCounter(TLBType::ITB1, InvalidationType::PROCESS);
// 		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Hooks.h
LINE: 774
SIGNATURE:
 if(dtb0 || dtb1) 

BODY (preview):
		if (dtb0 || dtb1) {
			spam.tlbTBIAP_AllShards(currentASN);
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Hooks.h
LINE: 780
SIGNATURE:
 if(dtb0 || dtb1) 

BODY (preview):
		if (dtb0 || dtb1) {
			spam.tlbTBIAP_AllShards(targetASN);
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Hooks.h
LINE: 787
SIGNATURE:
 if(targetASN == 0xFFu) 

BODY (preview):
// 	if (targetASN == 0xFFu) {
// 		if (dtb0) {
// 			incrementTLBInvalidationCounter(cpuState, TLBType::DTB0, InvalidationType::ALL);
// 		}
// 		if (dtb1) {
// 			incrementTLBInvalidationCounter(cpuState, TLBType::DTB1, InvalidationType::ALL);
// 		}
// 	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Hooks.h
LINE: 788
SIGNATURE:
  if(dtb0) 

BODY (preview):
// 		if (dtb0) {
// 			incrementTLBInvalidationCounter(cpuState, TLBType::DTB0, InvalidationType::ALL);
// 		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Hooks.h
LINE: 791
SIGNATURE:
  if(dtb1) 

BODY (preview):
// 		if (dtb1) {
// 			incrementTLBInvalidationCounter(cpuState, TLBType::DTB1, InvalidationType::ALL);
// 		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Hooks.h
LINE: 796
SIGNATURE:
  if(dtb0) 

BODY (preview):
// 		if (dtb0) {
// 			incrementTLBInvalidationCounter(cpuState, TLBType::DTB0, InvalidationType::PROCESS);
// 		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Hooks.h
LINE: 799
SIGNATURE:
  if(dtb1) 

BODY (preview):
// 		if (dtb1) {
// 			incrementTLBInvalidationCounter(cpuState, TLBType::DTB1, InvalidationType::PROCESS);
// 		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Hooks.h
LINE: 1027
SIGNATURE:
 if(oldCM != newCM) 

BODY (preview):
// 	if (oldCM != newCM) {
// 		cpuState->onModeChange(oldCM, newCM);
// 
// 		// EV6: Advanced shadow register management
// 		cpuState->manageShadowBanks(newCM);
// 
// 		// Mode change may affect speculation
// 		cpuState->flushSpeculativeState();
// 	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Hooks.h
LINE: 1056
SIGNATURE:
 if(pendingIPL != 0) 

BODY (preview):
		if (pendingIPL != 0) {
			irqController.deliverInterrupt(cpuId, pendingIPL);
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Hooks.h
LINE: 1336
SIGNATURE:
void onHW_INT_CLRWrite(AlphaCPU &cpuState, quint64 oldValue, quint64 newValue) 

BODY (preview):
void onHW_INT_CLRWrite(AlphaCPU &cpuState, quint64 oldValue, quint64 newValue) {
	(void)oldValue;
	quint8 cpuId = cpuState.cpuId();
	// EV6: Clear hardware interrupts
	// Enhanced with priority levels
	auto& irq = global_IRQController();
	irq.clearHardwareInterrupts(newValue); // TODO

	// EV6: May need to recalculate interrupt priorities
	irq.recalculateInterruptPriorities(cpuId, newValue);

	TRACE_LOG(QString("EV6_HW_INT_CLR:: oldvalue: %1 - newvalue: %2").arg(oldValue).arg(newValue));
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\EV6_Hooks.h
LINE: 1813
SIGNATURE:
void onASNWrite(AlphaCPU* cpuState, quint64 oldValue, quint64 newValue) 

BODY (preview):
void onASNWrite(AlphaCPU* cpuState, quint64 oldValue, quint64 newValue) {
	(void)oldValue;

	quint8 cpuId = cpuState->cpuId();

	// EV6: ASN part of PCTX pattern
	// Bits [7:0] = ASN
	// Bits [39:32] = ASID for DTB0
	// Bits [47:40] = ASID for DTB1

	quint8 asn = getASN_Active(cpuId) & 0xFF;
	quint8 asid0 = (newValue >> 32) & 0xFF;
	quint8 asid1 = (newValue >> 40) & 0xFF;

	setASN_Active(cpuId, asn); // cpuState->setAddressSpaceNumber(asn);

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 37
SIGNATURE:
 noexcept : m_value(value) 

BODY (preview):
    explicit FpcrRegister(u64 value = 0) noexcept : m_value(value) {}


================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 40
SIGNATURE:
    inline void reset() noexcept

BODY (preview):
    inline void reset() noexcept {
        m_value = 0;  // Round-to-nearest, all traps disabled
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 46
SIGNATURE:
    inline void setRaw(u64 v) noexcept

BODY (preview):
    inline void setRaw(u64 v) noexcept { m_value = v; }


================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 62
SIGNATURE:
    inline void setRoundingMode(RoundingMode rm) noexcept

BODY (preview):
    inline void setRoundingMode(RoundingMode rm) noexcept {
        m_value &= ~(0x3ull << 58);
        m_value |= (static_cast<u64>(rm) & 0x3ull) << 58;
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 84
SIGNATURE:
    inline void setFlag(FpFlag f, bool v = true) noexcept

BODY (preview):
    inline void setFlag(FpFlag f, bool v = true) noexcept {
        const u64 mask = 1ull << (FlagBaseBit + static_cast<u64>(f));
        if (v) m_value |= mask;
        else   m_value &= ~mask;
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 90
SIGNATURE:
    inline void clearFlag(FpFlag f) noexcept

BODY (preview):
    inline void clearFlag(FpFlag f) noexcept {
        setFlag(f, false);
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 94
SIGNATURE:
    inline void raise(FpFlag f) noexcept

BODY (preview):
    inline void raise(FpFlag f) noexcept {
        setFlag(f, true);
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 107
SIGNATURE:
    inline void setSoftwareDetectEnabled(bool v) noexcept

BODY (preview):
    inline void setSoftwareDetectEnabled(bool v) noexcept {
        if (v) m_value |= (1ull << SDE_Bit);
        else   m_value &= ~(1ull << SDE_Bit);
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 146
SIGNATURE:
    inline void clearAllFaults() noexcept

BODY (preview):
    inline void clearAllFaults() noexcept {
        m_value &= ~(0x1FULL << FlagBaseBit);  // Clear bits 49-53
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 167
SIGNATURE:
    inline FpcrRegister get(CPUIdType cpuId) noexcept

BODY (preview):
    inline FpcrRegister get(CPUIdType cpuId) noexcept {
        return FpcrRegister(globalIPRHot(cpuId).fpcr);
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 176
SIGNATURE:
    inline void set(CPUIdType cpuId, const FpcrRegister& fpcr) noexcept

BODY (preview):
    inline void set(CPUIdType cpuId, const FpcrRegister& fpcr) noexcept {
        globalIPRHot(cpuId).fpcr = fpcr.raw();
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 185
SIGNATURE:
    inline quint64 getRaw(CPUIdType cpuId) noexcept

BODY (preview):
    inline quint64 getRaw(CPUIdType cpuId) noexcept {
        return globalIPRHot(cpuId).fpcr;
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 194
SIGNATURE:
    inline void setRaw(CPUIdType cpuId, quint64 value) noexcept

BODY (preview):
    inline void setRaw(CPUIdType cpuId, quint64 value) noexcept {
        globalIPRHot(cpuId).fpcr = value;
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 208
SIGNATURE:
    inline void modify(CPUIdType cpuId, F&& modifier) noexcept

BODY (preview):
    inline void modify(CPUIdType cpuId, F&& modifier) noexcept {
        FpcrRegister fpcr(globalIPRHot(cpuId).fpcr);
        modifier(fpcr);
        globalIPRHot(cpuId).fpcr = fpcr.raw();
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 219
SIGNATURE:
    inline quint64 getExceptionSummary(CPUIdType cpuId) noexcept

BODY (preview):
    inline quint64 getExceptionSummary(CPUIdType cpuId) noexcept {
        return (globalIPRHot(cpuId).fpcr >> 49) & 0x1FULL;
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 228
SIGNATURE:
    inline bool anyException(CPUIdType cpuId) noexcept

BODY (preview):
    inline bool anyException(CPUIdType cpuId) noexcept {
        return (globalIPRHot(cpuId).fpcr >> 49) & 0x1FULL;
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 237
SIGNATURE:
    inline bool shouldTrap(CPUIdType cpuId) noexcept

BODY (preview):
    inline bool shouldTrap(CPUIdType cpuId) noexcept {
        quint64 fpcr = globalIPRHot(cpuId).fpcr;
        bool hasException = (fpcr >> 49) & 0x1FULL;
        bool sdeEnabled = (fpcr >> 48) & 1ULL;
        return hasException && sdeEnabled;
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 251
SIGNATURE:
inline quint64 executeMF_FPCR(CPUIdType cpuId) noexcept

BODY (preview):
inline quint64 executeMF_FPCR(CPUIdType cpuId) noexcept {
    return FPCR::getRaw(cpuId);
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 256
SIGNATURE:
inline void executeMT_FPCR(CPUIdType cpuId, quint64 value) noexcept

BODY (preview):
inline void executeMT_FPCR(CPUIdType cpuId, quint64 value) noexcept {
    FPCR::setRaw(cpuId, value);
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 261
SIGNATURE:
inline void raiseInvalidOperation(CPUIdType cpuId) noexcept

BODY (preview):
inline void raiseInvalidOperation(CPUIdType cpuId) noexcept {
    FPCR::modify(cpuId, [](FpcrRegister& fpcr) {
        fpcr.raise(FpcrRegister::FpFlag::InvalidOp);
        });
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 268
SIGNATURE:
inline bool checkFPTrap(CPUIdType cpuId) noexcept

BODY (preview):
inline bool checkFPTrap(CPUIdType cpuId) noexcept {
    return FPCR::shouldTrap(cpuId);
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 273
SIGNATURE:
inline void updateExcSumFromFPCR(CPUIdType cpuId) noexcept

BODY (preview):
inline void updateExcSumFromFPCR(CPUIdType cpuId) noexcept {
    auto& iprs = globalIPRHot(cpuId);
    quint64 fpSummary = FPCR::getExceptionSummary(cpuId);
    iprs.exc_sum |= fpSummary;  // Merge FP exceptions into EXC_SUM
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\FPCRRegister.h
LINE: 280
SIGNATURE:
inline void setRoundingModeAndClearFaults(CPUIdType cpuId, quint8 mode) noexcept

BODY (preview):
inline void setRoundingModeAndClearFaults(CPUIdType cpuId, quint8 mode) noexcept {
    FPCR::modify(cpuId, [mode](FpcrRegister& fpcr) {
        fpcr.setRoundingMode(static_cast<FpcrRegister::RoundingMode>(mode));
        fpcr.clearAllFaults();
        });
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\global_exceptionVectorTable.h
LINE: 10
SIGNATURE:
	void initEV6() 

BODY (preview):
	void initEV6() {}   // Load EV6 exception vectors
	void initEV5() {}   // Load EV5 exception vectors (optional)

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\global_exceptionVectorTable.h
LINE: 11
SIGNATURE:
	void initEV5() 

BODY (preview):
	void initEV5() {}   // Load EV5 exception vectors (optional)
	void initCustom() {} // For VMS, Linux/Tru64 special handlers

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\global_exceptionVectorTable.h
LINE: 12
SIGNATURE:
	void initCustom() 

BODY (preview):
	void initCustom() {} // For VMS, Linux/Tru64 special handlers


================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\global_ReservationManager.h
LINE: 4
SIGNATURE:
inline ReservationManager& global_ReservationManager() 

BODY (preview):
inline ReservationManager& global_ReservationManager() {
	return ReservationManager::gInstance();
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\IPRDescriptor.h
LINE: 107
SIGNATURE:
 constexpr IPRDescriptorBase(const char* name_, ...) 

BODY (preview):
		// constexpr IPRDescriptorBase(const char* name_, ...) { ... }
	};


	// ============================================================================
	// UNIFIED IPR DESCRIPTOR (Tagged Union)
	// ============================================================================

	struct IPRDescriptor {

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\IRQ_AST_core_inl.h
LINE: 11
SIGNATURE:
inline void onAstModeChanged(AlphaCPU* cpuState) 

BODY (preview):
inline void onAstModeChanged(AlphaCPU* cpuState) {
	// If AST delivery rules depend on privilege mode, evaluate here.
	cpuState->setInterruptEligibilityDirty(true);
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\IRQ_AST_core_inl.h
LINE: 55
SIGNATURE:
inline void evaluatePendingASTs(CPUStateIPRInterface* cpuState) 

BODY (preview):
inline void evaluatePendingASTs(CPUStateIPRInterface* cpuState) {
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\LDST_core_inl.h
LINE: 30
SIGNATURE:
 switch(memStat) 

BODY (preview):
		switch (memStat) {
		case SafeStatus::Un_Aligned:
			faultType = MemoryFaultType::ALIGNMENT_FAULT;
			break;
		case SafeStatus::AccessViolation:
			faultType = MemoryFaultType::LOAD_ACCESS;
			break;
		case SafeStatus::TlbMiss:
			faultType = MemoryFaultType::TLB_MISS;
			break;
		default:
			faultType = MemoryFaultType::LOAD_ACCESS;
			break;
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\LDST_core_inl.h
LINE: 66
SIGNATURE:
 switch(memStat) 

BODY (preview):
		switch (memStat) {
		case SafeStatus::Un_Aligned:
			faultType = MemoryFaultType::ALIGNMENT_FAULT;
			break;
		case SafeStatus::AccessViolation:
			faultType = MemoryFaultType::STORE_ACCESS;
			break;
		case SafeStatus::TlbMiss:
			faultType = MemoryFaultType::TLB_MISS;
			break;
		default:
			faultType = MemoryFaultType::STORE_ACCESS;
			break;
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\LDST_core_inl.h
LINE: 97
SIGNATURE:
 switch(memStat) 

BODY (preview):
		switch (memStat) {
		case SafeStatus::Un_Aligned:
			faultType = MemoryFaultType::ALIGNMENT_FAULT;
			break;
		case SafeStatus::AccessViolation:
			faultType = MemoryFaultType::LOAD_ACCESS;
			break;
		case SafeStatus::TlbMiss:
			faultType = MemoryFaultType::TLB_MISS;
			break;
		default:
			faultType = MemoryFaultType::LOAD_ACCESS;
			break;
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\LDST_core_inl.h
LINE: 128
SIGNATURE:
 switch(memStat) 

BODY (preview):
		switch (memStat) {
		case SafeStatus::Un_Aligned:
			faultType = MemoryFaultType::ALIGNMENT_FAULT;
			break;
		case SafeStatus::AccessViolation:
			faultType = MemoryFaultType::STORE_ACCESS;
			break;
		case SafeStatus::TlbMiss:
			faultType = MemoryFaultType::TLB_MISS;
			break;
		default:
			faultType = MemoryFaultType::STORE_ACCESS;
			break;
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\LDST_core_inl.h
LINE: 291
SIGNATURE:
 switch(memStat) 

BODY (preview):
		switch (memStat) {
		case SafeStatus::Un_Aligned:
			faultType = MemoryFaultType::ALIGNMENT_FAULT;
			break;
		case SafeStatus::AccessViolation:
			faultType = MemoryFaultType::STORE_ACCESS;
			break;
		case SafeStatus::TlbMiss:
			faultType = MemoryFaultType::TLB_MISS;
			break;
		default:
			faultType = MemoryFaultType::STORE_ACCESS;
			break;
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onASTENChanged_inl.h
LINE: 5
SIGNATURE:
inline void onASTENChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept

BODY (preview):
inline void onASTENChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept{


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onASTSRChanged_inl.h
LINE: 5
SIGNATURE:
inline void onASTSRChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept

BODY (preview):
inline void onASTSRChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept{


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onCMChanged_inl.h
LINE: 5
SIGNATURE:
inline void onCMChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept

BODY (preview):
inline void onCMChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept{


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onDTB_PTEChanged_inl.h
LINE: 6
SIGNATURE:
inline void onDTB_PTEChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept

BODY (preview):
inline void onDTB_PTEChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept{


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onDTB_TAGChanged.h
LINE: 5
SIGNATURE:
inline void onDTB_TAGChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept

BODY (preview):
inline void onDTB_TAGChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept{


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onESPChanged_inl.h
LINE: 5
SIGNATURE:
inline void onESPChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept

BODY (preview):
inline void onESPChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept{


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onITB_IAChanged_inl.h
LINE: 5
SIGNATURE:
inline void onITB_IAChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept

BODY (preview):
inline void onITB_IAChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept{


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onKSPChanged_inl.h
LINE: 6
SIGNATURE:
inline void onKSPChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept

BODY (preview):
inline void onKSPChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept{


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onMM_STATChanged_inl.h
LINE: 5
SIGNATURE:
inline void onMM_STATChanged(AlphaCPU *argCpu, quint64 oldValue, quint64 newValue) noexcept

BODY (preview):
inline void onMM_STATChanged(AlphaCPU *argCpu, quint64 oldValue, quint64 newValue) noexcept{


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onPALcodeBaseChange_inl.h
LINE: 42
SIGNATURE:
 if(oldOffset < 0x10000ULL) 

BODY (preview):
		if (oldOffset < 0x10000ULL) {
			// PC was in old PAL region - relocate to new base
			quint64 newPC = newBase + oldOffset;
			setPC_Active(cpuId, newPC);

			DEBUG_LOG(QString("Relocated PAL PC: 0x%1 -> 0x%2")
				.arg(currentPC, 16, 16, QChar('0'))
				.arg(newPC, 16, 16, QChar('0')));
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onPCRChanged_inl.h
LINE: 5
SIGNATURE:
inline void onPCRChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept

BODY (preview):
inline void onPCRChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept{


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onSIRRChanged_inl.h
LINE: 5
SIGNATURE:
inline void onSIRRChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept

BODY (preview):
inline void onSIRRChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept{


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onSSPChanged_inl.h
LINE: 5
SIGNATURE:
inline void onSSPChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept

BODY (preview):
inline void onSSPChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept{


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onTBIAP_inl.h
LINE: 6
SIGNATURE:
inline void onTBIAP(AlphaCPU *argCpu) noexcept

BODY (preview):
inline void onTBIAP(AlphaCPU *argCpu) noexcept{


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onTBIA_ALL_inl.h
LINE: 5
SIGNATURE:
inline void onTBIA_ALL(AlphaCPU *argCpu) noexcept

BODY (preview):
inline void onTBIA_ALL(AlphaCPU *argCpu) noexcept{


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onTBIA_inl.h
LINE: 5
SIGNATURE:
inline void onTBIA(AlphaCPU *argCpu) noexcept

BODY (preview):
inline void onTBIA(AlphaCPU *argCpu) noexcept{


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onTBISD_inl.h
LINE: 5
SIGNATURE:
inline void onTBISD(AlphaCPU *argCpu) noexcept

BODY (preview):
inline void onTBISD(AlphaCPU *argCpu) noexcept{


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onTBIS_inl.h
LINE: 5
SIGNATURE:
inline void onTBIS(AlphaCPU *argCpu) noexcept

BODY (preview):
inline void onTBIS(AlphaCPU *argCpu) noexcept{


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onUSPChanged.h
LINE: 5
SIGNATURE:
inline void onUSPChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept

BODY (preview):
inline void onUSPChanged(AlphaCPU *argCpu, quint8 oldValue, quint8 newValue) noexcept{


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onWrite_DTB_PTE_Common_inl.h
LINE: 33
SIGNATURE:
   if(!argCpu) 

BODY (preview):
    if (!argCpu) {
        return;
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onWrite_DTB_PTE_Common_inl.h
LINE: 56
SIGNATURE:
   if(bank1) 

BODY (preview):
    if (bank1) {
        iprs.dtb_pte1 = newValue;
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\onWrite_DTB_PTE_Common_inl.h
LINE: 69
SIGNATURE:
   if(bank1) 

BODY (preview):
    if (bank1) {
        argCpu->stageDTB1PTE(pte.raw);
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\PerformanceCounterEvents_inl.h
LINE: 40
SIGNATURE:
inline void incrementPerfCounter(AlphaCPU& argCpu, PerfEvent eventType) 

BODY (preview):
inline void incrementPerfCounter(AlphaCPU& argCpu, PerfEvent eventType) {


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\Pipeline_inl_headers.h
LINE: 6
SIGNATURE:
inline void flushFPPipeline() noexcept

BODY (preview):
inline void flushFPPipeline() noexcept{

}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\Prefetch_header_inl.h
LINE: 6
SIGNATURE:
inline void setPrefetchEnable(AlphaCPU & cpuState, bool bPrefetch=true) 

BODY (preview):
inline void setPrefetchEnable(AlphaCPU & cpuState, bool bPrefetch=true ) {

}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\Prefetch_header_inl.h
LINE: 10
SIGNATURE:
inline void setPrefetchDistance(AlphaCPU & cpuState, quint8 bPrefetchDist) 

BODY (preview):
inline void setPrefetchDistance(AlphaCPU & cpuState, quint8 bPrefetchDist ) {

}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\Prefetch_inl_helper.h
LINE: 5
SIGNATURE:
inline void setSpeculativeLoads(AlphaCPU& cpuState, bool bSpecLoads) 

BODY (preview):
inline void setSpeculativeLoads(AlphaCPU& cpuState, bool bSpecLoads) {

	throw std::logic_error("The method or operation is not implemented.");
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\Prefetch_inl_helper.h
LINE: 10
SIGNATURE:
inline void flushIPrefetchQueue_inl(AlphaCPU& cpuState) noexcept

BODY (preview):
inline void flushIPrefetchQueue_inl(AlphaCPU& cpuState) noexcept {

}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\Prefetch_inl_helper.h
LINE: 21
SIGNATURE:
inline void flushPrefetchLine(AlphaCPU& cpuState, quint64 va) noexcept

BODY (preview):
inline void flushPrefetchLine(AlphaCPU& cpuState, quint64 va) noexcept {

}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\Prefetch_inl_helper.h
LINE: 30
SIGNATURE:
inline void flushICache() 

BODY (preview):
inline void flushICache() {

}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\Prefetch_inl_helper.h
LINE: 34
SIGNATURE:
inline void flushICacheByASN(ASNType asn) 

BODY (preview):
inline void flushICacheByASN(ASNType asn) {

}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\Prefetch_inl_helper.h
LINE: 37
SIGNATURE:
inline void flushBranchPredictorByASN(ASNType asn) 

BODY (preview):
inline void flushBranchPredictorByASN(ASNType asn) {

}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\registerBank_coreFramework.h
LINE: 116
SIGNATURE:
	inline void setReturnAddress(quint64 v) noexcept

BODY (preview):
	inline void    setReturnAddress(quint64 v) noexcept { write(R26, v); }


================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\registerBank_coreFramework.h
LINE: 119
SIGNATURE:
	inline void setGlobalPointer(quint64 v) noexcept

BODY (preview):
	inline void    setGlobalPointer(quint64 v) noexcept { write(R29, v); }


================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 68
SIGNATURE:
	static ReservationManager& gInstance() 

BODY (preview):
	static ReservationManager& gInstance() {
		static ReservationManager rm;
		return rm;
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 79
SIGNATURE:
 : m_numCpus(MAX_CPUS) 

BODY (preview):
	ReservationManager() : m_numCpus(MAX_CPUS) {
		initialize();
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 83
SIGNATURE:
 : m_numCpus(numCpus) 

BODY (preview):
	ReservationManager(quint16 numCpus) : m_numCpus(numCpus) {
		initialize();
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 91
SIGNATURE:
	void initialize() 

BODY (preview):
	void initialize() {
		m_reservations.resize(m_numCpus);
		m_ts.reset(new QAtomicInteger<quint64>[m_numCpus]);

		for (quint16 i = 0; i < m_numCpus; ++i) {
			m_ts[i].storeRelease(0);
		}

		qDebug() << "ReservationManager: initialized for" << m_numCpus << "CPUs";
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 95
SIGNATURE:
 for(quint16 i = 0; i < m_numCpus; ++i) 

BODY (preview):
		for (quint16 i = 0; i < m_numCpus; ++i) {
			m_ts[i].storeRelease(0);
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 106
SIGNATURE:
	void setTimestamp(quint16 cpuId, quint64 v) noexcept

BODY (preview):
	void setTimestamp(quint16 cpuId, quint64 v) noexcept {
		if (cpuId < m_numCpus)
			m_ts[cpuId].storeRelease(v);
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 125
SIGNATURE:
	void setOnInvalidatedCallback(const OnReservationInvalidatedFn& fn) 

BODY (preview):
	void setOnInvalidatedCallback(const OnReservationInvalidatedFn& fn) {
		m_onInvalidated = fn;
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 146
SIGNATURE:
	bool reserve(quint16 cpuId, quint64 pa) 

BODY (preview):
	bool reserve(quint16 cpuId, quint64 pa) {
		if (cpuId >= m_numCpus) {
			qWarning() << "ReservationManager: reserve() invalid CPU" << cpuId;
			return false;
		}

		QWriteLocker locker(&m_lock);

		quint64 granule = alignToQuadword(pa);
		m_reservations[cpuId].pa = pa;           // Store original address
		m_reservations[cpuId].granule = granule; // Store aligned quadword
		m_reservations[cpuId].valid = true;
		m_ts[cpuId].storeRelease(QDateTime::currentMSecsSinceEpoch());

		DEBUG_LOG(QString("ReservationManager: CPU %1 reserved quadword %2 from PA 0x%3")

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 147
SIGNATURE:
 if(cpuId >= m_numCpus) 

BODY (preview):
		if (cpuId >= m_numCpus) {
			qWarning() << "ReservationManager: reserve() invalid CPU" << cpuId;
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 187
SIGNATURE:
	bool tryStoreConditional(quint16 cpuId, quint64 pa) 

BODY (preview):
	bool tryStoreConditional(quint16 cpuId, quint64 pa) {
		if (cpuId >= m_numCpus) {
			qWarning() << "ReservationManager: tryStoreConditional() invalid CPU" << cpuId;
			return false;
		}

		QWriteLocker locker(&m_lock);

		const Reservation& res = m_reservations[cpuId];
		quint64 granule = alignToQuadword(pa);

		// Check if reservation is still valid on this quadword
		if (!res.valid || res.granule != granule) {
			qDebug() << "ReservationManager: CPU" << cpuId
				<< "SC FAILED at" << Qt::hex << pa

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 188
SIGNATURE:
 if(cpuId >= m_numCpus) 

BODY (preview):
		if (cpuId >= m_numCpus) {
			qWarning() << "ReservationManager: tryStoreConditional() invalid CPU" << cpuId;
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 199
SIGNATURE:
 if(!res.valid || res.granule != granule) 

BODY (preview):
		if (!res.valid || res.granule != granule) {
			qDebug() << "ReservationManager: CPU" << cpuId
				<< "SC FAILED at" << Qt::hex << pa
				<< "(reservation:" << (res.valid ? "valid" : "invalid")
				<< "granule:" << res.granule << "vs" << granule << ")";
			return false;  // SC fails
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 231
SIGNATURE:
	void conflictWrite(quint64 pa) 

BODY (preview):
	void conflictWrite(quint64 pa) {
		QWriteLocker locker(&m_lock);

		quint64 granule = alignToQuadword(pa);

		for (quint16 cpuId = 0; cpuId < m_numCpus; ++cpuId) {
			Reservation& res = m_reservations[cpuId];

			if (res.valid && res.granule == granule) {
				res.valid = false;
				m_conflictCount.fetch_add(1, std::memory_order_relaxed);

				// Trigger callback
				if (m_onInvalidated) {
					m_onInvalidated(cpuId, pa);

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 236
SIGNATURE:
 for(quint16 cpuId = 0; cpuId < m_numCpus; ++cpuId) 

BODY (preview):
		for (quint16 cpuId = 0; cpuId < m_numCpus; ++cpuId) {
			Reservation& res = m_reservations[cpuId];

			if (res.valid && res.granule == granule) {
				res.valid = false;
				m_conflictCount.fetch_add(1, std::memory_order_relaxed);

				// Trigger callback
				if (m_onInvalidated) {
					m_onInvalidated(cpuId, pa);
				}

				qDebug() << "ReservationManager: CPU" << cpuId
					<< "reservation invalidated by write to" << Qt::hex << pa;
			}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 239
SIGNATURE:
	 if(res.valid && res.granule == granule) 

BODY (preview):
			if (res.valid && res.granule == granule) {
				res.valid = false;
				m_conflictCount.fetch_add(1, std::memory_order_relaxed);

				// Trigger callback
				if (m_onInvalidated) {
					m_onInvalidated(cpuId, pa);
				}

				qDebug() << "ReservationManager: CPU" << cpuId
					<< "reservation invalidated by write to" << Qt::hex << pa;
			}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 244
SIGNATURE:
		 if(m_onInvalidated) 

BODY (preview):
				if (m_onInvalidated) {
					m_onInvalidated(cpuId, pa);
				}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 259
SIGNATURE:
	void invalidateGranule(quint64 pa) 

BODY (preview):
	void invalidateGranule(quint64 pa) {
		conflictWrite(pa);  // Same implementation
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 275
SIGNATURE:
	void invalidateRange(quint64 pa, quint64 size) 

BODY (preview):
	void invalidateRange(quint64 pa, quint64 size) {
		if (size == 0) return;

		// Walk quadwords that overlap [pa, pa+size)
		quint64 startGranule = alignToQuadword(pa);
		quint64 endAddr = pa + size;
		quint64 endGranule = alignToQuadword(endAddr);

		// If end address is exactly on boundary, don't include extra quadword
		if ((endAddr & QUADWORD_MASK_BITS) == 0 && endAddr > 0) {
			endGranule -= QUADWORD_SIZE;
		}

		for (quint64 g = startGranule; g <= endGranule; g += QUADWORD_SIZE) {
			conflictWrite(g);

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 288
SIGNATURE:
 for(quint64 g = startGranule; g <= endGranule; g += QUADWORD_SIZE) 

BODY (preview):
		for (quint64 g = startGranule; g <= endGranule; g += QUADWORD_SIZE) {
			conflictWrite(g);
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 311
SIGNATURE:
	void clearReservation(quint16 cpuId) 

BODY (preview):
	void clearReservation(quint16 cpuId) {
		if (cpuId >= m_numCpus) {
			qWarning() << "ReservationManager: clearReservation() invalid CPU" << cpuId;
			return;
		}

		QWriteLocker locker(&m_lock);

		if (m_reservations[cpuId].valid) {
			quint64 granule = m_reservations[cpuId].granule;
			m_reservations[cpuId].valid = false;
			qDebug() << "ReservationManager: CPU" << cpuId
				<< "reservation cleared (was at" << Qt::hex << granule << ")";
		}
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 312
SIGNATURE:
 if(cpuId >= m_numCpus) 

BODY (preview):
		if (cpuId >= m_numCpus) {
			qWarning() << "ReservationManager: clearReservation() invalid CPU" << cpuId;
			return;
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 319
SIGNATURE:
 if(m_reservations[cpuId].valid) 

BODY (preview):
		if (m_reservations[cpuId].valid) {
			quint64 granule = m_reservations[cpuId].granule;
			m_reservations[cpuId].valid = false;
			qDebug() << "ReservationManager: CPU" << cpuId
				<< "reservation cleared (was at" << Qt::hex << granule << ")";
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 342
SIGNATURE:
	void clearAllReservationForCpu() 

BODY (preview):
	void clearAllReservationForCpu() {
		QWriteLocker locker(&m_lock);

		quint32 clearedCount = 0;
		for (auto& res : m_reservations) {
			if (res.valid) {
				res.valid = false;
				clearedCount++;
			}
		}

		qDebug() << "ReservationManager: cleared" << clearedCount
			<< "reservations across all CPUs";
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 346
SIGNATURE:
 for(auto& res : m_reservations) 

BODY (preview):
		for (auto& res : m_reservations) {
			if (res.valid) {
				res.valid = false;
				clearedCount++;
			}
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 347
SIGNATURE:
	 if(res.valid) 

BODY (preview):
			if (res.valid) {
				res.valid = false;
				clearedCount++;
			}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 361
SIGNATURE:
	inline bool setReservation(quint16 cpuId, quint64 pa) 

BODY (preview):
	inline bool setReservation(quint16 cpuId, quint64 pa) {
		return reserve(cpuId, pa);
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 369
SIGNATURE:
	inline void clearReservation(quint16 cpuId, quint64 pa) 

BODY (preview):
	inline void clearReservation(quint16 cpuId, quint64 pa) {
		Q_UNUSED(pa);
		clearReservation(cpuId);
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 374
SIGNATURE:
	inline void clearAllReservationForCpu(quint16 cpuId) 

BODY (preview):
	inline void clearAllReservationForCpu(quint16 cpuId) {
		clearReservation(cpuId);
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 445
SIGNATURE:
 for(const auto& res : m_reservations) 

BODY (preview):
		for (const auto& res : m_reservations) {
			if (res.valid) activeCount++;
		}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 484
SIGNATURE:
	static inline quint64 alignToQuadword(quint64 pa) noexcept

BODY (preview):
	static inline quint64 alignToQuadword(quint64 pa) noexcept {
		return pa & QUADWORD_MASK;
	}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 493
SIGNATURE:
inline bool resReserve(ReservationManager* resMgr, quint16 cpuId, quint64 pa) 

BODY (preview):
inline bool resReserve(ReservationManager* resMgr, quint16 cpuId, quint64 pa) {
	if (!resMgr) return true;
	return resMgr->reserve(cpuId, pa);
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 498
SIGNATURE:
inline bool resCheckSC(ReservationManager* resMgr, quint16 cpuId, quint64 pa) 

BODY (preview):
inline bool resCheckSC(ReservationManager* resMgr, quint16 cpuId, quint64 pa) {
	if (!resMgr) return true;
	return resMgr->tryStoreConditional(cpuId, pa);
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\ReservationManager.h
LINE: 503
SIGNATURE:
inline void resConflictWrite(ReservationManager* resMgr, quint64 pa) 

BODY (preview):
inline void resConflictWrite(ReservationManager* resMgr, quint64 pa) {
	if (resMgr) resMgr->conflictWrite(pa);
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\resetPALcodeState_inl.h
LINE: 7
SIGNATURE:
inline void resetPALcodeState(AlphaCPU* argCpu,  quint64 newValue) noexcept

BODY (preview):
inline void resetPALcodeState(AlphaCPU* argCpu,  quint64 newValue) noexcept {


}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\servicePendingEvent.h
LINE: 6
SIGNATURE:
inline void servicePendingEvent(CPUStateIPRInterface* cpuState) 

BODY (preview):
inline void servicePendingEvent(CPUStateIPRInterface* cpuState) {

}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\servicePendingEvent.h
LINE: 10
SIGNATURE:
inline void handleTranslationFault(CPUStateIPRInterface* cpuState) 

BODY (preview):
inline void handleTranslationFault(CPUStateIPRInterface* cpuState) {

}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\stageITBPTE_inl.h
LINE: 5
SIGNATURE:
inline void stageITBPTE(CPUStateIPRInterface* cpuState, quint64 newValue) noexcept

BODY (preview):
inline void stageITBPTE(CPUStateIPRInterface* cpuState, quint64 newValue) noexcept {

	cpuState->stageITBPTE(newValue);
}

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\translateResultToTrap_inl.h
LINE: 10
SIGNATURE:
   switch(r) 

BODY (preview):
    switch (r) {
    case TranslationResult::TlbMiss:
        return (k == AccessKind::EXECUTE)
                   ? TrapCode::ITB_MISS
                   : TrapCode::DTB_MISS;

    case TranslationResult::PermissionDenied:
        return (k == AccessKind::EXECUTE)
                   ? TrapCode::ITB_ACCESS_VIOLATION
                   : TrapCode::DTB_ACCESS_VIOLATION;

    case TranslationResult::NonCanonical:
    case TranslationResult::Misaligned:
        return TrapCode::DTB_FAULT; // EV6 rule


================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\translateResultToTrap_inl.h
LINE: 30
SIGNATURE:
inline TrapCode translateStatusToTrap(SafeMemory::Status st) noexcept

BODY (preview):
inline TrapCode translateStatusToTrap(SafeMemory::Status st) noexcept {
    switch (st) {
    case SafeMemory::Status::Ok:
        return TrapCode::NONE;

    case SafeMemory::Status::AccessViolation:
        return TrapCode::DTB_ACCESS_VIOLATION;

    case SafeMemory::Status::Misaligned:
        return TrapCode::DTB_FAULT;

    case SafeMemory::Status::BusError:
    default:
        return TrapCode::MACHINE_CHECK; // Machine check
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\translateResultToTrap_inl.h
LINE: 31
SIGNATURE:
   switch(st) 

BODY (preview):
    switch (st) {
    case SafeMemory::Status::Ok:
        return TrapCode::NONE;

    case SafeMemory::Status::AccessViolation:
        return TrapCode::DTB_ACCESS_VIOLATION;

    case SafeMemory::Status::Misaligned:
        return TrapCode::DTB_FAULT;

    case SafeMemory::Status::BusError:
    default:
        return TrapCode::MACHINE_CHECK; // Machine check
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\trapTranslation_inl.h
LINE: 10
SIGNATURE:
   switch(r) 

BODY (preview):
    switch (r) {
    case TranslationResult::TlbMiss:
        return (k == AccessKind::EXECUTE)
                   ? TrapCode::ITB_MISS
                   : TrapCode::DTB_MISS;

    case TranslationResult::PermissionDenied:
        return (k == AccessKind::EXECUTE)
                   ? TrapCode::ITB_ACV
                   : TrapCode::DTB_ACV;

    case TranslationResult::NonCanonical:
    case TranslationResult::BadAlignment:
        return TrapCode::DTB_FAULT; // EV6 rule


================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\trapTranslation_inl.h
LINE: 30
SIGNATURE:
inline TrapCode translateStatusToTrap(SafeMemory::Status st) noexcept

BODY (preview):
inline TrapCode translateStatusToTrap(SafeMemory::Status st) noexcept {
    switch (st) {
    case SafeMemory::Status::Ok:
        return TrapCode::NONE;

    case SafeMemory::Status::AccessViolation:
        return TrapCode::DTB_ACV;

    case SafeMemory::Status::Unaligned:
        return TrapCode::DTB_FAULT;

    case SafeMemory::Status::BusError:
    default:
        return TrapCode::MCHK; // Machine check
    }

================================================================================
FILE: z:\EmulatRApp\cpuCoreLib\trapTranslation_inl.h
LINE: 31
SIGNATURE:
   switch(st) 

BODY (preview):
    switch (st) {
    case SafeMemory::Status::Ok:
        return TrapCode::NONE;

    case SafeMemory::Status::AccessViolation:
        return TrapCode::DTB_ACV;

    case SafeMemory::Status::Unaligned:
        return TrapCode::DTB_FAULT;

    case SafeMemory::Status::BusError:
    default:
        return TrapCode::MCHK; // Machine check
    }

================================================================================
FILE: z:\EmulatRApp\EBoxLib\EBoxBase.h
LINE: 66
SIGNATURE:
	RegisterBankInteger& registerIntBank() 

BODY (preview):
	RegisterBankInteger& registerIntBank() { return m_intRegister; }


================================================================================
FILE: z:\EmulatRApp\EBoxLib\EBoxBase.h
LINE: 71
SIGNATURE:
	AXP_FLATTEN void writeIntReg(quint8 index, quint64 value) 

BODY (preview):
	AXP_FLATTEN void writeIntReg(quint8 index, quint64 value) {
		m_intRegister.write(index, value);
	}

================================================================================
FILE: z:\EmulatRApp\EBoxLib\EBoxBase.h
LINE: 89
SIGNATURE:
 if(m_busy && m_cyclesRemaining > 0) 

BODY (preview):
		if (m_busy && m_cyclesRemaining > 0) {
			m_cyclesRemaining--;
			if (m_cyclesRemaining == 0) {
				m_busy = false;
			}
		}

================================================================================
FILE: z:\EmulatRApp\EBoxLib\EBoxBase.h
LINE: 91
SIGNATURE:
	 if(m_cyclesRemaining == 0) 

BODY (preview):
			if (m_cyclesRemaining == 0) {
				m_busy = false;
			}

================================================================================
FILE: z:\EmulatRApp\EBoxLib\EBoxBase.h
LINE: 97
SIGNATURE:
	AXP_FLATTEN void execute(DecodedInstruction& di, quint64 resultInt) noexcept

BODY (preview):
	AXP_FLATTEN void execute(DecodedInstruction& di, quint64 resultInt) noexcept {


	}

================================================================================
FILE: z:\EmulatRApp\EBoxLib\EBoxBase.h
LINE: 435
SIGNATURE:
 for(int i = 0; i < 8; i++) 

BODY (preview):
		for (int i = 0; i < 8; i++) {
			const quint8 byteA = (srcA >> (i * 8)) & 0xFF;
			const quint8 byteB = (srcB >> (i * 8)) & 0xFF;
			if (byteA >= byteB)
				result |= (1ULL << i);
		}

================================================================================
FILE: z:\EmulatRApp\EBoxLib\EBoxBase.h
LINE: 522
SIGNATURE:
	AXP_FLATTEN void executeMskBL(const DecodedInstruction& di) noexcept

BODY (preview):
	AXP_FLATTEN void executeMskBL(const DecodedInstruction& di) noexcept {
		const quint64 srcA = m_ctx->readIntReg(di.ra);
		const quint64 srcB = getOperandB_64(di);  //  Offset/mask operand
		const quint64 result = Alpha_INT::ByteOps::mskbl(srcA, srcB);
		writeResult(di, result);
		// No trap - logical operation
	}

================================================================================
FILE: z:\EmulatRApp\EBoxLib\EboxVAState.h
LINE: 80
SIGNATURE:
	void setVA(VAType v) 

BODY (preview):
	void setVA(VAType v) {
		m_iprs->va = v;
	}

================================================================================
FILE: z:\EmulatRApp\EBoxLib\EboxVAState.h
LINE: 88
SIGNATURE:
	void setVA_CTL(VAType c) 

BODY (preview):
	void setVA_CTL(VAType c) {
		m_iprs->va_ctl = c & 0x7;
	}

================================================================================
FILE: z:\EmulatRApp\EBoxLib\EboxVAState.h
LINE: 96
SIGNATURE:
	void setVPTB(quint64 b) 

BODY (preview):
	void setVPTB(quint64 b) {
		m_iprs->vptb = b & 0xFFFFFFFFFFF80000ULL;
	}

================================================================================
FILE: z:\EmulatRApp\EBoxLib\EboxVAState.h
LINE: 145
SIGNATURE:
	 if(m_iprs->va_ctl & VA_CTL_FORM_MASK) 

BODY (preview):
			if (m_iprs->va_ctl & VA_CTL_FORM_MASK) {
				form |= (m_iprs->vptb & 0xC0000000ULL);
				form |= ((m_iprs->va & 0xFFFFE0000ULL) << 3);
			}

================================================================================
FILE: z:\EmulatRApp\EBoxLib\EboxVAState.h
LINE: 215
SIGNATURE:
 if(pageShift < 13 || pageShift >= 64) 

BODY (preview):
		if (pageShift < 13 || pageShift >= 64) {
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\EBoxLib\handleVA_FaultOrMiss_inl.h
LINE: 7
SIGNATURE:
void handleVA_FaultOrMiss(VAType va, ASNType asn, TLBFaultType fault) 

BODY (preview):
void handleVA_FaultOrMiss(VAType va, ASNType asn, TLBFaultType fault) { // TODO - not defined.
	//TODO
}

================================================================================
FILE: z:\EmulatRApp\EBoxLib\VA_core.h
LINE: 16
SIGNATURE:
inline TLB_BANK selectTLBBank(quint64 va) noexcept

BODY (preview):
inline TLB_BANK selectTLBBank(quint64 va) noexcept {
	// Example: high VA = bank 1, else bank 0
	return (va & 0xFFFF800000000000ULL) == 0xFFFF800000000000ULL
		? TLB_BANK::BANK1 : TLB_BANK::BANK0;
}

================================================================================
FILE: z:\EmulatRApp\EBoxLib\VA_core.h
LINE: 31
SIGNATURE:
inline bool isCanonicalUserVA(quint64 va) noexcept

BODY (preview):
inline bool isCanonicalUserVA(quint64 va) noexcept {
	return va <= MAX_VIRTUAL_ADDRESS;
}

================================================================================
FILE: z:\EmulatRApp\EBoxLib\VA_core.h
LINE: 36
SIGNATURE:
inline bool isValidASN(ASNType asn) noexcept

BODY (preview):
inline bool isValidASN(ASNType asn) noexcept {
	return asn < MAX_ASN; // 0..255 valid
}

================================================================================
FILE: z:\EmulatRApp\EBoxLib\VA_core.h
LINE: 40
SIGNATURE:
inline bool isValidAddressInASN(VAType va, ASNType asn) noexcept

BODY (preview):
inline bool isValidAddressInASN(VAType va, ASNType asn) noexcept {
	// Check VA within supported virtual address range
	if (va > MAX_VIRTUAL_ADDRESS) return false;

	// Check ASN is in valid range
	if (asn >= MAX_ASN) return false;

	// (Optional) Check current context's valid ASN list, or process mapping table

	return true; // Or more complex check
}

================================================================================
FILE: z:\EmulatRApp\EBoxLib\VA_core.h
LINE: 65
SIGNATURE:
inline bool isVA48(VAType va_ctl) noexcept

BODY (preview):
inline bool isVA48(VAType va_ctl) noexcept { return (va_ctl & 0x2) != 0; }
inline bool isVA43(VAType va_ctl) noexcept { return !isVA48(va_ctl); }

================================================================================
FILE: z:\EmulatRApp\EBoxLib\VA_core.h
LINE: 66
SIGNATURE:
inline bool isVA43(VAType va_ctl) noexcept

BODY (preview):
inline bool isVA43(VAType va_ctl) noexcept { return !isVA48(va_ctl); }
inline bool isBitEndian(VAType va_ctl) noexcept { return (va_ctl & 0x1) != 0; }

================================================================================
FILE: z:\EmulatRApp\EBoxLib\VA_core.h
LINE: 67
SIGNATURE:
inline bool isBitEndian(VAType va_ctl) noexcept

BODY (preview):
inline bool isBitEndian(VAType va_ctl) noexcept { return (va_ctl & 0x1) != 0; }


================================================================================
FILE: z:\EmulatRApp\EBoxLib\VA_core.h
LINE: 70
SIGNATURE:
 inline quint64 extractVPN(VAType va, VAType va_ctl) noexcept

BODY (preview):
// inline quint64 extractVPN(VAType va, VAType va_ctl) noexcept {
// 	return isVA48(va_ctl) ? ((va & 0xFFFFFFFFFFFE0000ULL) >> 13)
// 		: ((va & 0x7FFFFFE0000ULL) >> 13);
// }

================================================================================
FILE: z:\EmulatRApp\EBoxLib\VA_core.h
LINE: 76
SIGNATURE:
inline quint64 extractOffset(VAType va) noexcept

BODY (preview):
inline quint64 extractOffset(VAType va) noexcept {
	return va & 0x1FFFULL;
}

================================================================================
FILE: z:\EmulatRApp\EBoxLib\VA_core.h
LINE: 81
SIGNATURE:
inline quint64 computeVA_FORM(VAType va, VAType va_ctl, quint64 vptb) noexcept

BODY (preview):
inline quint64 computeVA_FORM(VAType va, VAType va_ctl, quint64 vptb) noexcept {
	quint64 form = (vptb & 0xFFFFFFFFFFF80000ULL); // VPTB[63:33]
	if (isVA48(va_ctl)) {
		form |= ((va & 0x3F00000000000ULL) >> 6);
		form |= ((va & 0xFFFFE0000ULL) << 16);
		form |= (quint64(qint64(va) >> 58) << 38);
	}
	else {
		if (va_ctl & 0x4) { // VA_CTL_FORM_MASK
			form |= (vptb & 0xC0000000ULL);
			form |= ((va & 0xFFFFE0000ULL) << 3);
		}
		else {
			form |= ((va & 0x20000000000ULL) >> 10);
			form |= ((va & 0xFFFFE0000ULL) << 3);

================================================================================
FILE: z:\EmulatRApp\EBoxLib\VA_core.h
LINE: 89
SIGNATURE:
 if(va_ctl & 0x4) 

BODY (preview):
		if (va_ctl & 0x4) { // VA_CTL_FORM_MASK
			form |= (vptb & 0xC0000000ULL);
			form |= ((va & 0xFFFFE0000ULL) << 3);
		}

================================================================================
FILE: z:\EmulatRApp\EBoxLib\VA_core.h
LINE: 104
SIGNATURE:
inline AddressClass classifyVA(VAType va, VAType va_ctl) noexcept

BODY (preview):
inline AddressClass classifyVA(VAType va, VAType va_ctl) noexcept {
	if (isVA48(va_ctl)) {
		if (va >= USER_MIN_48 && va <= USER_MAX_48)   return AddressClass::User;
		if (va >= KERNEL_MIN_48 && va <= KERNEL_MAX_48) return AddressClass::Kernel;
	}
	else {
		if (va >= USER_MIN_43 && va <= USER_MAX_43)   return AddressClass::User;
		if (va >= KERNEL_MIN_43 && va <= KERNEL_MAX_43) return AddressClass::Kernel;
	}
	return AddressClass::Unknown;
}

================================================================================
FILE: z:\EmulatRApp\EBoxLib\VA_core.h
LINE: 117
SIGNATURE:
inline bool isUserVA(VAType va, quint64 va_ctl) noexcept

BODY (preview):
inline bool isUserVA(VAType va, quint64 va_ctl)   noexcept { return classifyVA(va, va_ctl) == AddressClass::User; }
inline bool isKernelVA(VAType va, quint64 va_ctl) noexcept { return classifyVA(va, va_ctl) == AddressClass::Kernel; }

================================================================================
FILE: z:\EmulatRApp\EBoxLib\VA_core.h
LINE: 118
SIGNATURE:
inline bool isKernelVA(VAType va, quint64 va_ctl) noexcept

BODY (preview):
inline bool isKernelVA(VAType va, quint64 va_ctl) noexcept { return classifyVA(va, va_ctl) == AddressClass::Kernel; }


================================================================================
FILE: z:\EmulatRApp\exceptionLib\ExceptionHelpers_inl.h
LINE: 98
SIGNATURE:
   if(oldSum != excSum) 

BODY (preview):
    if (oldSum != excSum) {
        qDebug() << "CPU" << cpuId << "EXC_SUM:"
            << Qt::hex << oldSum << "->" << excSum;
    }

================================================================================
FILE: z:\EmulatRApp\exceptionLib\ExceptionHelpers_inl.h
LINE: 118
SIGNATURE:
   if(oldSum != newSum) 

BODY (preview):
    if (oldSum != newSum) {
        qDebug() << "[CPU" << cpuId << "] EXC_SUM change:"
            << "old=" << Qt::hex << oldSum
            << "new=" << Qt::hex << newSum
            << "diff=" << (newSum ^ oldSum);
    }

================================================================================
FILE: z:\EmulatRApp\exceptionLib\ExceptionHelpers_inl.h
LINE: 155
SIGNATURE:
   if(oldAddr != newAddr) 

BODY (preview):
    if (oldAddr != newAddr) {
        qDebug() << "[CPU" << cpuId << "] EXC_ADDR changed:"
            << Qt::hex << oldAddr << "->" << newAddr;
    }

================================================================================
FILE: z:\EmulatRApp\exceptionLib\ExceptionHelpers_inl.h
LINE: 176
SIGNATURE:
   if(excSum & HARDWARE_ERROR) 

BODY (preview):
    if (excSum & HARDWARE_ERROR) {
        // Hardware error takes highest priority
        // Should trigger machine check
    }

================================================================================
FILE: z:\EmulatRApp\exceptionLib\ExceptionHelpers_inl.h
LINE: 180
SIGNATURE:
    else if(excSum & PROCESSOR_ERROR) 

BODY (preview):
    else if (excSum & PROCESSOR_ERROR) {
        // Processor error
    }

================================================================================
FILE: z:\EmulatRApp\exceptionLib\ExceptionHelpers_inl.h
LINE: 183
SIGNATURE:
    else if(excSum & MEMORY_ERROR) 

BODY (preview):
    else if (excSum & MEMORY_ERROR) {
        // Memory subsystem error
    }

================================================================================
FILE: z:\EmulatRApp\exceptionLib\ExceptionHelpers_inl.h
LINE: 243
SIGNATURE:
   if(entry && entry->entryPC != 0xDEADBEEFDEADBEEF) 

BODY (preview):
    if (entry && entry->entryPC != 0xDEADBEEFDEADBEEF) {
        // Save current PC to HWPCB
        hwpcb.setSavedPC(hwpcb.getPC());
        hwpcb.setSavedPS(hwpcb.getPS());

        // Set exception address in IPR
        iprs.exc_addr = entry->entryPC;

        // Vector to PAL handler (actual PC update done by caller)
    }

================================================================================
FILE: z:\EmulatRApp\exceptionLib\ExceptionHelpers_inl.h
LINE: 269
SIGNATURE:
   if(errorType & CORRECTABLE_ERROR) 

BODY (preview):
    if (errorType & CORRECTABLE_ERROR) {
        // Log correctable error
#ifdef DEBUG_EXCEPTIONS
        qDebug() << "[CPU" << cpuId << "] Correctable error at"
            << Qt::hex << errorAddr << "type=" << errorType;
#endif

        // Clear correctable error bit
        excSum &= ~CORRECTABLE_ERROR;
        iprs.exc_sum = excSum;
    }

================================================================================
FILE: z:\EmulatRApp\exceptionLib\ExceptionHelpers_inl.h
LINE: 325
SIGNATURE:
   if(faultPC == 0) 

BODY (preview):
    if (faultPC == 0) {
        faultPC = hwpcb.getPC();
    }

================================================================================
FILE: z:\EmulatRApp\exceptionLib\ExceptionHelpers_inl.h
LINE: 332
SIGNATURE:
   if(faultVA != 0) 

BODY (preview):
    if (faultVA != 0) {
        hwpcb.setVA_Fault(faultVA);
    }

================================================================================
FILE: z:\EmulatRApp\exceptionLib\ExceptionHelpers_inl.h
LINE: 340
SIGNATURE:
   if(entry && entry->entryPC != 0xDEADBEEFDEADBEEF) 

BODY (preview):
    if (entry && entry->entryPC != 0xDEADBEEFDEADBEEF) {
        // Set exception handler address in both IPR and HWPCB
        iprs.exc_addr = entry->entryPC;
        hwpcb.setExc_Addr(entry->entryPC);
    }

================================================================================
FILE: z:\EmulatRApp\exceptionLib\ExceptionHelpers_inl.h
LINE: 352
SIGNATURE:
void handleTLBMiss(CPUIdType cpuId, quint64 faultVA, quint64 faultPC) 

BODY (preview):
void handleTLBMiss(CPUIdType cpuId, quint64 faultVA, quint64 faultPC) {
    buildExceptionContext(cpuId, ExceptionCategory::DTB_MISS, faultVA, faultPC);
    syncPALcodeExceptionState(cpuId);
    // Jump to PAL handler at iprs.exc_addr
}

================================================================================
FILE: z:\EmulatRApp\exceptionLib\ExceptionHelpers_inl.h
LINE: 359
SIGNATURE:
void handleITBMiss(CPUIdType cpuId, quint64 faultVA, quint64 faultPC) 

BODY (preview):
void handleITBMiss(CPUIdType cpuId, quint64 faultVA, quint64 faultPC) {
    buildExceptionContext(cpuId, ExceptionCategory::ITB_MISS, faultVA, faultPC);
    syncPALcodeExceptionState(cpuId);
}

================================================================================
FILE: z:\EmulatRApp\exceptionLib\ExceptionHelpers_inl.h
LINE: 365
SIGNATURE:
void handleHardwareError(CPUIdType cpuId, quint64 errorAddr, quint64 errorType) 

BODY (preview):
void handleHardwareError(CPUIdType cpuId, quint64 errorAddr, quint64 errorType) {
    attemptErrorRecovery(cpuId, errorAddr, errorType);
    buildExceptionContext(cpuId, ExceptionCategory::MACHINE_CHECK);
}

================================================================================
FILE: z:\EmulatRApp\exceptionLib\ExceptionHelpers_inl.h
LINE: 371
SIGNATURE:
void handleArithmeticTrap(CPUIdType cpuId, quint64 faultPC) 

BODY (preview):
void handleArithmeticTrap(CPUIdType cpuId, quint64 faultPC) {
    buildExceptionContext(cpuId, ExceptionCategory::ARITHMETIC, 0, faultPC);
    syncPALcodeExceptionState(cpuId);
}

================================================================================
FILE: z:\EmulatRApp\exceptionLib\ExceptionStateUpdate_inl.h
LINE: 198
SIGNATURE:
   if(ev.faultVA != 0) 

BODY (preview):
    if (ev.faultVA != 0) {
        saveFaultVirtualAddress(ctx, ev.faultVA);
    }

================================================================================
FILE: z:\EmulatRApp\exceptionLib\ExceptionStateUpdate_inl.h
LINE: 203
SIGNATURE:
   if(ev.exceptionClass == ExceptionClass::MACHINE_CHECK) 

BODY (preview):
    if (ev.exceptionClass == ExceptionClass::MACHINE_CHECK) {
        // Update MCES (Machine Check Error Summary)
        // Implementation depends on your MCES structure
        // iprs.mces |= ...;
    }

================================================================================
FILE: z:\EmulatRApp\faultLib\buildArithmeticTrap_inl.h
LINE: 6
SIGNATURE:
inline ArithmeticTrapKind buildArithmeticTrap(bool inv, bool dze, bool ovf, bool unf, bool ine, bool iov = false) 

BODY (preview):
inline ArithmeticTrapKind buildArithmeticTrap(bool inv, bool dze, bool ovf, bool unf, bool ine, bool iov = false) {
	quint16 result = 0;
	if (inv) result |= static_cast<quint16>(ArithmeticTrapKind::INVALID_OPERATION);
	if (dze) result |= static_cast<quint16>(ArithmeticTrapKind::DIVIDE_BY_ZERO);
	if (ovf) result |= static_cast<quint16>(ArithmeticTrapKind::OVER_FLOW);
	if (unf) result |= static_cast<quint16>(ArithmeticTrapKind::UNDER_FLOW);
	if (ine) result |= static_cast<quint16>(ArithmeticTrapKind::INEXACT);
	if (iov) result |= static_cast<quint16>(ArithmeticTrapKind::INTEGER_OVERFLOW);
	return static_cast<ArithmeticTrapKind>(result);
}

================================================================================
FILE: z:\EmulatRApp\faultLib\decodeMMStateFaultType.h
LINE: 27
SIGNATURE:
   switch(faultTypeBits) 

BODY (preview):
    switch (faultTypeBits) {
    case 0:
    case 1:
    case 2:
        // DTB miss - distinguish read vs write using bit [0]
        return isWrite ? MemoryFaultType::DTB_MISS_WRITE
                       : MemoryFaultType::DTB_MISS_READ;

    case 3:
        // Access violation - distinguish read vs write
        return isWrite ? MemoryFaultType::DTB_ACCESS_VIOLATION_WRITE
                       : MemoryFaultType::DTB_ACCESS_VIOLATION_READ;

    case 4:
        return MemoryFaultType::FAULT_ON_READ;

================================================================================
FILE: z:\EmulatRApp\faultLib\decodeMMStateFaultType.h
LINE: 58
SIGNATURE:
   switch(faultType) 

BODY (preview):
    switch (faultType) {
    case MemoryFaultType::DTB_MISS_READ:
    case MemoryFaultType::DTB_MISS_WRITE:
    case MemoryFaultType::DTB_FAULT_READ:
    case MemoryFaultType::DTB_FAULT_WRITE:
    case MemoryFaultType::DTB_ACCESS_VIOLATION_READ:
    case MemoryFaultType::DTB_ACCESS_VIOLATION_WRITE:
    case MemoryFaultType::FAULT_ON_READ:
    case MemoryFaultType::FAULT_ON_WRITE:
    case MemoryFaultType::FAULT_ON_EXECUTE:
    case MemoryFaultType::PAGE_NOT_PRESENT:
        return true;

    default:
        return false;

================================================================================
FILE: z:\EmulatRApp\faultLib\FaultDispatcher.h
LINE: 188
SIGNATURE:
       if(!entry) 

BODY (preview):
        if (!entry) {
            ERROR_LOG(std::format("Invalid PAL vector for HW IRQ: {}",
                                  static_cast<int>(m_pending.palVectorId)));
            return;
        }

================================================================================
FILE: z:\EmulatRApp\faultLib\FaultDispatcher.h
LINE: 216
SIGNATURE:
       if(!entry) 

BODY (preview):
        if (!entry) {
            ERROR_LOG(std::format("Invalid PAL vector for HW IRQ: {}",
                                  static_cast<int>(m_pending.palVectorId)));
            return;
        }

================================================================================
FILE: z:\EmulatRApp\faultLib\FaultDispatcher.h
LINE: 250
SIGNATURE:
 if(!entry || entry->entryPC == 0xDEADBEEFDEADBEEF) 

BODY (preview):
		if (!entry || entry->entryPC == 0xDEADBEEFDEADBEEF) {
			ERROR_LOG(std::format("Invalid PAL vector {}",
				static_cast<int>(m_pending.palVectorId)));
			m_cpu->halt();
			return;
		}

================================================================================
FILE: z:\EmulatRApp\faultLib\FaultDispatcher.h
LINE: 275
SIGNATURE:
       if(!entry) 

BODY (preview):
        if (!entry) {
            ERROR_LOG("Machine check with invalid PAL vector!");
            m_cpu->halt();
            return;
        }

================================================================================
FILE: z:\EmulatRApp\faultLib\FaultDispatcher.h
LINE: 297
SIGNATURE:
       if(!entry) 

BODY (preview):
        if (!entry) {
            ERROR_LOG("Machine check with invalid PAL vector!");
            m_cpu->halt();
            return;
        }

================================================================================
FILE: z:\EmulatRApp\faultLib\FaultDispatcher.h
LINE: 319
SIGNATURE:
       if(!entry) 

BODY (preview):
        if (!entry) {
            ERROR_LOG("Machine check with invalid PAL vector!");
            m_cpu->halt();
            return;
        }

================================================================================
FILE: z:\EmulatRApp\faultLib\fault_core.h
LINE: 192
SIGNATURE:
inline bool hasArithmeticException(ArithmeticTrapKind kind, ArithmeticTrapKind flag) 

BODY (preview):
inline bool hasArithmeticException(ArithmeticTrapKind kind, ArithmeticTrapKind flag) {
	return (static_cast<quint16>(kind) & static_cast<quint16>(flag)) != 0;
}

================================================================================
FILE: z:\EmulatRApp\faultLib\handleInvalidPTE_inl.h
LINE: 5
SIGNATURE:
inline void handleInvalidPTE(CPUIdType cpuId, VAType va, AlphaPTE pte) noexcept

BODY (preview):
inline void handleInvalidPTE(CPUIdType cpuId, VAType va, AlphaPTE pte) noexcept {


}

================================================================================
FILE: z:\EmulatRApp\faultLib\handleMemoryManagementFault_inl.h
LINE: 27
SIGNATURE:
   switch(faultInfo.faultType) 

BODY (preview):
    switch (faultInfo.faultType) {

    // ====================================================================
    // DTB Miss - Most common case
    // ====================================================================
    case MemoryFaultType::DTB_MISS_READ:
    case MemoryFaultType::DTB_MISS_WRITE:
        handleDTBMiss(cpu, faultInfo);
        break;

    // ====================================================================
    // Access Violations
    // ====================================================================
    case MemoryFaultType::DTB_ACCESS_VIOLATION_READ:
    case MemoryFaultType::DTB_ACCESS_VIOLATION_WRITE:

================================================================================
FILE: z:\EmulatRApp\faultLib\handleVirtualAddressFault.h
LINE: 5
SIGNATURE:
inline void handleVirtualAddressFault(AlphaCPU &cpuState, quint64 newValue) noexcept

BODY (preview):
inline void handleVirtualAddressFault(AlphaCPU &cpuState, quint64 newValue) noexcept {

}

================================================================================
FILE: z:\EmulatRApp\faultLib\MemoryFaultInfo.h
LINE: 108
SIGNATURE:
 switch(accessSize) 

BODY (preview):
		switch (accessSize) {
		case 1:  return MemoryAccessSize::BYTE;
		case 2:  return MemoryAccessSize::WORD;
		case 4:  return MemoryAccessSize::LONGWORD;
		case 8:  return MemoryAccessSize::QUADWORD;
		case 16: return MemoryAccessSize::OCTAWORD;
		default: return MemoryAccessSize::QUADWORD;
		}

================================================================================
FILE: z:\EmulatRApp\faultLib\MemoryFaultInfo.h
LINE: 138
SIGNATURE:
 switch(faultType) 

BODY (preview):
		switch (faultType) {
		case MemoryFaultType::ITB_MISS:
		case MemoryFaultType::DTB_MISS_READ:
		case MemoryFaultType::DTB_MISS_WRITE:
		case MemoryFaultType::ITB_FAULT:
		case MemoryFaultType::DTB_FAULT_READ:
		case MemoryFaultType::DTB_FAULT_WRITE:
		case MemoryFaultType::ALIGNMENT_FAULT:
		case MemoryFaultType::FEN_FAULT:
		case MemoryFaultType::OPCODE_FAULT:
		case MemoryFaultType::MACHINE_CHECK:
		case MemoryFaultType::BREAKPOINT:
		case MemoryFaultType::BUGCHECK:
			return true;
		default:

================================================================================
FILE: z:\EmulatRApp\faultLib\onMemoryManagementFault_inl.h
LINE: 7
SIGNATURE:
inline void handleMemoryManagementFault(AlphaCPU* cpuState, qint64 faultAddress, quint8 faultType, quint8 accesstype) noexcept

BODY (preview):
inline void handleMemoryManagementFault(AlphaCPU* cpuState, qint64 faultAddress, quint8 faultType, quint8 accesstype) noexcept{

}

================================================================================
FILE: z:\EmulatRApp\faultLib\PendingEvent_refined.h
LINE: 89
SIGNATURE:
    inline void clear() noexcept

BODY (preview):
    inline void clear() noexcept {
        kind = PendingEventKind::None;
        exceptionClass = ExceptionClass::None;
        palVectorId = PalVectorId::INVALID;
        faultVA = 0;
        asn = 0;
        extraInfo = 0;
        hwVector = 0;
        hwIPL = 0;
        swiLevel = 0;
        astMode = 0;
        mcReason = MachineCheckReason::NONE;
        Property_info = PropertyInfo{};
    }

================================================================================
FILE: z:\EmulatRApp\faultLib\raiseMachineCheck_inl.h
LINE: 6
SIGNATURE:
inline void raiseMachineCheck(PAType pa, bool isRead) noexcept

BODY (preview):
inline void raiseMachineCheck(PAType pa, bool isRead) noexcept {


}

================================================================================
FILE: z:\EmulatRApp\faultLib\raiseOpcodeFault_inl.h
LINE: 7
SIGNATURE:
inline void raiseOpcodeFault(CPUIdType cpuId, OpcodeFaultKind faultKind) noexcept

BODY (preview):
inline void raiseOpcodeFault(CPUIdType cpuId, OpcodeFaultKind faultKind) noexcept {

}

================================================================================
FILE: z:\EmulatRApp\faultLib\raisePageFault_inl.h
LINE: 5
SIGNATURE:
inline void raisePageFault(CPUIdType cpuid, VAType va, PTEType pte) noexcept

BODY (preview):
inline void raisePageFault(CPUIdType cpuid, VAType va, PTEType pte) noexcept {


}

================================================================================
FILE: z:\EmulatRApp\faultLib\raiseTrap_inl.h
LINE: 8
SIGNATURE:
inline void raiseTrap(AlphaCPU* cpuState, TrapCode trapCode, MemoryFaultInfo fault) noexcept

BODY (preview):
inline void raiseTrap(AlphaCPU* cpuState, TrapCode trapCode, MemoryFaultInfo fault) noexcept {


}

================================================================================
FILE: z:\EmulatRApp\faultLib\trackMemoryFault_inl.h
LINE: 15
SIGNATURE:
   switch(faultType) 

BODY (preview):
    switch (faultType) {
    case MemoryFaultType::DTB_MISS_READ:
    case MemoryFaultType::DTB_MISS_WRITE:
        argCpu->incrementPerfCounter(PerfEvent::DTB_MISSES);
        break;

    case MemoryFaultType::DTB_ACCESS_VIOLATION_READ:
    case MemoryFaultType::DTB_ACCESS_VIOLATION_WRITE:
        argCpu->incrementPerfCounter(PerfEvent::ACCESS_VIOLATIONS);
        break;

    case MemoryFaultType::FAULT_ON_WRITE:
        argCpu->incrementPerfCounter(PerfEvent::FAULT_ON_WRITE);
        break;


================================================================================
FILE: z:\EmulatRApp\FBoxLib\FBoxBase.h
LINE: 47
SIGNATURE:
	AXP_FLATTEN void writeFpReg(quint8 index, quint64 value) 

BODY (preview):
	AXP_FLATTEN void writeFpReg(quint8 index, quint64 value) {
		m_fpRegister.write(index, value);
	}

================================================================================
FILE: z:\EmulatRApp\FBoxLib\FBoxBase.h
LINE: 50
SIGNATURE:
	RegisterBankFP& registerFpBank() 

BODY (preview):
	RegisterBankFP& registerFpBank() { return m_fpRegister; }


================================================================================
FILE: z:\EmulatRApp\FBoxLib\FBoxBase.h
LINE: 52
SIGNATURE:
	AXP_FLATTEN quint64 getFPCRRaw() noexcept

BODY (preview):
	AXP_FLATTEN quint64 getFPCRRaw()   noexcept { return m_fpcr.raw(); }
	AXP_FLATTEN FpcrRegister& getFPCRegister() noexcept { return m_fpcr; }

================================================================================
FILE: z:\EmulatRApp\FBoxLib\FBoxBase.h
LINE: 53
SIGNATURE:
	AXP_FLATTEN FpcrRegister& getFPCRegister() noexcept

BODY (preview):
	AXP_FLATTEN FpcrRegister& getFPCRegister() noexcept { return m_fpcr; }
#pragma endregion FPCR Public Accessors

================================================================================
FILE: z:\EmulatRApp\FBoxLib\FBoxBase.h
LINE: 63
SIGNATURE:
 if(m_busy && m_cyclesRemaining > 0) 

BODY (preview):
		if (m_busy && m_cyclesRemaining > 0) {
			m_cyclesRemaining--;
			if (m_cyclesRemaining == 0) {
				m_busy = false;
			}
		}

================================================================================
FILE: z:\EmulatRApp\FBoxLib\FBoxBase.h
LINE: 65
SIGNATURE:
	 if(m_cyclesRemaining == 0) 

BODY (preview):
			if (m_cyclesRemaining == 0) {
				m_busy = false;
			}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\AlphaInstructionGrain.h
LINE: 44
SIGNATURE:
	grainPlatform grainPlatform() 

BODY (preview):
	grainPlatform grainPlatform() { return m_grainPlatform; }
	void setTargetPlatform(grainPlatform platform) {
		m_grainPlatform = platform;
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\AlphaInstructionGrain.h
LINE: 45
SIGNATURE:
	void setTargetPlatform(grainPlatform platform) 

BODY (preview):
	void setTargetPlatform(grainPlatform platform) {
		m_grainPlatform = platform;
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 104
SIGNATURE:
AXP_FLATTEN inline quint32 getRaw(const DecodedInstruction& di) noexcept

BODY (preview):
AXP_FLATTEN inline quint32 getRaw(const DecodedInstruction& di) noexcept {
    return static_cast<quint32>(di.semantics >> RAW_SHIFT);
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 113
SIGNATURE:
AXP_FLATTEN inline void setRaw(DecodedInstruction& di, quint32 raw) noexcept

BODY (preview):
AXP_FLATTEN inline void setRaw(DecodedInstruction& di, quint32 raw) noexcept {
    // Clear old raw bits, keep semantic flags
    di.semantics = (di.semantics & SEMANTICS_MASK) |
        (static_cast<quint64>(raw) << RAW_SHIFT);
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 124
SIGNATURE:
AXP_FLATTEN inline quint8 getOpcodeFromPacked(const DecodedInstruction& di) noexcept

BODY (preview):
AXP_FLATTEN inline quint8 getOpcodeFromPacked(const DecodedInstruction& di) noexcept {
    return static_cast<quint8>((di.semantics >> (RAW_SHIFT + 26)) & 0x3F);
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 132
SIGNATURE:
AXP_FLATTEN inline bool isLoad(const DecodedInstruction& di) noexcept

BODY (preview):
AXP_FLATTEN inline bool isLoad(const DecodedInstruction& di) noexcept {
    return (di.semantics & S_Load) != 0;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 136
SIGNATURE:
AXP_FLATTEN inline bool isStore(const DecodedInstruction& di) noexcept

BODY (preview):
AXP_FLATTEN inline bool isStore(const DecodedInstruction& di) noexcept {
    return (di.semantics & S_Store) != 0;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 140
SIGNATURE:
AXP_FLATTEN inline bool isBranchFormat(const DecodedInstruction& di) noexcept

BODY (preview):
AXP_FLATTEN inline bool isBranchFormat(const DecodedInstruction& di) noexcept {
    return (di.semantics & S_Branch) != 0;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 144
SIGNATURE:
AXP_FLATTEN inline bool isMemoryFormat(const DecodedInstruction& di) noexcept

BODY (preview):
AXP_FLATTEN inline bool isMemoryFormat(const DecodedInstruction& di) noexcept {
    return (di.semantics & S_MemFmt) != 0;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 161
SIGNATURE:
bool isPalFormat(const DecodedInstruction& di) noexcept

BODY (preview):
bool isPalFormat(const DecodedInstruction& di) noexcept {
	return (di.semantics & S_PalFormat) != 0;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 170
SIGNATURE:
AXP_FLATTEN inline quint8 getRA(const DecodedInstruction& di) noexcept

BODY (preview):
AXP_FLATTEN inline quint8 getRA(const DecodedInstruction& di) noexcept {
    return di.ra;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 174
SIGNATURE:
AXP_FLATTEN inline quint8 getRB(const DecodedInstruction& di) noexcept

BODY (preview):
AXP_FLATTEN inline quint8 getRB(const DecodedInstruction& di) noexcept {
    return di.rb;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 178
SIGNATURE:
AXP_FLATTEN inline quint8 getRC(const DecodedInstruction& di) noexcept

BODY (preview):
AXP_FLATTEN inline quint8 getRC(const DecodedInstruction& di) noexcept {
    return di.rc;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 186
SIGNATURE:
AXP_FLATTEN inline MemSize getMemSize(const DecodedInstruction& di) noexcept

BODY (preview):
AXP_FLATTEN inline MemSize getMemSize(const DecodedInstruction& di) noexcept {
    return static_cast<MemSize>((di.semantics >> S_MEMSIZE_SHIFT) & 0x7);
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 192
SIGNATURE:
AXP_FLATTEN inline void setMemSize(DecodedInstruction& di, MemSize sz) noexcept

BODY (preview):
AXP_FLATTEN inline void setMemSize(DecodedInstruction& di, MemSize sz) noexcept {
    di.semantics &= ~S_MEMSIZE_MASK;
    di.semantics |= (static_cast<quint64>(sz) << S_MEMSIZE_SHIFT);
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 201
SIGNATURE:
AXP_FLATTEN static  quint8 extractOpcode(quint32 raw) noexcept

BODY (preview):
AXP_FLATTEN static  quint8 extractOpcode(quint32 raw) noexcept {
    return (raw >> 26) & 0x3F;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 205
SIGNATURE:
AXP_FLATTEN  quint8 extractRA(quint32 raw) noexcept

BODY (preview):
AXP_FLATTEN  quint8 extractRA(quint32 raw) noexcept {
    return (raw >> 21) & 0x1F;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 209
SIGNATURE:
AXP_FLATTEN quint8 extractRB(quint32 raw) noexcept

BODY (preview):
AXP_FLATTEN quint8 extractRB(quint32 raw) noexcept {
    return (raw >> 16) & 0x1F;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 213
SIGNATURE:
AXP_FLATTEN  quint8 extractRC(quint32 raw) noexcept

BODY (preview):
AXP_FLATTEN  quint8 extractRC(quint32 raw) noexcept {
    return raw & 0x1F;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 217
SIGNATURE:
AXP_FLATTEN  quint16 extractFunction(quint32 raw) noexcept

BODY (preview):
AXP_FLATTEN  quint16 extractFunction(quint32 raw) noexcept {
    return (raw >> 5) & 0x7F;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 221
SIGNATURE:
AXP_FLATTEN  bool extractLBit(quint32 raw) noexcept

BODY (preview):
AXP_FLATTEN  bool extractLBit(quint32 raw) noexcept {
    return (raw >> 12) & 1;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 225
SIGNATURE:
AXP_FLATTEN inline quint8 extractLiteral(quint32 raw) noexcept

BODY (preview):
AXP_FLATTEN inline quint8 extractLiteral(quint32 raw) noexcept {
    return (raw >> 13) & 0xFF;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 234
SIGNATURE:
   if(opcode < 0x30 || opcode > 0x3F) 

BODY (preview):
    if (opcode < 0x30 || opcode > 0x3F) {
        di.branchCode = static_cast<quint8>(BranchCode::NONE);
        return;
    }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstruction.h
LINE: 333
SIGNATURE:
   void execute(const DecodedInstruction& di, AlphaProcessorContext& ctx) 

BODY (preview):
//   void execute(const DecodedInstruction& di, AlphaProcessorContext& ctx) {
//       // Access semantics (includes packed raw)
//       if (isLoad(di)) { ... }
//       
//       // Extract raw if needed (rare)
//       quint32 raw = getRaw(di);
//   }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 162
SIGNATURE:
       if(opFunc == 0x00) 

BODY (preview):
        if (opFunc == 0x00) {
            sz = MemSize::Long;
            semFlags = S_Load;
        }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 166
SIGNATURE:
        else if(opFunc == 0x01) 

BODY (preview):
        else if (opFunc == 0x01) {
            sz = MemSize::Quad;
            semFlags = S_Load;
        }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 170
SIGNATURE:
        else if(opFunc == 0x02) 

BODY (preview):
        else if (opFunc == 0x02) {
            sz = MemSize::Word;
            semFlags = static_cast<InstrSemantics>(S_Load | S_ZeroExtend);
        }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 192
SIGNATURE:
       if(opFunc == 0x20) 

BODY (preview):
        if (opFunc == 0x20) {
            sz = MemSize::Long;
            semFlags = S_Store;
        }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 196
SIGNATURE:
        else if(opFunc == 0x21) 

BODY (preview):
        else if (opFunc == 0x21) {
            sz = MemSize::Quad;
            semFlags = S_Store;
        }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 200
SIGNATURE:
        else if(opFunc == 0x22) 

BODY (preview):
        else if (opFunc == 0x22) {
            sz = MemSize::Word;
            semFlags = S_Store;
        }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 329
SIGNATURE:
inline bool isLoadLocked(const DecodedInstruction& di) noexcept

BODY (preview):
inline bool isLoadLocked(const DecodedInstruction& di) noexcept {
    return (di.semantics & S_LoadLocked) != 0;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 337
SIGNATURE:
inline bool isStoreConditional(const DecodedInstruction& di) noexcept

BODY (preview):
inline bool isStoreConditional(const DecodedInstruction& di) noexcept {
    return (di.semantics & S_StoreConditional) != 0;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 345
SIGNATURE:
inline bool isLLSC(const DecodedInstruction& di) noexcept

BODY (preview):
inline bool isLLSC(const DecodedInstruction& di) noexcept {
    return (di.semantics & (S_LoadLocked | S_StoreConditional)) != 0;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 353
SIGNATURE:
inline bool hasSideEffects(const DecodedInstruction& di) noexcept

BODY (preview):
inline bool hasSideEffects(const DecodedInstruction& di) noexcept {
    return (di.semantics & S_SideEffect) != 0;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 361
SIGNATURE:
inline bool isBarrier(const DecodedInstruction& di) noexcept

BODY (preview):
inline bool isBarrier(const DecodedInstruction& di) noexcept {
    return (di.semantics & S_Barrier) != 0;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 374
SIGNATURE:
AXP_FLATTEN  bool hasSem(quint64 m, InstrSemantics s) noexcept

BODY (preview):
AXP_FLATTEN  bool hasSem(quint64 m, InstrSemantics s) noexcept {
	return (m & s) != 0;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 378
SIGNATURE:
AXP_FLATTEN  void addSem(quint64& m, InstrSemantics s) noexcept

BODY (preview):
AXP_FLATTEN  void addSem(quint64& m, InstrSemantics s) noexcept {
	m |= s;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 382
SIGNATURE:
AXP_FLATTEN  void clearSem(quint64& m, InstrSemantics s) noexcept

BODY (preview):
AXP_FLATTEN  void clearSem(quint64& m, InstrSemantics s) noexcept {
	m &= ~static_cast<quint64>(s);
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 386
SIGNATURE:
AXP_FLATTEN  void toggleSem(quint64& m, InstrSemantics s) noexcept

BODY (preview):
AXP_FLATTEN  void toggleSem(quint64& m, InstrSemantics s) noexcept {
	m ^= s;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 390
SIGNATURE:
AXP_FLATTEN  void setSem(quint64& m, InstrSemantics s, bool enable) noexcept

BODY (preview):
AXP_FLATTEN  void setSem(quint64& m, InstrSemantics s, bool enable) noexcept {
	if (enable) {
		m |= s;
	}
	else {
		m &= ~static_cast<quint64>(s);
	}
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 404
SIGNATURE:
AXP_FLATTEN  void addMultiSem(quint64& m, InstrSemantics s1, InstrSemantics s2) noexcept

BODY (preview):
AXP_FLATTEN  void addMultiSem(quint64& m, InstrSemantics s1, InstrSemantics s2) noexcept {
	m |= (s1 | s2);
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 408
SIGNATURE:
AXP_FLATTEN  void addMultiSem(quint64& m, InstrSemantics s1, InstrSemantics s2, InstrSemantics s3) noexcept

BODY (preview):
AXP_FLATTEN  void addMultiSem(quint64& m, InstrSemantics s1, InstrSemantics s2, InstrSemantics s3) noexcept {
	m |= (s1 | s2 | s3);
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 413
SIGNATURE:
AXP_FLATTEN  bool hasAllSem(quint64 m, InstrSemantics mask) noexcept

BODY (preview):
AXP_FLATTEN  bool hasAllSem(quint64 m, InstrSemantics mask) noexcept {
	return (m & mask) == mask;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\DecodedInstructionHelper_inl.h
LINE: 418
SIGNATURE:
AXP_FLATTEN  bool hasAnySem(quint64 m, InstrSemantics mask) noexcept

BODY (preview):
AXP_FLATTEN  bool hasAnySem(quint64 m, InstrSemantics mask) noexcept {
	return (m & mask) != 0;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\fp_variant_core.h
LINE: 134
SIGNATURE:
 if(v.roundingMode != FpRoundingMode::UseFPCR) 

BODY (preview):
		if (v.roundingMode != FpRoundingMode::UseFPCR) {
			// Clear rounding mode bits
			local &= ~AlphaFPCR::DYN_RM_MASK;

			// Set new rounding mode
			quint64 rm = 0;
			switch (v.roundingMode) {
			case FpRoundingMode::RoundToNearest:  rm = AlphaFPCR::RM_NORMAL;    break;
			case FpRoundingMode::RoundTowardZero: rm = AlphaFPCR::RM_CHOPPED;   break;
			case FpRoundingMode::RoundUp:         rm = AlphaFPCR::RM_PLUS_INF;  break;
			case FpRoundingMode::RoundDown:       rm = AlphaFPCR::RM_MINUS_INF; break;
			default: break;
			}
			local |= (rm << AlphaFPCR::DYN_RM_SHIFT);
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\fp_variant_core.h
LINE: 140
SIGNATURE:
	 switch(v.roundingMode) 

BODY (preview):
			switch (v.roundingMode) {
			case FpRoundingMode::RoundToNearest:  rm = AlphaFPCR::RM_NORMAL;    break;
			case FpRoundingMode::RoundTowardZero: rm = AlphaFPCR::RM_CHOPPED;   break;
			case FpRoundingMode::RoundUp:         rm = AlphaFPCR::RM_PLUS_INF;  break;
			case FpRoundingMode::RoundDown:       rm = AlphaFPCR::RM_MINUS_INF; break;
			default: break;
			}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\fp_variant_core.h
LINE: 160
SIGNATURE:
 switch(variant.roundingMode) 

BODY (preview):
		switch (variant.roundingMode) {
		case FpRoundingMode::RoundToNearest:
			std::fesetround(FE_TONEAREST);
			break;
		case FpRoundingMode::RoundTowardZero:
			std::fesetround(FE_TOWARDZERO);
			break;
		case FpRoundingMode::RoundUp:
			std::fesetround(FE_UPWARD);
			break;
		case FpRoundingMode::RoundDown:
			std::fesetround(FE_DOWNWARD);
			break;
		case FpRoundingMode::UseFPCR:
			// Leave current rounding mode unchanged

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\fp_variant_core.h
LINE: 197
SIGNATURE:
 if(exceptions & FE_UNDERFLOW) 

BODY (preview):
		if (exceptions & FE_UNDERFLOW) {
			if (!variant.suppressUnderflow) {
				fpcr |= AlphaFPCR::UNF;
			}
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\fp_variant_core.h
LINE: 198
SIGNATURE:
	 if(!variant.suppressUnderflow) 

BODY (preview):
			if (!variant.suppressUnderflow) {
				fpcr |= AlphaFPCR::UNF;
			}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\fp_variant_core.h
LINE: 204
SIGNATURE:
 if(exceptions & FE_INEXACT) 

BODY (preview):
		if (exceptions & FE_INEXACT) {
			if (!variant.suppressInexact) {
				fpcr |= AlphaFPCR::INE;
			}
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\fp_variant_core.h
LINE: 205
SIGNATURE:
	 if(!variant.suppressInexact) 

BODY (preview):
			if (!variant.suppressInexact) {
				fpcr |= AlphaFPCR::INE;
			}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\global_grainResolver.h
LINE: 4
SIGNATURE:
inline GrainResolver& global_GrainResolver() 

BODY (preview):
inline GrainResolver& global_GrainResolver() {
	static GrainResolver instance;    // header-only is fine
	return instance;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\GrainResolver_legacy.h
LINE: 631
SIGNATURE:
 for(auto& vec : m_grainMap) 

BODY (preview):
		for (auto& vec : m_grainMap) {
			for (auto* g : vec) {
				delete g;
			}
			vec.clear();
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\GrainResolver_legacy.h
LINE: 632
SIGNATURE:
	 for(auto* g : vec) 

BODY (preview):
			for (auto* g : vec) {
				delete g;
			}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\GrainResolver_legacy.h
LINE: 645
SIGNATURE:
	   for(auto& vec : m_grainMap) 

BODY (preview):
	    for (auto& vec : m_grainMap) {
		    for (auto* g : vec) {
			    delete g;
		    }
		    vec.clear();
	    }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\GrainResolver_legacy.h
LINE: 646
SIGNATURE:
		   for(auto* g : vec) 

BODY (preview):
		    for (auto* g : vec) {
			    delete g;
		    }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\GrainResolver_legacy.h
LINE: 697
SIGNATURE:
       if(m_currentPlatform == grainPlatform::Tru64) 

BODY (preview):
        if (m_currentPlatform == grainPlatform::Tru64) {
            for (auto* g : candidates)
                if (g->grainPlatform() == grainPlatform::Tru64)
                    return g;
        }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\GrainResolver_legacy.h
LINE: 702
SIGNATURE:
       if(m_currentPlatform == grainPlatform::Linux) 

BODY (preview):
        if (m_currentPlatform == grainPlatform::Linux) {
            for (auto* g : candidates)
                if (g->grainPlatform() == grainPlatform::Linux)
                    return g;
        }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-DualCache_singleton.h
LINE: 12
SIGNATURE:
inline DecodeCache<PcKey>& pcDecodeCache() noexcept

BODY (preview):
inline DecodeCache<PcKey>& pcDecodeCache() noexcept {
	static DecodeCache<PcKey> instance;
	return instance;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-DualCache_singleton.h
LINE: 18
SIGNATURE:
inline DecodeCache<PaKey>& paDecodeCache() noexcept

BODY (preview):
inline DecodeCache<PaKey>& paDecodeCache() noexcept {
	static DecodeCache<PaKey> instance;
	return instance;
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-DualLookup_inl.h
LINE: 97
SIGNATURE:
 if(opFunc == 0x00) 

BODY (preview):
		if (opFunc == 0x00) {
			sz = MemSize::Long;
			semFlags = S_Load;
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-DualLookup_inl.h
LINE: 101
SIGNATURE:
		else if(opFunc == 0x01) 

BODY (preview):
		else if (opFunc == 0x01) {
			sz = MemSize::Quad;
			semFlags = S_Load;
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-DualLookup_inl.h
LINE: 105
SIGNATURE:
		else if(opFunc == 0x02) 

BODY (preview):
		else if (opFunc == 0x02) {
			sz = MemSize::Word;
			semFlags = static_cast<InstrSemantics>(S_Load | S_ZeroExtend);
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-DualLookup_inl.h
LINE: 117
SIGNATURE:
 if(opFunc == 0x20) 

BODY (preview):
		if (opFunc == 0x20) {
			sz = MemSize::Long;
			semFlags = S_Store;
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-DualLookup_inl.h
LINE: 121
SIGNATURE:
		else if(opFunc == 0x21) 

BODY (preview):
		else if (opFunc == 0x21) {
			sz = MemSize::Quad;
			semFlags = S_Store;
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-DualLookup_inl.h
LINE: 125
SIGNATURE:
		else if(opFunc == 0x22) 

BODY (preview):
		else if (opFunc == 0x22) {
			sz = MemSize::Word;
			semFlags = S_Store;
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Invalidations_inl.h
LINE: 11
SIGNATURE:
void onCodeModified(quint64 pa) 

BODY (preview):
void onCodeModified(quint64 pa) {
	// Invalidate by PA (hardware identity)
	PaKey paKey = PaKey::fromPA(pa);
	paDecodeCache().invalidate(paKey);
    pcDecodeCache().invalidateAll();  // conservative but safe
	// Note: PC cache may still have stale entries
	// They'll be detected as mismatches on next PA lookup
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Invalidations_inl.h
LINE: 24
SIGNATURE:
void onPageUnmapped(quint64 pfn) 

BODY (preview):
void onPageUnmapped(quint64 pfn) {
	// Must invalidate entire page worth of PA entries
	const quint64 pageBase = pfn << 13;  // 8KB page
	const quint64 pageEnd = pageBase + 0x2000;

	for (quint64 pa = pageBase; pa < pageEnd; pa += 4) {
		PaKey paKey = PaKey::fromPA(pa);
		paDecodeCache().invalidate(paKey);
	}
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Invalidations_inl.h
LINE: 39
SIGNATURE:
void onContextSwitch() 

BODY (preview):
void onContextSwitch() {
	// PC mappings change - flush PC cache
	pcDecodeCache().invalidateAll();

	// PA cache remains valid (physical identity unchanged)
}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-KeyIdenties.h
LINE: 30
SIGNATURE:
 static constexpr PcKey fromVA(quint64 va) noexcept

BODY (preview):
	[[nodiscard]] static constexpr PcKey fromVA(quint64 va) noexcept {
		return PcKey{ va >> 2 };  // 4-byte aligned
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-KeyIdenties.h
LINE: 61
SIGNATURE:
 static constexpr PaKey fromPA(quint64 pa) noexcept

BODY (preview):
	[[nodiscard]] static constexpr PaKey fromPA(quint64 pa) noexcept {
		return PaKey{ pa >> 2 };  // 4-byte aligned
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 50
SIGNATURE:
 const DecodedInstruction* find(const KeyType& key) noexcept

BODY (preview):
	[[nodiscard]] const DecodedInstruction* find(const KeyType& key) noexcept {
		for (;;) {
			const quint32 v0 = version.loadAcquire();
			if (v0 & 1u) continue;  // Writer active

			const quint64 occ = occupancy.loadRelaxed();

			for (unsigned i = 0; i < Ways; ++i) {
				if (!((occ >> i) & 1ULL)) continue;

				auto* entry = &entries[i];
				if (!entry->isValid()) continue;
				if (!(entry->key == key)) continue;

				// NEW: generation check

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 51
SIGNATURE:
 for(;;) 

BODY (preview):
		for (;;) {
			const quint32 v0 = version.loadAcquire();
			if (v0 & 1u) continue;  // Writer active

			const quint64 occ = occupancy.loadRelaxed();

			for (unsigned i = 0; i < Ways; ++i) {
				if (!((occ >> i) & 1ULL)) continue;

				auto* entry = &entries[i];
				if (!entry->isValid()) continue;
				if (!(entry->key == key)) continue;

				// NEW: generation check
				quint32 currentGen = parent->m_generation.loadRelaxed();

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 57
SIGNATURE:
	 for(unsigned i = 0; i < Ways; ++i) 

BODY (preview):
			for (unsigned i = 0; i < Ways; ++i) {
				if (!((occ >> i) & 1ULL)) continue;

				auto* entry = &entries[i];
				if (!entry->isValid()) continue;
				if (!(entry->key == key)) continue;

				// NEW: generation check
				quint32 currentGen = parent->m_generation.loadRelaxed();
				if (entry->generation != currentGen) continue;

				const quint32 v1 = version.loadAcquire();
				if (v0 == v1) {
					// Hot path hit
					if (entry->accessCount < 255) {

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 69
SIGNATURE:
		 if(v0 == v1) 

BODY (preview):
				if (v0 == v1) {
					// Hot path hit
					if (entry->accessCount < 255) {
						entry->accessCount++;
					}
					return &entry->decoded;
				}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 71
SIGNATURE:
			 if(entry->accessCount < 255) 

BODY (preview):
					if (entry->accessCount < 255) {
						entry->accessCount++;
					}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 87
SIGNATURE:
	bool insert(const KeyType& key, const DecodedInstruction& decoded) noexcept

BODY (preview):
	bool insert(const KeyType& key, const DecodedInstruction& decoded) noexcept {
		unsigned slot;
		if (!tryClaimSlot(slot)) {
			return false;
		}

		beginWrite();
		entries[slot].key = key;
		entries[slot].decoded = decoded;
		entries[slot].accessCount = 0;
		entries[slot].valid = true;
		entries[slot].generation = parent->m_generation.loadRelaxed();
		endWrite();

		return true;

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 108
SIGNATURE:
	void invalidateKey(const KeyType& key) noexcept

BODY (preview):
	void invalidateKey(const KeyType& key) noexcept {
		beginWrite();
		const quint64 occ = occupancy.loadRelaxed();

		for (unsigned i = 0; i < Ways; ++i) {
			if (!((occ >> i) & 1ULL)) continue;
			if (entries[i].key == key) {
				invalidateSlot(i);
			}
		}
		endWrite();
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 112
SIGNATURE:
 for(unsigned i = 0; i < Ways; ++i) 

BODY (preview):
		for (unsigned i = 0; i < Ways; ++i) {
			if (!((occ >> i) & 1ULL)) continue;
			if (entries[i].key == key) {
				invalidateSlot(i);
			}
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 114
SIGNATURE:
	 if(entries[i].key == key) 

BODY (preview):
			if (entries[i].key == key) {
				invalidateSlot(i);
			}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 122
SIGNATURE:
	bool tryClaimSlot(unsigned& slot) noexcept

BODY (preview):
	bool tryClaimSlot(unsigned& slot) noexcept {
		for (;;) {
			const quint64 cur = occupancy.loadRelaxed();
			const quint64 used = cur & FULL_MASK;

			if (used == FULL_MASK) {
				slot = findLRU();
				return true;
			}

			const quint64 freeBits = (~used) & FULL_MASK;
			const int bit = qCountTrailingZeroBits(freeBits);
			const quint64 want = cur | (1ULL << bit);

			if (occupancy.testAndSetRelaxed(cur, want)) {

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 123
SIGNATURE:
 for(;;) 

BODY (preview):
		for (;;) {
			const quint64 cur = occupancy.loadRelaxed();
			const quint64 used = cur & FULL_MASK;

			if (used == FULL_MASK) {
				slot = findLRU();
				return true;
			}

			const quint64 freeBits = (~used) & FULL_MASK;
			const int bit = qCountTrailingZeroBits(freeBits);
			const quint64 want = cur | (1ULL << bit);

			if (occupancy.testAndSetRelaxed(cur, want)) {
				slot = static_cast<unsigned>(bit);

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 127
SIGNATURE:
	 if(used == FULL_MASK) 

BODY (preview):
			if (used == FULL_MASK) {
				slot = findLRU();
				return true;
			}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 147
SIGNATURE:
 for(unsigned i = 0; i < Ways; ++i) 

BODY (preview):
		for (unsigned i = 0; i < Ways; ++i) {
			if (entries[i].locked) continue;
			if (entries[i].accessCount < minCount) {
				minCount = entries[i].accessCount;
				lru = i;
			}
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 149
SIGNATURE:
	 if(entries[i].accessCount < minCount) 

BODY (preview):
			if (entries[i].accessCount < minCount) {
				minCount = entries[i].accessCount;
				lru = i;
			}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 157
SIGNATURE:
	void invalidateSlot(unsigned slot) noexcept

BODY (preview):
	void invalidateSlot(unsigned slot) noexcept {
		entries[slot].valid = false;
		const quint64 mask = ~(1ULL << slot);
		quint64 cur;
		do {
			cur = occupancy.loadRelaxed();
		} while (!occupancy.testAndSetRelaxed(cur, cur & mask));
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 166
SIGNATURE:
	inline void beginWrite() noexcept

BODY (preview):
	inline void beginWrite() noexcept { version.fetchAndAddRelease(1); }
	inline void endWrite() noexcept { version.fetchAndAddRelease(1); }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 167
SIGNATURE:
	inline void endWrite() noexcept

BODY (preview):
	inline void endWrite() noexcept { version.fetchAndAddRelease(1); }
};

// ============================================================================
// Global Decode Cache Manager
// ============================================================================

template<typename KeyType, unsigned Ways = 4, unsigned Buckets = 4096>
class DecodeCache {

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 184
SIGNATURE:
 for(unsigned i = 0; i < Buckets; ++i) 

BODY (preview):
		for (unsigned i = 0; i < Buckets; ++i) {
			m_buckets[i].parent = this;     // 
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 193
SIGNATURE:
 const DecodedInstruction* lookup(const KeyType& key) noexcept

BODY (preview):
	[[nodiscard]] const DecodedInstruction* lookup(const KeyType& key) noexcept {
		const unsigned idx = bucketIndex(key);
		return m_buckets[idx].find(key);
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 202
SIGNATURE:
	bool insert(const KeyType& key, const DecodedInstruction& decoded) noexcept

BODY (preview):
	bool insert(const KeyType& key, const DecodedInstruction& decoded) noexcept {
		const unsigned idx = bucketIndex(key);
		return m_buckets[idx].insert(key, decoded);
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 211
SIGNATURE:
	void invalidate(const KeyType& key) noexcept

BODY (preview):
	void invalidate(const KeyType& key) noexcept {
		const unsigned idx = bucketIndex(key);
		m_buckets[idx].invalidateKey(key);
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 216
SIGNATURE:
	void invalidateAll() noexcept

BODY (preview):
	void invalidateAll() noexcept {
		m_generation.fetchAndAddRelaxed(1);
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain-Parameter-DecodeCache.h
LINE: 221
SIGNATURE:
	static unsigned bucketIndex(const KeyType& key) noexcept

BODY (preview):
	static unsigned bucketIndex(const KeyType& key) noexcept {
		return static_cast<unsigned>(key.hash()) & (Buckets - 1);
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain_SemanicExamples.h
LINE: 196
SIGNATURE:
       if(taken) 

BODY (preview):
        if (taken) {
            ctx.setPC(target);
        }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iGrain_SemanicExamples.h
LINE: 285
SIGNATURE:
   switch(sizeBytes) 

BODY (preview):
    switch (sizeBytes) {
        case 1: return static_cast<quint64>(static_cast<qint8>(value));
        case 2: return static_cast<quint64>(static_cast<qint16>(value));
        case 4: return static_cast<quint64>(static_cast<qint32>(value));
        case 8: return value;
        default: return value;
    }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\InstructionGrain.h
LINE: 94
SIGNATURE:
     AXP_FLATTEN void setMemoryFormat() noexcept

BODY (preview):
//     AXP_FLATTEN void setMemoryFormat() noexcept {
//         flags |= GF_MemoryFormat;
//     }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\InstructionGrain.h
LINE: 98
SIGNATURE:
     AXP_FLATTEN void setBranchFormat() noexcept

BODY (preview):
//     AXP_FLATTEN void setBranchFormat() noexcept {
//         flags |= GF_BranchFormat;
//     }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\InstructionGrain.h
LINE: 102
SIGNATURE:
     AXP_FLATTEN void setOperateFormat() noexcept

BODY (preview):
//     AXP_FLATTEN void setOperateFormat() noexcept {
//         flags |= GF_OperateFormat;
//     }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\InstructionGrain.h
LINE: 106
SIGNATURE:
     AXP_FLATTEN void setPALcodeFormat() noexcept

BODY (preview):
//     AXP_FLATTEN void setPALcodeFormat() noexcept {
//         flags |= GF_PALcodeFormat;
//     }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\InstructionGrain.h
LINE: 110
SIGNATURE:
    AXP_FLATTEN void setCanDualIssue() noexcept

BODY (preview):
    AXP_FLATTEN void setCanDualIssue() noexcept {
        flags |= GF_CanDualIssue;
    }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\InstructionGrain.h
LINE: 114
SIGNATURE:
    AXP_FLATTEN void setNeedsStall() noexcept

BODY (preview):
    AXP_FLATTEN void setNeedsStall() noexcept {
        flags |= GF_NeedsStall;
    }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\InstructionGrainRegistry.h
LINE: 65
SIGNATURE:
 if(platform != GrainPlatform::NONE) 

BODY (preview):
		if (platform != GrainPlatform::NONE) {
			key = makeGrainKey(opcode, func, GrainPlatform::NONE);
			it = m_table.find(key);
			if (it != m_table.end()) {
				return it.value();
			}
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpam-Ev6InstructionCache.h
LINE: 9
SIGNATURE:
		: m_ispam(cpuCount) 

BODY (preview):
		: m_ispam(cpuCount) {
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpam-Ev6InstructionCache.h
LINE: 46
SIGNATURE:
	void dispatchToBox(const InstructionGrain_iSpam& grain) 

BODY (preview):
	void dispatchToBox(const InstructionGrain_iSpam& grain) {
		switch (grain.targetBox) {
		case ExecutionBox::EBox:
			m_ebox.enqueue(grain);
			break;
		case ExecutionBox::FBox:
			m_fbox.enqueue(grain);
			break;
		case ExecutionBox::MBox:
			m_mbox.enqueue(grain);
			break;
		default:
			break;
		}
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpam-Ev6InstructionCache.h
LINE: 47
SIGNATURE:
 switch(grain.targetBox) 

BODY (preview):
		switch (grain.targetBox) {
		case ExecutionBox::EBox:
			m_ebox.enqueue(grain);
			break;
		case ExecutionBox::FBox:
			m_fbox.enqueue(grain);
			break;
		case ExecutionBox::MBox:
			m_mbox.enqueue(grain);
			break;
		default:
			break;
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpam-Ev6InstructionCache.h
LINE: 66
SIGNATURE:
	void onPageModified(CPUIdType cpuId, quint64 pa) 

BODY (preview):
	void onPageModified(CPUIdType cpuId, quint64 pa) {
		m_ispam.invalidateByPA(cpuId, pa);
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 29
SIGNATURE:
 ISpamEntry* find(const ISpamTag& tag) noexcept

BODY (preview):
	[[nodiscard]] ISpamEntry* find(const ISpamTag& tag) noexcept {
		for (;;) {
			const quint32 v0 = version.loadAcquire();
			if (v0 & 1u) continue;  // Writer active

			const quint64 occ = occupancy.loadRelaxed();

			for (unsigned i = 0; i < Ways; ++i) {
				if (!((occ >> i) & 1ULL)) continue;

				ISpamEntry* e = &entries[i];
				if (!e->isValid()) continue;
				if (!(e->tag == tag)) continue;

				const quint32 v1 = version.loadAcquire();

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 30
SIGNATURE:
 for(;;) 

BODY (preview):
		for (;;) {
			const quint32 v0 = version.loadAcquire();
			if (v0 & 1u) continue;  // Writer active

			const quint64 occ = occupancy.loadRelaxed();

			for (unsigned i = 0; i < Ways; ++i) {
				if (!((occ >> i) & 1ULL)) continue;

				ISpamEntry* e = &entries[i];
				if (!e->isValid()) continue;
				if (!(e->tag == tag)) continue;

				const quint32 v1 = version.loadAcquire();
				if (v0 == v1) {

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 36
SIGNATURE:
	 for(unsigned i = 0; i < Ways; ++i) 

BODY (preview):
			for (unsigned i = 0; i < Ways; ++i) {
				if (!((occ >> i) & 1ULL)) continue;

				ISpamEntry* e = &entries[i];
				if (!e->isValid()) continue;
				if (!(e->tag == tag)) continue;

				const quint32 v1 = version.loadAcquire();
				if (v0 == v1) {
					// Hot path: increment access count for LRU
					if (e->accessCount < 255) {
						e->accessCount++;
					}
					return e;
				}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 44
SIGNATURE:
		 if(v0 == v1) 

BODY (preview):
				if (v0 == v1) {
					// Hot path: increment access count for LRU
					if (e->accessCount < 255) {
						e->accessCount++;
					}
					return e;
				}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 46
SIGNATURE:
			 if(e->accessCount < 255) 

BODY (preview):
					if (e->accessCount < 255) {
						e->accessCount++;
					}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 63
SIGNATURE:
	bool insert(const ISpamEntry& entry) noexcept

BODY (preview):
	bool insert(const ISpamEntry& entry) noexcept {
		unsigned slot;
		if (!tryClaimSlot(slot)) {
			return false;  // Cache full
		}

		beginWrite();
		entries[slot] = entry;
		entries[slot].valid = true;
		endWrite();

		return true;
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 81
SIGNATURE:
	void invalidateByPC(quint64 pc) noexcept

BODY (preview):
	void invalidateByPC(quint64 pc) noexcept {
		beginWrite();
		const quint64 occ = occupancy.loadRelaxed();

		for (unsigned i = 0; i < Ways; ++i) {
			if (!((occ >> i) & 1ULL)) continue;
			if (entries[i].tag.pc == pc) {
				invalidateSlot(i);
			}
		}
		endWrite();
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 85
SIGNATURE:
 for(unsigned i = 0; i < Ways; ++i) 

BODY (preview):
		for (unsigned i = 0; i < Ways; ++i) {
			if (!((occ >> i) & 1ULL)) continue;
			if (entries[i].tag.pc == pc) {
				invalidateSlot(i);
			}
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 87
SIGNATURE:
	 if(entries[i].tag.pc == pc) 

BODY (preview):
			if (entries[i].tag.pc == pc) {
				invalidateSlot(i);
			}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 94
SIGNATURE:
	void invalidateByPA(quint64 pa) noexcept

BODY (preview):
	void invalidateByPA(quint64 pa) noexcept {
		beginWrite();
		const quint64 occ = occupancy.loadRelaxed();

		for (unsigned i = 0; i < Ways; ++i) {
			if (!((occ >> i) & 1ULL)) continue;
			if (entries[i].tag.pa == pa) {
				invalidateSlot(i);
			}
		}
		endWrite();
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 98
SIGNATURE:
 for(unsigned i = 0; i < Ways; ++i) 

BODY (preview):
		for (unsigned i = 0; i < Ways; ++i) {
			if (!((occ >> i) & 1ULL)) continue;
			if (entries[i].tag.pa == pa) {
				invalidateSlot(i);
			}
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 100
SIGNATURE:
	 if(entries[i].tag.pa == pa) 

BODY (preview):
			if (entries[i].tag.pa == pa) {
				invalidateSlot(i);
			}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 108
SIGNATURE:
	bool tryClaimSlot(unsigned& slot) noexcept

BODY (preview):
	bool tryClaimSlot(unsigned& slot) noexcept {
		for (;;) {
			const quint64 cur = occupancy.loadRelaxed();
			const quint64 used = cur & FULL_MASK;

			if (used == FULL_MASK) {
				// Evict LRU entry
				slot = findLRU();
				return true;
			}

			const quint64 freeBits = (~used) & FULL_MASK;
			const int bit = qCountTrailingZeroBits(freeBits);
			const quint64 want = cur | (1ULL << bit);


================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 109
SIGNATURE:
 for(;;) 

BODY (preview):
		for (;;) {
			const quint64 cur = occupancy.loadRelaxed();
			const quint64 used = cur & FULL_MASK;

			if (used == FULL_MASK) {
				// Evict LRU entry
				slot = findLRU();
				return true;
			}

			const quint64 freeBits = (~used) & FULL_MASK;
			const int bit = qCountTrailingZeroBits(freeBits);
			const quint64 want = cur | (1ULL << bit);

			if (occupancy.testAndSetRelaxed(cur, want)) {

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 113
SIGNATURE:
	 if(used == FULL_MASK) 

BODY (preview):
			if (used == FULL_MASK) {
				// Evict LRU entry
				slot = findLRU();
				return true;
			}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 134
SIGNATURE:
 for(unsigned i = 0; i < Ways; ++i) 

BODY (preview):
		for (unsigned i = 0; i < Ways; ++i) {
			if (entries[i].locked) continue;
			if (entries[i].accessCount < minCount) {
				minCount = entries[i].accessCount;
				lru = i;
			}
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 136
SIGNATURE:
	 if(entries[i].accessCount < minCount) 

BODY (preview):
			if (entries[i].accessCount < minCount) {
				minCount = entries[i].accessCount;
				lru = i;
			}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 144
SIGNATURE:
	void invalidateSlot(unsigned slot) noexcept

BODY (preview):
	void invalidateSlot(unsigned slot) noexcept {
		entries[slot].valid = false;
		const quint64 mask = ~(1ULL << slot);
		quint64 cur;
		do {
			cur = occupancy.loadRelaxed();
		} while (!occupancy.testAndSetRelaxed(cur, cur & mask));
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 153
SIGNATURE:
	inline void beginWrite() noexcept

BODY (preview):
	inline void beginWrite() noexcept { version.fetchAndAddRelease(1); }
	inline void endWrite() noexcept { version.fetchAndAddRelease(1); }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpamBucket.h
LINE: 154
SIGNATURE:
	inline void endWrite() noexcept

BODY (preview):
	inline void endWrite() noexcept { version.fetchAndAddRelease(1); }
};

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpam_Manager.h
LINE: 16
SIGNATURE:
 : m_cpuCount(cpuCount) 

BODY (preview):
	explicit ISpamManager(int cpuCount) : m_cpuCount(cpuCount) {
		m_buckets.resize(cpuCount);
		for (int i = 0; i < cpuCount; ++i) {
			m_buckets[i].resize(Buckets);
		}
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpam_Manager.h
LINE: 18
SIGNATURE:
 for(int i = 0; i < cpuCount; ++i) 

BODY (preview):
		for (int i = 0; i < cpuCount; ++i) {
			m_buckets[i].resize(Buckets);
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpam_Manager.h
LINE: 66
SIGNATURE:
	void invalidateByPC(CPUIdType cpuId, quint64 pc) noexcept

BODY (preview):
	void invalidateByPC(CPUIdType cpuId, quint64 pc) noexcept {
		// Invalidate all buckets that might contain this PC
		for (unsigned i = 0; i < Buckets; ++i) {
			m_buckets[cpuId][i].invalidateByPC(pc);
		}
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpam_Manager.h
LINE: 68
SIGNATURE:
 for(unsigned i = 0; i < Buckets; ++i) 

BODY (preview):
		for (unsigned i = 0; i < Buckets; ++i) {
			m_buckets[cpuId][i].invalidateByPC(pc);
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpam_Manager.h
LINE: 73
SIGNATURE:
	void invalidateByPA(CPUIdType cpuId, quint64 pa) noexcept

BODY (preview):
	void invalidateByPA(CPUIdType cpuId, quint64 pa) noexcept {
		// Called when a page is unmapped or modified
		for (unsigned i = 0; i < Buckets; ++i) {
			m_buckets[cpuId][i].invalidateByPA(pa);
		}
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpam_Manager.h
LINE: 75
SIGNATURE:
 for(unsigned i = 0; i < Buckets; ++i) 

BODY (preview):
		for (unsigned i = 0; i < Buckets; ++i) {
			m_buckets[cpuId][i].invalidateByPA(pa);
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpam_Manager.h
LINE: 80
SIGNATURE:
	void invalidateAll(CPUIdType cpuId) noexcept

BODY (preview):
	void invalidateAll(CPUIdType cpuId) noexcept {
		m_generation[cpuId].fetchAndAddRelaxed(1);
	}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\iSpam_Manager.h
LINE: 85
SIGNATURE:
	static unsigned bucketIndex(const ISpamTag& tag) noexcept

BODY (preview):
	static unsigned bucketIndex(const ISpamTag& tag) noexcept {
		return static_cast<unsigned>(tag.hash()) & (Buckets - 1);
	}

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 92
SIGNATURE:
		void setRealm(Realm r) noexcept

BODY (preview):
		void setRealm(Realm r) noexcept {
		m_alphaPipeline.setRealm(r);
	}

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 115
SIGNATURE:
	MBox* getMBox() noexcept

BODY (preview):
	MBox* getMBox() noexcept { return m_mBox; }
	EBox* getEBox() noexcept { return m_eBox; }

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 116
SIGNATURE:
	EBox* getEBox() noexcept

BODY (preview):
	EBox* getEBox() noexcept { return m_eBox; }
	FBox* getFBox() noexcept { return m_fBox; }

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 117
SIGNATURE:
	FBox* getFBox() noexcept

BODY (preview):
	FBox* getFBox() noexcept { return m_fBox; }
	CBox* getCBox() noexcept { return m_cBox; }

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 118
SIGNATURE:
	CBox* getCBox() noexcept

BODY (preview):
	CBox* getCBox() noexcept { return m_cBox; }


================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 131
SIGNATURE:
	AXP_FLATTEN void stepPipeLine() noexcept

BODY (preview):
	AXP_FLATTEN void stepPipeLine() noexcept {
		// 1) Produce a new fetch result from current PC
		FetchResult fr = fetchNext();

		// 2) Supply it to AlphaPipeline IF stage (even if invalid)
		m_alphaPipeline.supplyFetchResult(fr);

		// 3) Step the pipeline (WB, MEM, EX, IS, DE, IF, then advance ring)
		m_alphaPipeline.step();
	}

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 182
SIGNATURE:
	 if(predictedTaken) 

BODY (preview):
			if (predictedTaken) {
				predictedTarget =
					m_cBox->getPredictedBranchTarget_IBox(di.pc, disp);
			}

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 280
SIGNATURE:
	bool fetch(DecodedInstruction& di) 

BODY (preview):
	bool fetch(DecodedInstruction& di) {
		if (m_stalled) return false;
		return fetchAndDecode(di);
	}

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 303
SIGNATURE:
 if(tr != TranslationResult::Ok) 

BODY (preview):
		if (tr != TranslationResult::Ok) {
			// Convert directly to architectural trap
			TrapCode trap = translationResultToTrap(tr);

			// Raise trap into the CPU context (delegates to FaultDispatcher)
			m_ctx->raiseTrap(trap, pc);
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 318
SIGNATURE:
 if(st != SafeMemory::Status::Ok) 

BODY (preview):
		if (st != SafeMemory::Status::Ok) {
			// Instruction access faults are different PAL vectors from ITB faults
			m_ctx->queueInstructionAccessFault(pc, st);
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 394
SIGNATURE:
  if(di.grain != nullptr) 

BODY (preview):
// 		if (di.grain != nullptr) {
// 			// Extract function code from the grain itself
// 			di.funcCode = di.grain->functionCode();
// 			di.platform = di.grain->platform();
// 			di.box = di.grain->box;
// 		}

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 423
SIGNATURE:
 if(di.grain == nullptr) 

BODY (preview):
		if (di.grain == nullptr) {
			raiseException(TrapCode::ILLEGAL_INSTRUCTION, di.pc);
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 461
SIGNATURE:
	void tick() 

BODY (preview):
	void tick() {
		// Process pending loads/stores

	}

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 492
SIGNATURE:
 if(di1.rc == di2.ra || di1.rc == di2.rb) 

BODY (preview):
		if (di1.rc == di2.ra || di1.rc == di2.rb) {
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 497
SIGNATURE:
 if(di1.rc == di2.rc && di1.rc != 31) 

BODY (preview):
		if (di1.rc == di2.rc && di1.rc != 31) {
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 528
SIGNATURE:
 if(isFloat) 

BODY (preview):
		if (isFloat) {
			m_fpRegisterDirty |= mask;
		}

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 541
SIGNATURE:
 if(isFloat) 

BODY (preview):
		if (isFloat) {
			m_fpRegisterDirty &= mask;
		}

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 554
SIGNATURE:
	AXP_FLATTEN void setPC(quint64 pc) 

BODY (preview):
	AXP_FLATTEN void setPC(quint64 pc) { setPC_Active(m_cpuId, pc); }			// IPR::pc setter
	AXP_FLATTEN void advancePC(quint64 pc, quint64 offset = 4) { setPC_Active(m_cpuId, pc += offset); }

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 555
SIGNATURE:
	AXP_FLATTEN void advancePC(quint64 pc, quint64 offset = 4) 

BODY (preview):
	AXP_FLATTEN void advancePC(quint64 pc, quint64 offset = 4) { setPC_Active(m_cpuId, pc += offset); }
	AXP_FLATTEN quint64 getNextPC() const noexcept { return getPC() + 4; }

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 563
SIGNATURE:
	void stall() 

BODY (preview):
	void stall() { m_stalled = true; }
	void unstall() { m_stalled = false; }

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 564
SIGNATURE:
	void unstall() 

BODY (preview):
	void unstall() { m_stalled = false; }
	bool isStalled() const { return m_stalled; }

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 680
SIGNATURE:
	void queueITBFault(quint64 pc, TranslationResult result) 

BODY (preview):
	void queueITBFault(quint64 pc, TranslationResult result) {
		PendingEvent ev{};
		ev.kind = PendingEventKind::TRAP_SYNC;
		ev.faultVA = pc;

		switch (result) {
		case TranslationResult::TlbMiss:
			ev.exceptionClass = ExceptionClass::ITB_MISS;
			ev.palVectorId = PalVectorId::ITB_MISS;
			break;
		case TranslationResult::PermissionDenied:
		case TranslationResult::NonCanonical:
			ev.exceptionClass = ExceptionClass::ITB_ACV;
			ev.palVectorId = PalVectorId::IACV;
			break;

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 685
SIGNATURE:
 switch(result) 

BODY (preview):
		switch (result) {
		case TranslationResult::TlbMiss:
			ev.exceptionClass = ExceptionClass::ITB_MISS;
			ev.palVectorId = PalVectorId::ITB_MISS;
			break;
		case TranslationResult::PermissionDenied:
		case TranslationResult::NonCanonical:
			ev.exceptionClass = ExceptionClass::ITB_ACV;
			ev.palVectorId = PalVectorId::IACV;
			break;
		default:
			ev.exceptionClass = ExceptionClass::ITB_ACV;
			ev.palVectorId = PalVectorId::IACV;
			break;
		}

================================================================================
FILE: z:\EmulatRApp\IBoxLib\iBox_Base.h
LINE: 722
SIGNATURE:
	AXP_FLATTEN void invalidateIGrainCache() noexcept

BODY (preview):
	AXP_FLATTEN void invalidateIGrainCache() noexcept { /* NOOP */ }


================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 34
SIGNATURE:
inline TrapCode translationResultToTrap(TranslationResult result) 

BODY (preview):
inline TrapCode translationResultToTrap(TranslationResult result) {
	switch (result) {
	case TranslationResult::TlbMiss:
		return TrapCode::ITB_MISS;
	case TranslationResult::PermissionDenied:
		return TrapCode::ITB_ACCESS_VIOLATION;
	case TranslationResult::NonCanonical:
		return TrapCode::ITB_FAULT;
	case TranslationResult::Misaligned:
		return TrapCode::ITB_MISALIGN_FAULT;
	default:
		return TrapCode::ITB_FAULT;
	}
}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 84
SIGNATURE:
		quint64 readIntReg(CPUIdType cpuId, quint8 regNum) noexcept

BODY (preview):
		quint64 readIntReg(CPUIdType cpuId, quint8 regNum) noexcept {
		if (regNum == 31) return 0; // R31 is always zero

		// Check if we're in PAL mode
		bool inPalMode = getActivePalModeStatus(cpuId);

		if (inPalMode) {
			quint64 i_ctl_t = globalIPRHot(m_cpuId).i_ctl;
			// Get SDE bits from I_CTL IPR (you'll need to implement this)
			bool sde1 = ictl_isShadowGroup0Enabled(i_ctl_t);
			bool sde0 = ictl_isShadowGroup1Enabled(i_ctl_t);

			// Check Bank 1 overlay (SDE<1>)
			if (sde1 && isPalShadowGroup1Reg(regNum)) {
				quint8 idx = palShadowGroup1Index(regNum);

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 90
SIGNATURE:
 if(inPalMode) 

BODY (preview):
		if (inPalMode) {
			quint64 i_ctl_t = globalIPRHot(m_cpuId).i_ctl;
			// Get SDE bits from I_CTL IPR (you'll need to implement this)
			bool sde1 = ictl_isShadowGroup0Enabled(i_ctl_t);
			bool sde0 = ictl_isShadowGroup1Enabled(i_ctl_t);

			// Check Bank 1 overlay (SDE<1>)
			if (sde1 && isPalShadowGroup1Reg(regNum)) {
				quint8 idx = palShadowGroup1Index(regNum);
				return getHWPCB_Active(cpuId).getActive_PalShadowBank1(idx);
			}

			// Check Bank 0 overlay (SDE<0>)
			if (sde0 && isPalShadowGroup0Reg(regNum)) {
				quint8 idx = palShadowGroup0Index(regNum);

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 115
SIGNATURE:
		void writeIntReg(CPUIdType cpuId, quint8 regNum, quint64 value) noexcept

BODY (preview):
		void writeIntReg(CPUIdType cpuId, quint8 regNum, quint64 value) noexcept {
		if (regNum == 31) return; // R31 writes are ignored

		bool inPalMode = getActivePalModeStatus(cpuId);

		if (inPalMode) {
			quint64 i_ctl_t = globalIPRHot(m_cpuId).i_ctl;
			bool sde1 = ictl_isShadowGroup1Enabled(i_ctl_t);
			bool sde0 = ictl_isShadowGroup0Enabled(i_ctl_t);

			// Check Bank 1 overlay (SDE<1>)
			if (sde1 && isPalShadowGroup1Reg(regNum)) {
				quint8 idx = palShadowGroup1Index(regNum);
				getHWPCB_Active(cpuId).setActive_PalShadowBank1(idx, value);
				return;

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 120
SIGNATURE:
 if(inPalMode) 

BODY (preview):
		if (inPalMode) {
			quint64 i_ctl_t = globalIPRHot(m_cpuId).i_ctl;
			bool sde1 = ictl_isShadowGroup1Enabled(i_ctl_t);
			bool sde0 = ictl_isShadowGroup0Enabled(i_ctl_t);

			// Check Bank 1 overlay (SDE<1>)
			if (sde1 && isPalShadowGroup1Reg(regNum)) {
				quint8 idx = palShadowGroup1Index(regNum);
				getHWPCB_Active(cpuId).setActive_PalShadowBank1(idx, value);
				return;
			}

			// Check Bank 0 overlay (SDE<0>)
			if (sde0 && isPalShadowGroup0Reg(regNum)) {
				quint8 idx = palShadowGroup0Index(regNum);

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 237
SIGNATURE:
		void executeSTF(PipelineSlot& slot) noexcept

BODY (preview):
		void executeSTF(PipelineSlot& slot) noexcept { /* TODO */ }


================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 240
SIGNATURE:
		void executeSTG(PipelineSlot& slot) noexcept

BODY (preview):
		void executeSTG(PipelineSlot& slot) noexcept { /* TODO */ }


================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 243
SIGNATURE:
		void executeSTS(PipelineSlot& slot) noexcept

BODY (preview):
		void executeSTS(PipelineSlot& slot) noexcept { /* TODO */ }


================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 246
SIGNATURE:
		void executeSTT(PipelineSlot& slot) noexcept

BODY (preview):
		void executeSTT(PipelineSlot& slot) noexcept { /* TODO */ }


================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 300
SIGNATURE:
 if(!allowed) 

BODY (preview):
		if (!allowed) {
			disp.setPendingEvent(makeAccessViolationFault(va));
			return;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 358
SIGNATURE:
 if(!allowed) 

BODY (preview):
		if (!allowed) {
			disp.setPendingEvent(makeAccessViolationFault(va));
			return;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 414
SIGNATURE:
 if(!allowed) 

BODY (preview):
		if (!allowed) {
			disp.setPendingEvent(makeAccessViolationFault(va));
			return;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 465
SIGNATURE:
 if(!allowed) 

BODY (preview):
		if (!allowed) {
			disp.setPendingEvent(makeAccessViolationFault(va));
			return;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 530
SIGNATURE:
 if(!allowed) 

BODY (preview):
		if (!allowed) {
			disp.setPendingEvent(makeAccessViolationFault(va));
			return;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 588
SIGNATURE:
 if(!allowed) 

BODY (preview):
		if (!allowed) {
			disp.setPendingEvent(makeAccessViolationFault(va));
			return;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 643
SIGNATURE:
 if(!allowed) 

BODY (preview):
		if (!allowed) {
			disp.setPendingEvent(makeAccessViolationFault(va));
			return;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 694
SIGNATURE:
 if(!allowed) 

BODY (preview):
		if (!allowed) {
			disp.setPendingEvent(makeAccessViolationFault(va));
			return;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 758
SIGNATURE:
 if(!allowed) 

BODY (preview):
		if (!allowed) {
			disp.setPendingEvent(makeAccessViolationFault(va));
			return;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 823
SIGNATURE:
 if(!allowed) 

BODY (preview):
		if (!allowed) {
			disp.setPendingEvent(makeAccessViolationFault(va));
			return;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 907
SIGNATURE:
 if(!allowed) 

BODY (preview):
		if (!allowed) {
			global_ReservationManager().clearReservation(m_cpuId);
			disp.setPendingEvent(makeAccessViolationFault(va));
			slot.needsWriteback = false;
			return;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 922
SIGNATURE:
 if(!hasRes) 

BODY (preview):
		if (!hasRes) {
			// Reservation lost -> STQ_C fails *without* fault.
			// Store not performed; RA gets 0.
			slot.resultInt = 0;
			slot.needsWriteback = true;   // WB stage writes the 0 to RA
			// No store; reservation already gone or invalid.
			return;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 997
SIGNATURE:
 if(!allowed) 

BODY (preview):
		if (!allowed) {
			global_ReservationManager().clearReservation(m_cpuId);
			disp.setPendingEvent(makeAccessViolationFault(va));
			slot.needsWriteback = false;
			return;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 1010
SIGNATURE:
 if(!hasRes) 

BODY (preview):
		if (!hasRes) {
			// Reservation lost -> STQ_C fails *without* fault.
			// Store not performed; RA gets 0.
			slot.resultInt = 0;
			slot.needsWriteback = true;   // WB stage writes the 0 to RA
			// No store; reservation already gone or invalid.
			return;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 1127
SIGNATURE:
	AXP_FLATTEN void enterPal() noexcept

BODY (preview):
	AXP_FLATTEN void enterPal() noexcept {
		globalIPRHot(m_cpuId).setInPalMode(true);
		m_isInPalMode = true;  // locally cache for performance only
	}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 1131
SIGNATURE:
	AXP_FLATTEN void exitPal() noexcept

BODY (preview):
	AXP_FLATTEN void exitPal() noexcept {
		globalIPRHot(m_cpuId).setInPalMode(false); // this function also demotes processor mode to user.
		m_isInPalMode = false;  // locally cache for performance only
	}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 1168
SIGNATURE:
 if(entry->flags & PalVectorEntry::MODIFIES_IPL) 

BODY (preview):
		if (entry->flags & PalVectorEntry::MODIFIES_IPL) {
			/*		setCurrentIPL(entry->targetIPL);*/
			ipl.setCPUIpl(m_cpuId, entry->targetIPL);
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 1256
SIGNATURE:
 switch(func) 

BODY (preview):
		switch (func) {
			// Privileged CALL_PAL operations (0x00-0x3F)
		case 0x00: executeHALT(di); break;
		case 0x01: executeCFLUSH(di); break;
		case 0x02: executeDRAINA(di); break;
		case 0x06: executeMFPR_ASN(di); break;
		case 0x07: executeMTPR_ASN(di); break;
		case 0x09: executeCSERVE(di); break;
		case 0x0D: executeSWPPAL(di); break;
		case 0x10: executeRDMCES(di); break;
		case 0x11: executeWRMCES(di); break;

			// Unprivileged CALL_PAL operations (0x80-0xBF)
		case 0x80: executeBPT(di); break;
		case 0x81: executeBUGCHK(di); break;

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 1325
SIGNATURE:
 if(newAsn != oldAsn) 

BODY (preview):
		if (newAsn != oldAsn) {
			handleASNChange(oldAsn, newAsn);
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 1751
SIGNATURE:
 if(newAstLevel > oldAstLevel) 

BODY (preview):
		if (newAstLevel > oldAstLevel) {
			handleASTRaise(oldAstLevel, newAstLevel);  // Schedule AST trap
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 1754
SIGNATURE:
		else if(newAstLevel < oldAstLevel) 

BODY (preview):
		else if (newAstLevel < oldAstLevel) {
			handleASTLower(oldAstLevel, newAstLevel);  // Clear pending ASTs
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 1786
SIGNATURE:
 if(currentMode == 0) 

BODY (preview):
		if (currentMode == 0) {
			// In KERNEL mode: AST will be delivered on next REI to user mode
			// Just mark it pending
			iprs.sirr |= (1ULL << newLevel);  // Set bit in Software Interrupt Request

			// Optional: Set AST pending flag
			// iprs.flags |= IPR_FLAG_AST_PENDING;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 1817
SIGNATURE:
 for(quint64 level = newLevel + 1; level <= oldLevel; ++level) 

BODY (preview):
		for (quint64 level = newLevel + 1; level <= oldLevel; ++level) {
			iprs.sirr &= ~(1ULL << level);  // Clear bit in Software Interrupt Request
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 1866
SIGNATURE:
 if(currentMode == 0 && targetMode != 0) 

BODY (preview):
		if (currentMode == 0 && targetMode != 0) {
			// We're currently in KERNEL, returning to USER/EXEC/SUPER
			// This is the ONLY time AST can be delivered!

			if (iprs.astrr > 0) {
				// AST pending - deliver it instead of returning
				scheduleAST(iprs.astrr);
				return;
			}
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 1870
SIGNATURE:
	 if(iprs.astrr > 0) 

BODY (preview):
			if (iprs.astrr > 0) {
				// AST pending - deliver it instead of returning
				scheduleAST(iprs.astrr);
				return;
			}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 1912
SIGNATURE:
 if(tr != TranslationResult::Ok) 

BODY (preview):
		if (tr != TranslationResult::Ok) {
			raiseTranslationFault(va, tr);
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 1925
SIGNATURE:
 if(st != SafeMemory::Status::Ok) 

BODY (preview):
		if (st != SafeMemory::Status::Ok) {
			m_ctx->raiseTrap(translateSafeMemStatusToTrap(st), va);
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 1950
SIGNATURE:
 if(st != SafeMemory::Status::Ok) 

BODY (preview):
		if (st != SafeMemory::Status::Ok) {
			m_ctx->raiseTrap(translateSafeMemStatusToTrap(st), pa);
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 1975
SIGNATURE:
 if(tr != TranslationResult::Ok) 

BODY (preview):
		if (tr != TranslationResult::Ok) {
			raiseTranslationFault(va, tr);
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 2070
SIGNATURE:
	AXP_FLATTEN void final_stage_before_exit(CPUIdType cpuId, quint64 pc) noexcept

BODY (preview):
	AXP_FLATTEN void final_stage_before_exit(CPUIdType cpuId, quint64 pc) noexcept {
		globalHWPCBController()(cpuId).forceUserPC(cpuId, pc);
	}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 2095
SIGNATURE:
 switch(tr) 

BODY (preview):
		switch (tr) {
		case TranslationResult::TlbMiss:
			trap = TrapCode::DTB_MISS;
			break;
		case TranslationResult::PermissionDenied:
			trap = TrapCode::DTB_ACCESS_VIOLATION;
			break;
		case TranslationResult::NonCanonical:
		case TranslationResult::Misaligned:
			trap = TrapCode::DTB_FAULT;
			break;
		default:
			trap = TrapCode::MACHINE_CHECK;
			break;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 2116
SIGNATURE:
 switch(st) 

BODY (preview):
		switch (st) {
		case SafeMemory::Status::Ok:
			return TrapCode::NONE;
		case SafeMemory::Status::AccessViolation:
			return TrapCode::DTB_ACCESS_VIOLATION;
		case SafeMemory::Status::Un_Aligned:
			return TrapCode::UN_ALIGNED;
		case SafeMemory::Status::BusError:
		case SafeMemory::Status::Time_Out:
		default:
			return TrapCode::MACHINE_CHECK;
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 2183
SIGNATURE:
 for(int i = 0; i < WRITE_BUFFER_SIZE; i++) 

BODY (preview):
		for (int i = 0; i < WRITE_BUFFER_SIZE; i++) {
			if (m_writeBuffer[i].valid) {
				m_ctx->storeMemory(
					m_writeBuffer[i].pa,
					m_writeBuffer[i].size,
					m_writeBuffer[i].value
				);
				m_writeBuffer[i].valid = false;
			}
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 2184
SIGNATURE:
	 if(m_writeBuffer[i].valid) 

BODY (preview):
			if (m_writeBuffer[i].valid) {
				m_ctx->storeMemory(
					m_writeBuffer[i].pa,
					m_writeBuffer[i].size,
					m_writeBuffer[i].value
				);
				m_writeBuffer[i].valid = false;
			}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 2443
SIGNATURE:
 for(uintptr_t p = start; p < end; p += 64) 

BODY (preview):
		for (uintptr_t p = start; p < end; p += 64) {
			asm volatile("dc cvau, %0" : : "r"(p) : "memory");
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBoxBase.h
LINE: 2451
SIGNATURE:
 for(uintptr_t p = start; p < end; p += 64) 

BODY (preview):
		for (uintptr_t p = start; p < end; p += 64) {
			asm volatile("ic ivau, %0" : : "r"(p) : "memory");
		}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBox_VirtualAddressTranslation_inl.h
LINE: 69
SIGNATURE:
   if(isPhysical) 

BODY (preview):
    if (isPhysical) {
        // PAL physical mode: VA = PA (identity mapping)
        pa = va;
        return TranslationResult::Success;
    }

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBox_VirtualAddressTranslation_inl.h
LINE: 80
SIGNATURE:
   if(!entry) 

BODY (preview):
    if (!entry) {
        // DTB MISS - Determine level

        // Check if this is a double miss (miss during miss handler)
        bool inPalMissHandler = ctx.isInPalMissHandler();

        if (inPalMissHandler) {
            // Double miss - check level
            quint8 missLevel = ctx.getDTBMissLevel();

            if (missLevel == 2) {
                // Level 3 miss (third level)
                auto ev = ExceptionFactory::makeDTBMissDouble3Event(
                    cpuId, va, isWrite);
                FaultDispatcher::queuePendingEvent(ev);

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBox_VirtualAddressTranslation_inl.h
LINE: 86
SIGNATURE:
       if(inPalMissHandler) 

BODY (preview):
        if (inPalMissHandler) {
            // Double miss - check level
            quint8 missLevel = ctx.getDTBMissLevel();

            if (missLevel == 2) {
                // Level 3 miss (third level)
                auto ev = ExceptionFactory::makeDTBMissDouble3Event(
                    cpuId, va, isWrite);
                FaultDispatcher::queuePendingEvent(ev);
                return TranslationResult::DTB_Miss;
            }
            else {
                // Level 4 miss (fourth level - critical)
                auto ev = ExceptionFactory::makeDTBMissDouble4Event(
                    cpuId, va, isWrite);

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBox_VirtualAddressTranslation_inl.h
LINE: 90
SIGNATURE:
           if(missLevel == 2) 

BODY (preview):
            if (missLevel == 2) {
                // Level 3 miss (third level)
                auto ev = ExceptionFactory::makeDTBMissDouble3Event(
                    cpuId, va, isWrite);
                FaultDispatcher::queuePendingEvent(ev);
                return TranslationResult::DTB_Miss;
            }

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBox_VirtualAddressTranslation_inl.h
LINE: 165
SIGNATURE:
   if(isWrite) 

BODY (preview):
    if (isWrite) {
        entry->setModified();
    }

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBox_VirtualAddressTranslation_inl.h
LINE: 238
SIGNATURE:
   if(!entry) 

BODY (preview):
    if (!entry) {
        // ITB MISS
        auto ev = ExceptionFactory::makeITBMissEvent(cpuId, va);
        FaultDispatcher::queuePendingEvent(ev);
        return TranslationResult::ITB_Miss;
    }

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBox_VirtualAddressTranslation_inl.h
LINE: 343
SIGNATURE:
void example_LoadInstruction(AlphaProcessorContext& ctx, quint64 va) 

BODY (preview):
void example_LoadInstruction(AlphaProcessorContext& ctx, quint64 va) {
    quint64 pa;

    TranslationResult result = translateVAForLoad(ctx, va, pa);

    switch (result) {
    case TranslationResult::Success:
        // Proceed with memory access
        // quint64 data = readPhysicalMemory(pa);
        break;

    case TranslationResult::DTB_Miss:
        // Exception already queued
        // Pipeline will handle fault delivery
        break;

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBox_VirtualAddressTranslation_inl.h
LINE: 348
SIGNATURE:
   switch(result) 

BODY (preview):
    switch (result) {
    case TranslationResult::Success:
        // Proceed with memory access
        // quint64 data = readPhysicalMemory(pa);
        break;

    case TranslationResult::DTB_Miss:
        // Exception already queued
        // Pipeline will handle fault delivery
        break;

    case TranslationResult::AccessViolation:
        // Exception already queued
        break;


================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBox_VirtualAddressTranslation_inl.h
LINE: 369
SIGNATURE:
void example_StoreInstruction(AlphaProcessorContext& ctx, quint64 va, quint64 data) 

BODY (preview):
void example_StoreInstruction(AlphaProcessorContext& ctx, quint64 va, quint64 data) {
    quint64 pa;

    TranslationResult result = translateVAForStore(ctx, va, pa);

    if (result == TranslationResult::Success) {
        // writePhysicalMemory(pa, data);
    }
    // Else: exception already queued
}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBox_VirtualAddressTranslation_inl.h
LINE: 374
SIGNATURE:
   if(result == TranslationResult::Success) 

BODY (preview):
    if (result == TranslationResult::Success) {
        // writePhysicalMemory(pa, data);
    }

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBox_VirtualAddressTranslation_inl.h
LINE: 381
SIGNATURE:
void example_InstructionFetch(AlphaProcessorContext& ctx, quint64 pc) 

BODY (preview):
void example_InstructionFetch(AlphaProcessorContext& ctx, quint64 pc) {
    quint64 pa;

    TranslationResult result = translateVAForInstruction(ctx, pc, pa);

    if (result == TranslationResult::Success) {
        // quint32 instruction = fetchFromPhysical(pa);
    }
    // Else: exception already queued
}

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBox_VirtualAddressTranslation_inl.h
LINE: 386
SIGNATURE:
   if(result == TranslationResult::Success) 

BODY (preview):
    if (result == TranslationResult::Success) {
        // quint32 instruction = fetchFromPhysical(pa);
    }

================================================================================
FILE: z:\EmulatRApp\MBoxLib_EV6\MBox_VirtualAddressTranslation_inl.h
LINE: 393
SIGNATURE:
void example_PALPhysicalAccess(AlphaProcessorContext& ctx, quint64 physAddr) 

BODY (preview):
void example_PALPhysicalAccess(AlphaProcessorContext& ctx, quint64 physAddr) {
    quint64 pa;

    // PAL physical mode bypasses translation
    TranslationResult result = translateVAForLoad(ctx, physAddr, pa, true);

    // result will always be Success
    // pa == physAddr
}

================================================================================
FILE: z:\EmulatRApp\memoryLib\AlphaMemorySystem.h
LINE: 48
SIGNATURE:
	 if(status != MMIOStatus::OK) 

BODY (preview):
			if (status != MMIOStatus::OK) {
				handleMMIOFault(pa, width, status, true);
				return false;
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\AlphaMemorySystem.h
LINE: 72
SIGNATURE:
	 if(status != MMIOStatus::OK) 

BODY (preview):
			if (status != MMIOStatus::OK) {
				handleMMIOFault(pa, width, status, false);
				return false;
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\AlphaMemorySystem.h
LINE: 83
SIGNATURE:
 if(success) 

BODY (preview):
		if (success) {
			// Notify reservation manager of potential conflict
			global_ReservationManager().conflictWrite(pa);

			// Notify IRQ controller to send IPIs to affected CPUs
			global_IRQController().promoteReservationLock();   // if needed
// 			global_IRQController().postInterrupt(hoseId, vector, ipl);
// 			global_IRQController().notifyDeliverable(cpuId);   // depends on your design
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\AlphaMemorySystem.h
LINE: 269
SIGNATURE:
 switch(width) 

BODY (preview):
		switch (width) {
		case 1: {
			quint8 val;
			if (!m_guestMem->readPA(pa, &val, 1)) return false;
			outValue = val;
			return true;
		}
		case 2: {
			quint16 val;
			if (!m_guestMem->readPA(pa, &val, 2)) return false;
			outValue = qFromLittleEndian(val);  // SafeMemory stores little-endian
			return true;
		}
		case 4: {
			quint32 val;

================================================================================
FILE: z:\EmulatRApp\memoryLib\AlphaMemorySystem.h
LINE: 301
SIGNATURE:
 switch(width) 

BODY (preview):
		switch (width) {
		case 1: {
			quint8 val = static_cast<quint8>(value);
			return m_guestMem->writePA(pa, &val, 1);
		}
		case 2: {
			quint16 val = qToLittleEndian(static_cast<quint16>(value));
			return m_guestMem->writePA(pa, &val, 2);
		}
		case 4: {
			quint32 val = qToLittleEndian(static_cast<quint32>(value));
			return m_guestMem->writePA(pa, &val, 4);
		}
		case 8: {
			quint64 val = qToLittleEndian(value);

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheLine.h
LINE: 89
SIGNATURE:
	void setValid(bool valid) 

BODY (preview):
	void setValid(bool valid) { m_valid.store(valid, std::memory_order_release); }


================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheLine.h
LINE: 93
SIGNATURE:
	void setTag(quint64 tag) 

BODY (preview):
	void setTag(quint64 tag) { m_tag.store(tag, std::memory_order_release); }


================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheLine.h
LINE: 96
SIGNATURE:
	void setAddress(quint64 addr) 

BODY (preview):
	void setAddress(quint64 addr) { m_address.store(addr, std::memory_order_release); }


================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheLine.h
LINE: 99
SIGNATURE:
	void setDirty(bool dirty) 

BODY (preview):
	void setDirty(bool dirty) { m_dirty.store(dirty, std::memory_order_release); }


================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheLine.h
LINE: 102
SIGNATURE:
	void setPrefetched(bool prefetched) 

BODY (preview):
	void setPrefetched(bool prefetched) { m_prefetched.store(prefetched, std::memory_order_release); }


================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheLine.h
LINE: 108
SIGNATURE:
	void AppendData(quint64 data_Line) 

BODY (preview):
	void AppendData(quint64 data_Line) {
		if (m_data.size() < static_cast<qsizetype>(getSize())) {
			m_data.append(data_Line);  // Append data to cache line
		}
		else {
			//WARN_LOG("Cache line is full. Data not appended.");
			// Optionally, handle eviction or replace based on policy
		}
	}

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheLine.h
LINE: 126
SIGNATURE:
	void setState(CoherencyState state) 

BODY (preview):
	void setState(CoherencyState state) {
		m_state.store(state, std::memory_order_release);
	}

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheLine.h
LINE: 149
SIGNATURE:
 if(buffer == nullptr) 

BODY (preview):
		if (buffer == nullptr) {
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheLine.h
LINE: 156
SIGNATURE:
 if(offset > dataSize || size > dataSize || offset + size > dataSize) 

BODY (preview):
		if (offset > dataSize || size > dataSize || offset + size > dataSize) {
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheLine.h
LINE: 160
SIGNATURE:
 if(dataSize == 0) 

BODY (preview):
		if (dataSize == 0) {
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheLine.h
LINE: 184
SIGNATURE:
 if(buffer == nullptr) 

BODY (preview):
		if (buffer == nullptr) {
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheLine.h
LINE: 191
SIGNATURE:
 if(offset > dataSize || size > dataSize || offset + size > dataSize) 

BODY (preview):
		if (offset > dataSize || size > dataSize || offset + size > dataSize) {
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheLine.h
LINE: 195
SIGNATURE:
 if(dataSize == 0) 

BODY (preview):
		if (dataSize == 0) {
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheLine.h
LINE: 235
SIGNATURE:
	qsizetype* getData() 

BODY (preview):
	qsizetype* getData() {
		return reinterpret_cast<qsizetype*>(m_data.data());
	}

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheLine.h
LINE: 243
SIGNATURE:
	qsizetype* getMutableData() 

BODY (preview):
	qsizetype* getMutableData() {
		return reinterpret_cast<qsizetype*>(m_data.data());
	}

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheLine.h
LINE: 255
SIGNATURE:
	void addRef() 

BODY (preview):
	void addRef() { m_refCount.fetch_add(1, std::memory_order_relaxed); }
	void removeRef() { m_refCount.fetch_sub(1, std::memory_order_relaxed); }

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheLine.h
LINE: 256
SIGNATURE:
	void removeRef() 

BODY (preview):
	void removeRef() { m_refCount.fetch_sub(1, std::memory_order_relaxed); }
	quint32 getRefCount() const { return m_refCount.load(std::memory_order_relaxed); }

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheSet.h
LINE: 59
SIGNATURE:
       for(int i = 0; i < m_associativity; ++i) 

BODY (preview):
        for (int i = 0; i < m_associativity; ++i) {
            m_lines.append(new CacheLine(lineSizeBytes));
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheSet.h
LINE: 66
SIGNATURE:
       for(int i = 0; i < m_associativity; ++i) 

BODY (preview):
        for (int i = 0; i < m_associativity; ++i) {
            m_order.append(i);
            m_frequency.append(0);
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheSet.h
LINE: 105
SIGNATURE:
       for(CacheLine* line : m_lines) 

BODY (preview):
        for (CacheLine* line : m_lines) {
            if (line) {
                if (line->isValid()) {
                    line->setValid(false);
                    line->setDirty(false);
                    m_validLineCount.fetch_sub(1, std::memory_order_relaxed);
                }
                else {
                    line->setDirty(false);
                }
            }
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheSet.h
LINE: 106
SIGNATURE:
           if(line) 

BODY (preview):
            if (line) {
                if (line->isValid()) {
                    line->setValid(false);
                    line->setDirty(false);
                    m_validLineCount.fetch_sub(1, std::memory_order_relaxed);
                }
                else {
                    line->setDirty(false);
                }
            }

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheSet.h
LINE: 131
SIGNATURE:
       for(CacheLine* line : m_lines) 

BODY (preview):
        for (CacheLine* line : m_lines) {
            if (line && line->isValid() && line->tag() == tag) {
                line->touch(currentTime);
                return line;
            }
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheSet.h
LINE: 148
SIGNATURE:
       for(CacheLine* line : m_lines) 

BODY (preview):
        for (CacheLine* line : m_lines) {
            if (line && line->isValid() && line->isDirty()) {
                dirty.append(line);
            }
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheSet.h
LINE: 198
SIGNATURE:
       for(qsizetype i = 0; i < m_associativity; ++i) 

BODY (preview):
        for (qsizetype i = 0; i < m_associativity; ++i) {
            CacheLine* line = m_lines[i];
            if (!line->isValid()) {
                line->setTag(tag);
                line->setAddress(address);
                line->setValid(true);

                const quint64 currentTime = m_globalTime.fetch_add(1ULL, std::memory_order_relaxed);
                if (i >= 0 && i < m_accessTimes.size()) {
                    m_accessTimes[i] = currentTime;
                }
                return line;
            }
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheSet.h
LINE: 295
SIGNATURE:
                   if(wb) 

BODY (preview):
                    if (wb) {
                        const bool ok = wb(address, data, sz);
                        if (ok) {
                            line->setDirty(false);
                            DEBUG_LOG(QString("CacheSet: Write-back completed for addr=0x%1").arg(address, 0, 16));
                        }
                        else {
                            ERROR_LOG(QString("CacheSet: Write-back FAILED for addr=0x%1").arg(address, 0, 16));
                        }
                    }

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheSet.h
LINE: 297
SIGNATURE:
                       if(ok) 

BODY (preview):
                        if (ok) {
                            line->setDirty(false);
                            DEBUG_LOG(QString("CacheSet: Write-back completed for addr=0x%1").arg(address, 0, 16));
                        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheSet.h
LINE: 335
SIGNATURE:
       for(int i = 0; i < m_associativity; ++i) 

BODY (preview):
        for (int i = 0; i < m_associativity; ++i) {
            m_lines.append(new CacheLine());
            m_order.append(i);
            m_frequency.append(0);
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheSet.h
LINE: 352
SIGNATURE:
       for(CacheLine* line : m_lines) 

BODY (preview):
        for (CacheLine* line : m_lines) {
            line->setValid(false);
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheSet.h
LINE: 359
SIGNATURE:
       for(int i = 0; i < m_associativity; ++i) 

BODY (preview):
        for (int i = 0; i < m_associativity; ++i) {
            m_order.append(i);
            m_frequency.append(0);
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheSet.h
LINE: 395
SIGNATURE:
       for(CacheLine* line : m_lines) 

BODY (preview):
        for (CacheLine* line : m_lines) {
            if (line && line->isDirty() && line->isValid()) {
                if (!writeBackFunc(line->getAddress(), line->getData(), line->getSize())) {
                    allClean = false;
                }
                line->setDirty(false);
            }
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheSet.h
LINE: 434
SIGNATURE:
       switch(m_policy) 

BODY (preview):
        switch (m_policy) {
        case ReplacementPolicy::LRU:
        case ReplacementPolicy::MRU:
        case ReplacementPolicy::FIFO:
            m_order.removeAll(idx);
            m_order.prepend(idx);
            break;
        case ReplacementPolicy::LFU:
            m_frequency[idx] += 1;
            break;
        case ReplacementPolicy::RANDOM:
            // no-op for RANDOM
            break;
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheSet.h
LINE: 460
SIGNATURE:
       if(m_policy == ReplacementPolicy::LFU) 

BODY (preview):
        if (m_policy == ReplacementPolicy::LFU) {
            m_frequency[idx] = 1;
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheSet.h
LINE: 470
SIGNATURE:
       switch(m_policy) 

BODY (preview):
        switch (m_policy) {
        case ReplacementPolicy::LRU:
            return m_order.back();   // least recently used
        case ReplacementPolicy::MRU:
            return m_order.front();  // most recently used
        case ReplacementPolicy::LFU:
            return pickLFU();
        case ReplacementPolicy::FIFO:
            return m_order.back();   // first-in
        case ReplacementPolicy::RANDOM:
            return Q_EMULATR_RANDOM_INT(m_associativity);
        default:
            return m_order.back();   // fallback to LRU
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\CacheSet.h
LINE: 494
SIGNATURE:
           if(m_frequency[i] < minFreq) 

BODY (preview):
            if (m_frequency[i] < minFreq) {
                minFreq = m_frequency[i];
                victimIdx = i;
            }

================================================================================
FILE: z:\EmulatRApp\memoryLib\GuestMemory.h
LINE: 103
SIGNATURE:
		SafeMemory* safeMemory() noexcept

BODY (preview):
		SafeMemory* safeMemory() noexcept { return m_safeMem; }


================================================================================
FILE: z:\EmulatRApp\memoryLib\GuestMemory.h
LINE: 121
SIGNATURE:
	 if(!dst || len == 0) 

BODY (preview):
			if (!dst || len == 0) {
				return false;
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\GuestMemory.h
LINE: 150
SIGNATURE:
	 if(!src || len == 0) 

BODY (preview):
			if (!src || len == 0) {
				return false;
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\GuestMemory.h
LINE: 308
SIGNATURE:
		SafeMemory* backingStore() 

BODY (preview):
		SafeMemory* backingStore() {
			return m_safeMem;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\memory_core.h
LINE: 145
SIGNATURE:
inline const char* modeToString(quint8 mode) 

BODY (preview):
inline const char* modeToString(quint8 mode) {
    switch (mode) {
    case 0: return "Kernel";
    case 1: return "Executive";
    case 2: return "Supervisor";
    case 3: return "User";
    default: return "Unknown";
    }
}

================================================================================
FILE: z:\EmulatRApp\memoryLib\memory_core.h
LINE: 146
SIGNATURE:
   switch(mode) 

BODY (preview):
    switch (mode) {
    case 0: return "Kernel";
    case 1: return "Executive";
    case 2: return "Supervisor";
    case 3: return "User";
    default: return "Unknown";
    }

================================================================================
FILE: z:\EmulatRApp\memoryLib\memory_core.h
LINE: 156
SIGNATURE:
inline PermissionDetail readPermissionFault(quint8 mode) 

BODY (preview):
inline PermissionDetail readPermissionFault(quint8 mode) {
    switch (mode) {
    case 0: return PermissionDetail::READ_DISALLOWED_KERNEL;
    case 1: return PermissionDetail::READ_DISALLOWED_EXECUTIVE;
    case 2: return PermissionDetail::READ_DISALLOWED_SUPERVISOR;
    case 3: return PermissionDetail::READ_DISALLOWED_USER;
    default: return PermissionDetail::NONE;
    }
}

================================================================================
FILE: z:\EmulatRApp\memoryLib\memory_core.h
LINE: 157
SIGNATURE:
   switch(mode) 

BODY (preview):
    switch (mode) {
    case 0: return PermissionDetail::READ_DISALLOWED_KERNEL;
    case 1: return PermissionDetail::READ_DISALLOWED_EXECUTIVE;
    case 2: return PermissionDetail::READ_DISALLOWED_SUPERVISOR;
    case 3: return PermissionDetail::READ_DISALLOWED_USER;
    default: return PermissionDetail::NONE;
    }

================================================================================
FILE: z:\EmulatRApp\memoryLib\memory_core.h
LINE: 167
SIGNATURE:
inline PermissionDetail writePermissionFault(quint8 mode) 

BODY (preview):
inline PermissionDetail writePermissionFault(quint8 mode) {
    switch (mode) {
    case 0: return PermissionDetail::WRITE_DISALLOWED_KERNEL;
    case 1: return PermissionDetail::WRITE_DISALLOWED_EXECUTIVE;
    case 2: return PermissionDetail::WRITE_DISALLOWED_SUPERVISOR;
    case 3: return PermissionDetail::WRITE_DISALLOWED_USER;
    default: return PermissionDetail::NONE;
    }
}

================================================================================
FILE: z:\EmulatRApp\memoryLib\memory_core.h
LINE: 168
SIGNATURE:
   switch(mode) 

BODY (preview):
    switch (mode) {
    case 0: return PermissionDetail::WRITE_DISALLOWED_KERNEL;
    case 1: return PermissionDetail::WRITE_DISALLOWED_EXECUTIVE;
    case 2: return PermissionDetail::WRITE_DISALLOWED_SUPERVISOR;
    case 3: return PermissionDetail::WRITE_DISALLOWED_USER;
    default: return PermissionDetail::NONE;
    }

================================================================================
FILE: z:\EmulatRApp\memoryLib\memory_core.h
LINE: 260
SIGNATURE:
       switch(type) 

BODY (preview):
        switch (type) {

            // ========================================================================
            // DS10/DS20 (Tsunami Chipset)
            // ========================================================================
        case SystemType::DS10:
        case SystemType::DS20: {
            map.chipsetName = "Tsunami";
            map.ramBase = 0x0000000000000000ULL;
            map.ramMaxSize = 2ULL * GB;  // 2 GB max
            map.ramActualSize = std::min(installedRAM, map.ramMaxSize);

            // MMIO starts at 2 GB (0x8000_0000)
            map.mmioBase = 0x0000000080000000ULL;
            map.mmioSize = 0x0000000080000000ULL;  // 2 GB MMIO space

================================================================================
FILE: z:\EmulatRApp\memoryLib\memory_core.h
LINE: 388
SIGNATURE:
           for(int i = 0; i < 4; ++i) 

BODY (preview):
            for (int i = 0; i < 4; ++i) {
                map.mmioApertures.append({
                    0x8000000000000000ULL + (i * 0x1000000000000000ULL),
                    0x1000000000000000ULL,
                    QString("QBB%1 MMIO").arg(i)
                    });
            }

================================================================================
FILE: z:\EmulatRApp\memoryLib\memory_core.h
LINE: 410
SIGNATURE:
           for(int i = 0; i < 8; ++i) 

BODY (preview):
            for (int i = 0; i < 8; ++i) {
                map.mmioApertures.append({
                    0x8000000000000000ULL + (i * 0x1000000000000000ULL),
                    0x1000000000000000ULL,
                    QString("QBB%1 MMIO").arg(i)
                    });
            }

================================================================================
FILE: z:\EmulatRApp\memoryLib\memory_core.h
LINE: 466
SIGNATURE:
       if(pa + len < pa) 

BODY (preview):
        if (pa + len < pa) {
            return false;
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\memory_core.h
LINE: 471
SIGNATURE:
       if(pa < ramBase) 

BODY (preview):
        if (pa < ramBase) {
            return false;
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\memory_core.h
LINE: 475
SIGNATURE:
       if(pa >= ramBase + ramActualSize) 

BODY (preview):
        if (pa >= ramBase + ramActualSize) {
            return false;
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\memory_core.h
LINE: 479
SIGNATURE:
       if(pa + len > ramBase + ramActualSize) 

BODY (preview):
        if (pa + len > ramBase + ramActualSize) {
            return false;
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\memory_core.h
LINE: 484
SIGNATURE:
       if(pa >= mmioBase) 

BODY (preview):
        if (pa >= mmioBase) {
            return false;
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\memory_core.h
LINE: 503
SIGNATURE:
       if(endPA < pa) 

BODY (preview):
        if (endPA < pa) {
            return true;  // Treat overflow as invalid/MMIO
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\memory_core.h
LINE: 508
SIGNATURE:
       if(pa >= mmioBase && pa < mmioBase + mmioSize) 

BODY (preview):
        if (pa >= mmioBase && pa < mmioBase + mmioSize) {
            return true;
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\memory_core.h
LINE: 513
SIGNATURE:
       for(const Aperture& aperture : mmioApertures) 

BODY (preview):
        for (const Aperture& aperture : mmioApertures) {
            // Check for overlap: [pa, endPA) vs [aperture.base, aperture.limit())
            if (pa < aperture.limit() && endPA > aperture.base) {
                return true;  // Overlaps this aperture
            }
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\memory_core.h
LINE: 532
SIGNATURE:
       for(const Aperture& aperture : mmioApertures) 

BODY (preview):
        for (const Aperture& aperture : mmioApertures) {
            if (aperture.contains(pa)) {
                return &aperture;
            }
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\memory_core.h
LINE: 558
SIGNATURE:
       for(const Aperture& aperture : mmioApertures) 

BODY (preview):
        for (const Aperture& aperture : mmioApertures) {
            lines << QString("    %1: 0x%2 - 0x%3 (%4 MB)")
                .arg(aperture.name)
                .arg(aperture.base, 16, 16, QChar('0'))
                .arg(aperture.limit(), 16, 16, QChar('0'))
                .arg(aperture.size / (double)MB, 0, 'f', 0);
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\PlatformAddressMap_core.h
LINE: 145
SIGNATURE:
inline const char* modeToString(quint8 mode) 

BODY (preview):
inline const char* modeToString(quint8 mode) {
    switch (mode) {
    case 0: return "Kernel";
    case 1: return "Executive";
    case 2: return "Supervisor";
    case 3: return "User";
    default: return "Unknown";
    }
}

================================================================================
FILE: z:\EmulatRApp\memoryLib\PlatformAddressMap_core.h
LINE: 146
SIGNATURE:
   switch(mode) 

BODY (preview):
    switch (mode) {
    case 0: return "Kernel";
    case 1: return "Executive";
    case 2: return "Supervisor";
    case 3: return "User";
    default: return "Unknown";
    }

================================================================================
FILE: z:\EmulatRApp\memoryLib\PlatformAddressMap_core.h
LINE: 156
SIGNATURE:
inline PermissionDetail readPermissionFault(quint8 mode) 

BODY (preview):
inline PermissionDetail readPermissionFault(quint8 mode) {
    switch (mode) {
    case 0: return PermissionDetail::READ_DISALLOWED_KERNEL;
    case 1: return PermissionDetail::READ_DISALLOWED_EXECUTIVE;
    case 2: return PermissionDetail::READ_DISALLOWED_SUPERVISOR;
    case 3: return PermissionDetail::READ_DISALLOWED_USER;
    default: return PermissionDetail::NONE;
    }
}

================================================================================
FILE: z:\EmulatRApp\memoryLib\PlatformAddressMap_core.h
LINE: 157
SIGNATURE:
   switch(mode) 

BODY (preview):
    switch (mode) {
    case 0: return PermissionDetail::READ_DISALLOWED_KERNEL;
    case 1: return PermissionDetail::READ_DISALLOWED_EXECUTIVE;
    case 2: return PermissionDetail::READ_DISALLOWED_SUPERVISOR;
    case 3: return PermissionDetail::READ_DISALLOWED_USER;
    default: return PermissionDetail::NONE;
    }

================================================================================
FILE: z:\EmulatRApp\memoryLib\PlatformAddressMap_core.h
LINE: 167
SIGNATURE:
inline PermissionDetail writePermissionFault(quint8 mode) 

BODY (preview):
inline PermissionDetail writePermissionFault(quint8 mode) {
    switch (mode) {
    case 0: return PermissionDetail::WRITE_DISALLOWED_KERNEL;
    case 1: return PermissionDetail::WRITE_DISALLOWED_EXECUTIVE;
    case 2: return PermissionDetail::WRITE_DISALLOWED_SUPERVISOR;
    case 3: return PermissionDetail::WRITE_DISALLOWED_USER;
    default: return PermissionDetail::NONE;
    }
}

================================================================================
FILE: z:\EmulatRApp\memoryLib\PlatformAddressMap_core.h
LINE: 168
SIGNATURE:
   switch(mode) 

BODY (preview):
    switch (mode) {
    case 0: return PermissionDetail::WRITE_DISALLOWED_KERNEL;
    case 1: return PermissionDetail::WRITE_DISALLOWED_EXECUTIVE;
    case 2: return PermissionDetail::WRITE_DISALLOWED_SUPERVISOR;
    case 3: return PermissionDetail::WRITE_DISALLOWED_USER;
    default: return PermissionDetail::NONE;
    }

================================================================================
FILE: z:\EmulatRApp\memoryLib\PlatformAddressMap_core.h
LINE: 260
SIGNATURE:
       switch(type) 

BODY (preview):
        switch (type) {

            // ========================================================================
            // DS10/DS20 (Tsunami Chipset)
            // ========================================================================
        case SystemType::DS10:
        case SystemType::DS20: {
            map.chipsetName = "Tsunami";
            map.ramBase = 0x0000000000000000ULL;
            map.ramMaxSize = 2ULL * GB;  // 2 GB max
            map.ramActualSize = std::min(installedRAM, map.ramMaxSize);

            // MMIO starts at 2 GB (0x8000_0000)
            map.mmioBase = 0x0000000080000000ULL;
            map.mmioSize = 0x0000000080000000ULL;  // 2 GB MMIO space

================================================================================
FILE: z:\EmulatRApp\memoryLib\PlatformAddressMap_core.h
LINE: 388
SIGNATURE:
           for(int i = 0; i < 4; ++i) 

BODY (preview):
            for (int i = 0; i < 4; ++i) {
                map.mmioApertures.append({
                    0x8000000000000000ULL + (i * 0x1000000000000000ULL),
                    0x1000000000000000ULL,
                    QString("QBB%1 MMIO").arg(i)
                });
            }

================================================================================
FILE: z:\EmulatRApp\memoryLib\PlatformAddressMap_core.h
LINE: 410
SIGNATURE:
           for(int i = 0; i < 8; ++i) 

BODY (preview):
            for (int i = 0; i < 8; ++i) {
                map.mmioApertures.append({
                    0x8000000000000000ULL + (i * 0x1000000000000000ULL),
                    0x1000000000000000ULL,
                    QString("QBB%1 MMIO").arg(i)
                });
            }

================================================================================
FILE: z:\EmulatRApp\memoryLib\PlatformAddressMap_core.h
LINE: 466
SIGNATURE:
       if(pa + len < pa) 

BODY (preview):
        if (pa + len < pa) {
            return false;
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\PlatformAddressMap_core.h
LINE: 471
SIGNATURE:
       if(pa < ramBase) 

BODY (preview):
        if (pa < ramBase) {
            return false;
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\PlatformAddressMap_core.h
LINE: 475
SIGNATURE:
       if(pa >= ramBase + ramActualSize) 

BODY (preview):
        if (pa >= ramBase + ramActualSize) {
            return false;
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\PlatformAddressMap_core.h
LINE: 479
SIGNATURE:
       if(pa + len > ramBase + ramActualSize) 

BODY (preview):
        if (pa + len > ramBase + ramActualSize) {
            return false;
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\PlatformAddressMap_core.h
LINE: 484
SIGNATURE:
       if(pa >= mmioBase) 

BODY (preview):
        if (pa >= mmioBase) {
            return false;
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\PlatformAddressMap_core.h
LINE: 503
SIGNATURE:
       if(endPA < pa) 

BODY (preview):
        if (endPA < pa) {
            return true;  // Treat overflow as invalid/MMIO
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\PlatformAddressMap_core.h
LINE: 508
SIGNATURE:
       if(pa >= mmioBase && pa < mmioBase + mmioSize) 

BODY (preview):
        if (pa >= mmioBase && pa < mmioBase + mmioSize) {
            return true;
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\PlatformAddressMap_core.h
LINE: 513
SIGNATURE:
       for(const Aperture& aperture : mmioApertures) 

BODY (preview):
        for (const Aperture& aperture : mmioApertures) {
            // Check for overlap: [pa, endPA) vs [aperture.base, aperture.limit())
            if (pa < aperture.limit() && endPA > aperture.base) {
                return true;  // Overlaps this aperture
            }
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\PlatformAddressMap_core.h
LINE: 532
SIGNATURE:
       for(const Aperture& aperture : mmioApertures) 

BODY (preview):
        for (const Aperture& aperture : mmioApertures) {
            if (aperture.contains(pa)) {
                return &aperture;
            }
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\PlatformAddressMap_core.h
LINE: 558
SIGNATURE:
       for(const Aperture& aperture : mmioApertures) 

BODY (preview):
        for (const Aperture& aperture : mmioApertures) {
            lines << QString("    %1: 0x%2 - 0x%3 (%4 MB)")
                .arg(aperture.name)
                .arg(aperture.base, 16, 16, QChar('0'))
                .arg(aperture.limit(), 16, 16, QChar('0'))
                .arg(aperture.size / (double)MB, 0, 'f', 0);
        }

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 32
SIGNATURE:
	bool initialize(quint64 sizeBytes) 

BODY (preview):
	bool initialize(quint64 sizeBytes) {
		if (sizeBytes > MAX_RAM_SIZE) {
			return false;
		}
		m_bytes.resize(sizeBytes);
		m_bytes.fill(0);
		m_sizeBytes = sizeBytes;
		return true;
	}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 33
SIGNATURE:
 if(sizeBytes > MAX_RAM_SIZE) 

BODY (preview):
		if (sizeBytes > MAX_RAM_SIZE) {
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 53
SIGNATURE:
	inline quint8* data() 

BODY (preview):
	inline quint8* data() {
		return reinterpret_cast<quint8*>(m_bytes.data());
	}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 65
SIGNATURE:
 switch(size) 

BODY (preview):
		switch (size) {
		case 1: {  // 8-bit load
			if (paddr >= m_sizeBytes) {
				return Status::OutOfRange;
			}
			out = m_bytes[paddr];
			return Status::Ok;
		}

		case 2: {  // 16-bit load
			if (paddr + 1 >= m_sizeBytes) {
				return Status::OutOfRange;
			}
			if (paddr % 2 != 0) {
				return Status::Misaligned;

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 67
SIGNATURE:
	 if(paddr >= m_sizeBytes) 

BODY (preview):
			if (paddr >= m_sizeBytes) {
				return Status::OutOfRange;
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 75
SIGNATURE:
	 if(paddr + 1 >= m_sizeBytes) 

BODY (preview):
			if (paddr + 1 >= m_sizeBytes) {
				return Status::OutOfRange;
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 78
SIGNATURE:
	 if(paddr % 2 != 0) 

BODY (preview):
			if (paddr % 2 != 0) {
				return Status::Misaligned;
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 89
SIGNATURE:
	 if(paddr + 3 >= m_sizeBytes) 

BODY (preview):
			if (paddr + 3 >= m_sizeBytes) {
				return Status::OutOfRange;
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 92
SIGNATURE:
	 if(paddr % 4 != 0) 

BODY (preview):
			if (paddr % 4 != 0) {
				return Status::Misaligned;
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 103
SIGNATURE:
	 if(paddr + 7 >= m_sizeBytes) 

BODY (preview):
			if (paddr + 7 >= m_sizeBytes) {
				return Status::OutOfRange;
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 106
SIGNATURE:
	 if(paddr % 8 != 0) 

BODY (preview):
			if (paddr % 8 != 0) {
				return Status::Misaligned;
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 123
SIGNATURE:
	inline Status store(quint64 paddr, quint8 size, quint64 value) noexcept

BODY (preview):
	inline Status store(quint64 paddr, quint8 size, quint64 value) noexcept {
		switch (size) {
		case 1: {  // 8-bit store
			if (paddr >= m_sizeBytes) {
				return Status::OutOfRange;
			}
			m_bytes[paddr] = static_cast<quint8>(value);
			return Status::Ok;
		}

		case 2: {  // 16-bit store
			if (paddr + 1 >= m_sizeBytes) {
				return Status::OutOfRange;
			}
			if (paddr % 2 != 0) {

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 124
SIGNATURE:
 switch(size) 

BODY (preview):
		switch (size) {
		case 1: {  // 8-bit store
			if (paddr >= m_sizeBytes) {
				return Status::OutOfRange;
			}
			m_bytes[paddr] = static_cast<quint8>(value);
			return Status::Ok;
		}

		case 2: {  // 16-bit store
			if (paddr + 1 >= m_sizeBytes) {
				return Status::OutOfRange;
			}
			if (paddr % 2 != 0) {
				return Status::Misaligned;

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 126
SIGNATURE:
	 if(paddr >= m_sizeBytes) 

BODY (preview):
			if (paddr >= m_sizeBytes) {
				return Status::OutOfRange;
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 134
SIGNATURE:
	 if(paddr + 1 >= m_sizeBytes) 

BODY (preview):
			if (paddr + 1 >= m_sizeBytes) {
				return Status::OutOfRange;
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 137
SIGNATURE:
	 if(paddr % 2 != 0) 

BODY (preview):
			if (paddr % 2 != 0) {
				return Status::Misaligned;
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 146
SIGNATURE:
	 if(paddr + 3 >= m_sizeBytes) 

BODY (preview):
			if (paddr + 3 >= m_sizeBytes) {
				return Status::OutOfRange;
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 149
SIGNATURE:
	 if(paddr % 4 != 0) 

BODY (preview):
			if (paddr % 4 != 0) {
				return Status::Misaligned;
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 158
SIGNATURE:
	 if(paddr + 7 >= m_sizeBytes) 

BODY (preview):
			if (paddr + 7 >= m_sizeBytes) {
				return Status::OutOfRange;
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 161
SIGNATURE:
	 if(paddr % 8 != 0) 

BODY (preview):
			if (paddr % 8 != 0) {
				return Status::Misaligned;
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 178
SIGNATURE:
 if(paddr >= m_sizeBytes) 

BODY (preview):
		if (paddr >= m_sizeBytes) {
			return Status::OutOfRange;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 186
SIGNATURE:
 if(paddr + 1 >= m_sizeBytes) 

BODY (preview):
		if (paddr + 1 >= m_sizeBytes) {
			return Status::OutOfRange;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 189
SIGNATURE:
 if(paddr % 2 != 0) 

BODY (preview):
		if (paddr % 2 != 0) {
			return Status::Misaligned;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 197
SIGNATURE:
 if(paddr + 3 >= m_sizeBytes) 

BODY (preview):
		if (paddr + 3 >= m_sizeBytes) {
			return Status::OutOfRange;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 200
SIGNATURE:
 if(paddr % 4 != 0) 

BODY (preview):
		if (paddr % 4 != 0) {
			return Status::Misaligned;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 208
SIGNATURE:
 if(paddr + 7 >= m_sizeBytes) 

BODY (preview):
		if (paddr + 7 >= m_sizeBytes) {
			return Status::OutOfRange;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 211
SIGNATURE:
 if(paddr % 8 != 0) 

BODY (preview):
		if (paddr % 8 != 0) {
			return Status::Misaligned;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 221
SIGNATURE:
	inline Status store8(quint64 paddr, quint8 value) 

BODY (preview):
	inline Status store8(quint64 paddr, quint8 value) {
		if (paddr >= m_sizeBytes) {
			return Status::OutOfRange;
		}
		m_bytes[paddr] = value;
		return Status::Ok;
	}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 222
SIGNATURE:
 if(paddr >= m_sizeBytes) 

BODY (preview):
		if (paddr >= m_sizeBytes) {
			return Status::OutOfRange;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 229
SIGNATURE:
	inline Status store16(quint64 paddr, quint16 value) 

BODY (preview):
	inline Status store16(quint64 paddr, quint16 value) {
		if (paddr + 1 >= m_sizeBytes) {
			return Status::OutOfRange;
		}
		if (paddr % 2 != 0) {
			return Status::Misaligned;
		}
		*reinterpret_cast<quint16*>(&m_bytes[paddr]) = qToLittleEndian(value);
		return Status::Ok;
	}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 230
SIGNATURE:
 if(paddr + 1 >= m_sizeBytes) 

BODY (preview):
		if (paddr + 1 >= m_sizeBytes) {
			return Status::OutOfRange;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 233
SIGNATURE:
 if(paddr % 2 != 0) 

BODY (preview):
		if (paddr % 2 != 0) {
			return Status::Misaligned;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 240
SIGNATURE:
	inline Status store32(quint64 paddr, quint32 value) 

BODY (preview):
	inline Status store32(quint64 paddr, quint32 value) {
		if (paddr + 3 >= m_sizeBytes) {
			return Status::OutOfRange;
		}
		if (paddr % 4 != 0) {
			return Status::Misaligned;
		}
		*reinterpret_cast<quint32*>(&m_bytes[paddr]) = qToLittleEndian(value);
		return Status::Ok;
	}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 241
SIGNATURE:
 if(paddr + 3 >= m_sizeBytes) 

BODY (preview):
		if (paddr + 3 >= m_sizeBytes) {
			return Status::OutOfRange;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 244
SIGNATURE:
 if(paddr % 4 != 0) 

BODY (preview):
		if (paddr % 4 != 0) {
			return Status::Misaligned;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 251
SIGNATURE:
	inline Status store64(quint64 paddr, quint64 value) 

BODY (preview):
	inline Status store64(quint64 paddr, quint64 value) {
		if (paddr + 7 >= m_sizeBytes) {
			return Status::OutOfRange;
		}
		if (paddr % 8 != 0) {
			return Status::Misaligned;
		}
		*reinterpret_cast<quint64*>(&m_bytes[paddr]) = qToLittleEndian(value);
		return Status::Ok;
	}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 252
SIGNATURE:
 if(paddr + 7 >= m_sizeBytes) 

BODY (preview):
		if (paddr + 7 >= m_sizeBytes) {
			return Status::OutOfRange;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 255
SIGNATURE:
 if(paddr % 8 != 0) 

BODY (preview):
		if (paddr % 8 != 0) {
			return Status::Misaligned;
		}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 265
SIGNATURE:
	inline bool readBlock(quint64 physicalAddr, void* buffer, qsizetype size) 

BODY (preview):
	inline bool readBlock(quint64 physicalAddr, void* buffer, qsizetype size) {
		if (physicalAddr + size > m_bytes.size()) {
			return false;
		}
		std::memcpy(buffer, m_bytes.constData() + physicalAddr, size);
		return true;
	}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 273
SIGNATURE:
	inline bool writeBlock(quint64 physicalAddr, const void* buffer, qsizetype size) 

BODY (preview):
	inline bool writeBlock(quint64 physicalAddr, const void* buffer, qsizetype size) {
		if (physicalAddr + size > m_bytes.size()) {
			return false;
		}
		std::memcpy(m_bytes.data() + physicalAddr, buffer, size);
		return true;
	}

================================================================================
FILE: z:\EmulatRApp\memoryLib\SafeMemory.h
LINE: 281
SIGNATURE:
	inline void fill(quint64 address, quint64 size, quint8 value) 

BODY (preview):
	inline void fill(quint64 address, quint64 size, quint8 value) {
		if (isValidAddress(address, size)) {
			std::memset(m_bytes.data() + address, value, size);
		}
	}

================================================================================
FILE: z:\EmulatRApp\memoryLib\UnifiedDataCache.h
LINE: 120
SIGNATURE:
 for(quint64 addr = startAligned; addr < endAligned; addr += lineSize) 

BODY (preview):
		for (quint64 addr = startAligned; addr < endAligned; addr += lineSize) {
			CacheSet* cacheSet = getCacheSet(addr);
			if (!cacheSet) {
				//ERROR_LOG(QString("invalidateRange: null CacheSet for addr=0x%1").arg(addr, 0, 16));
				continue;
			}

			if (cacheSet->invalidateLine(addr)) {
				emit sigLineInvalidated(addr);
				//DEBUG_LOG(QString("Cache :: Invalidated line (range): addr=0x%1").arg(addr, 0, 16));
			}

			// Propagate to next level if present
			if (m_nextLevel) {
				m_nextLevel->invalidateLine(addr);

================================================================================
FILE: z:\EmulatRApp\memoryLib\UnifiedDataCache.h
LINE: 122
SIGNATURE:
	 if(!cacheSet) 

BODY (preview):
			if (!cacheSet) {
				//ERROR_LOG(QString("invalidateRange: null CacheSet for addr=0x%1").arg(addr, 0, 16));
				continue;
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\UnifiedDataCache.h
LINE: 133
SIGNATURE:
	 if(m_nextLevel) 

BODY (preview):
			if (m_nextLevel) {
				m_nextLevel->invalidateLine(addr);
			}

================================================================================
FILE: z:\EmulatRApp\memoryLib\UnifiedDataCache.h
LINE: 146
SIGNATURE:
	void setCacheLevel(const QString& cacheLevel) 

BODY (preview):
	void setCacheLevel(const QString& cacheLevel) { m_cachelevel = cacheLevel; }


================================================================================
FILE: z:\EmulatRApp\memoryLib\UnifiedDataCache.h
LINE: 181
SIGNATURE:
	void setPrefetchDepth(quint32 depth) 

BODY (preview):
	void setPrefetchDepth(quint32 depth) { /* Implementation needed */
		Q_UNUSED(depth)
	}

================================================================================
FILE: z:\EmulatRApp\memoryLib\UnifiedDataCache.h
LINE: 186
SIGNATURE:
	void setPrefetchDistance(quint32 distance) 

BODY (preview):
	void setPrefetchDistance(quint32 distance) { /* Implementation needed */
		Q_UNUSED(distance)
	}

================================================================================
FILE: z:\EmulatRApp\memoryLib\UnifiedDataCache.h
LINE: 243
SIGNATURE:
	void evictHint(quint64 address, WriteBackFunction backingWrite) 

BODY (preview):
	void evictHint(quint64 address, WriteBackFunction backingWrite) {
		quint64 tag = getTag(address);
		qsizetype index = getIndex(address);

		if (index >= m_cacheSets.size()) {
			//ERROR_LOG(QString("evictHint: invalid index %1").arg(index));
			return;
		}

		CacheSet* set = m_cacheSets[index];  // Use reference
		CacheLine* line = set->findLine(address);

		if (line && line->isValid()) {
			if (!set->handleEviction(address, tag, backingWrite)) {
				//ERROR_LOG(QString("[UnifiedDataCache] evictHint FAILED at VA=0x%1").arg(address, 0, 16));

================================================================================
FILE: z:\EmulatRApp\memoryLib\UnifiedDataCache.h
LINE: 266
SIGNATURE:
 	void evictHint(quint64 address) 

BODY (preview):
	// 	void evictHint(quint64 address) {
	// 		evictHint(address, nullptr);
	// 	}

================================================================================
FILE: z:\EmulatRApp\memoryLib\UnifiedDataCache.h
LINE: 384
SIGNATURE:
	void setBackingRead(ReadFunction backingRead) 

BODY (preview):
	void setBackingRead(ReadFunction backingRead) { m_backingRead = backingRead; }


================================================================================
FILE: z:\EmulatRApp\memoryLib\UnifiedDataCache.h
LINE: 403
SIGNATURE:
	void attachMemorySystem(AlphaMemorySystem* memSys) 

BODY (preview):
	void attachMemorySystem(AlphaMemorySystem* memSys) { m_memorySystem = memSys; }
	/*void clearStatistics();*/

================================================================================
FILE: z:\EmulatRApp\memoryLib\UnifiedDataCache.h
LINE: 409
SIGNATURE:
	qsizetype getNumSets() 

BODY (preview):
	qsizetype getNumSets() { return m_numSets; }
	qsizetype getAssociativity() { return m_associativity; }

================================================================================
FILE: z:\EmulatRApp\memoryLib\UnifiedDataCache.h
LINE: 410
SIGNATURE:
	qsizetype getAssociativity() 

BODY (preview):
	qsizetype getAssociativity() { return m_associativity; }
	qsizetype getLineSize() { return m_lineSizeBytes; }

================================================================================
FILE: z:\EmulatRApp\memoryLib\UnifiedDataCache.h
LINE: 411
SIGNATURE:
	qsizetype getLineSize() 

BODY (preview):
	qsizetype getLineSize() { return m_lineSizeBytes; }
	qsizetype getTotalSize() { return m_totalSize; }

================================================================================
FILE: z:\EmulatRApp\memoryLib\UnifiedDataCache.h
LINE: 412
SIGNATURE:
	qsizetype getTotalSize() 

BODY (preview):
	qsizetype getTotalSize() { return m_totalSize; }
	double getAverageSetUtilization() const;

================================================================================
FILE: z:\EmulatRApp\memoryLib\UnifiedDataCache.h
LINE: 419
SIGNATURE:
	qsizetype getStatsUpdateInterval() 

BODY (preview):
	qsizetype getStatsUpdateInterval() { return m_statusUpdateInterval; }


================================================================================
FILE: z:\EmulatRApp\memoryLib\UnifiedDataCache.h
LINE: 515
SIGNATURE:
 if(hit) 

BODY (preview):
		if (hit) {
			m_hits.fetchAndAddRelaxed(1);
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\IDeviceEmulator.h
LINE: 219
SIGNATURE:
    virtual void onFence(palCore_FenceKind kind) 

BODY (preview):
    virtual void onFence(palCore_FenceKind kind) {
        // Default: no-op (most devices don't need this)
        (void)kind;
    }

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_DegradedDevices.h
LINE: 15
SIGNATURE:
inline mmio_AllocationResult mmio_deviceMap(mmio_Reason rsn) 

BODY (preview):
inline mmio_AllocationResult mmio_deviceMap(mmio_Reason rsn) {
	switch (rsn) {
	case mmio_Reason::OK:
		return mmio_AllocationResult::SUCCESS;
	case mmio_Reason::MMIO_EXHAUSTED:
		return mmio_AllocationResult::MMIO_EXHAUSTED;
	case mmio_Reason::IRQ_EXHAUSTED:
		return mmio_AllocationResult::IRQ_EXHAUSTED;
	case mmio_Reason::TEMPLATE_NOT_FOUND:
		return mmio_AllocationResult::TEMPLATE_NOT_FOUND;
	case mmio_Reason::DMA_UNSUPPORTED:
		return mmio_AllocationResult::DMA_NOT_SUPPORTED;
	case mmio_Reason::INIT_FAILED:
		return mmio_AllocationResult::FATAL_BOOT_ABORT;
	case mmio_Reason::PARENT_DISABLED:

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_DegradedDevices.h
LINE: 39
SIGNATURE:
	static DegradedDevicesReport& instance() 

BODY (preview):
	static DegradedDevicesReport& instance() {
		static DegradedDevicesReport inst;
		return inst;
	}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_DegradedDevices.h
LINE: 44
SIGNATURE:
	void addDegradedDevice(const DegradedDeviceEntry& entry) 

BODY (preview):
	void addDegradedDevice(const DegradedDeviceEntry& entry) {
		QMutexLocker locker(&m_lock);
		m_entries.append(entry);
	}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_DegradedDevices.h
LINE: 48
SIGNATURE:
	void addDegradedDevice(const DegradedDeviceInfo& info) 

BODY (preview):
	void addDegradedDevice(const DegradedDeviceInfo& info) {

		DegradedDeviceEntry entry;
		entry.deviceName = info.name;
		entry.location = info.location;
		entry.deviceClass = info.deviceClass;
		/*entry.resolvedTemplate = info.resolvedTemplate;*/
		//entry.reason = allocationResultFromString(info.reason);
		entry.m_degradeDeviceTimestamp = QDateTime::currentDateTime();

		QMutexLocker locker(&m_lock);
		m_entries.append(entry);
	}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_DegradedDevices.h
LINE: 80
SIGNATURE:
 for(const auto& entry : m_entries) 

BODY (preview):
		for (const auto& entry : m_entries) {
			QString reasonStr;
			switch (entry.reason) {
			case mmio_Reason::MMIO_EXHAUSTED:
				reasonStr = "MMIO aperture exhausted";
				break;
			case mmio_Reason::IRQ_EXHAUSTED:
				reasonStr = "IRQ vectors exhausted";
				break;
			case mmio_Reason::DMA_UNSUPPORTED:
				reasonStr = "DMA requirements unmet";
				break;
			case mmio_Reason::INIT_FAILED:
				reasonStr = "Device initialization failed";
				break;

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_DegradedDevices.h
LINE: 82
SIGNATURE:
	 switch(entry.reason) 

BODY (preview):
			switch (entry.reason) {
			case mmio_Reason::MMIO_EXHAUSTED:
				reasonStr = "MMIO aperture exhausted";
				break;
			case mmio_Reason::IRQ_EXHAUSTED:
				reasonStr = "IRQ vectors exhausted";
				break;
			case mmio_Reason::DMA_UNSUPPORTED:
				reasonStr = "DMA requirements unmet";
				break;
			case mmio_Reason::INIT_FAILED:
				reasonStr = "Device initialization failed";
				break;
			case mmio_Reason::PARENT_DISABLED:
				reasonStr = "Parent controller unavailable";

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_DegradedDevices.h
LINE: 111
SIGNATURE:
	void clear() 

BODY (preview):
	void clear() {
		QMutexLocker locker(&m_lock);
		m_entries.clear();
	}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_DeviceCatalog.h
LINE: 82
SIGNATURE:
	int size() 

BODY (preview):
	int size() {
		return m_templates.size();
	}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_deviceTemplate.h
LINE: 113
SIGNATURE:
 if(deviceClass == mmio_DeviceClass::SCSI_DISK || deviceClass == mmio_DeviceClass::SCSI_TAPE) 

BODY (preview):
		if (deviceClass == mmio_DeviceClass::SCSI_DISK || deviceClass == mmio_DeviceClass::SCSI_TAPE) {
			return true;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_deviceTemplate.h
LINE: 131
SIGNATURE:
 for(const BarTemplate& bar : bars) 

BODY (preview):
		for (const BarTemplate& bar : bars) {
			if (barIndices.contains(bar.barIndex)) {
				if (whyNot) *whyNot = QString("Duplicate BAR index: %1").arg(bar.barIndex);
				return false;
			}
			barIndices.insert(bar.barIndex);

			// Validate BAR size and alignment
			if (bar.size == 0) {
				if (whyNot) *whyNot = QString("BAR%1 has zero size").arg(bar.barIndex);
				return false;
			}

			if (bar.minAlignment == 0 || (bar.minAlignment & (bar.minAlignment - 1)) != 0) {
				if (whyNot) *whyNot = QString("BAR%1 alignment not power of 2").arg(bar.barIndex);

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_deviceTemplate.h
LINE: 139
SIGNATURE:
	 if(bar.size == 0) 

BODY (preview):
			if (bar.size == 0) {
				if (whyNot) *whyNot = QString("BAR%1 has zero size").arg(bar.barIndex);
				return false;
			}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_deviceTemplate.h
LINE: 151
SIGNATURE:
 for(const IrqTemplate& irq : irqs) 

BODY (preview):
		for (const IrqTemplate& irq : irqs) {
			if (irq.defaultIRQIpl > 31) {
				if (whyNot) *whyNot = QString("IRQ '%1' has invalid IPL: %2")
					.arg(irq.purpose).arg(irq.defaultIRQIpl);
				return false;
			}
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_deviceTemplate.h
LINE: 152
SIGNATURE:
	 if(irq.defaultIRQIpl > 31) 

BODY (preview):
			if (irq.defaultIRQIpl > 31) {
				if (whyNot) *whyNot = QString("IRQ '%1' has invalid IPL: %2")
					.arg(irq.purpose).arg(irq.defaultIRQIpl);
				return false;
			}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_deviceTemplate.h
LINE: 168
SIGNATURE:
 for(const BarTemplate& bar : bars) 

BODY (preview):
		for (const BarTemplate& bar : bars) {
			total += bar.size;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_DMACoherencyManager.h
LINE: 114
SIGNATURE:
 if(size == 0) 

BODY (preview):
		if (size == 0) {
			WARN_LOG("DMACoherencyManager::prepareForDeviceRead: size=0");
			return;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_DMACoherencyManager.h
LINE: 167
SIGNATURE:
 if(size == 0) 

BODY (preview):
		if (size == 0) {
			WARN_LOG("DMACoherencyManager::handleDeviceWrite: size=0");
			return;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_DMACoherencyManager.h
LINE: 224
SIGNATURE:
 if(size == 0) 

BODY (preview):
		if (size == 0) {
			ERROR_LOG("DMACoherencyManager::allocateDMABuffer: size=0");
			return 0;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_DMACoherencyManager.h
LINE: 295
SIGNATURE:
 if(desc.deviceUid != deviceUid) 

BODY (preview):
		if (desc.deviceUid != deviceUid) {
			ERROR_LOG(QString("DMACoherencyManager::freeDMABuffer: PA=0x%1 owned by device %2, not %3")
				.arg(pa, 16, 16, QChar('0'))
				.arg(desc.deviceUid)
				.arg(deviceUid));
			return;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_DMACoherencyManager.h
LINE: 458
SIGNATURE:
 if(m_l3) 

BODY (preview):
		if (m_l3) {
			const quint64 CACHE_LINE_SIZE = 64;
			quint64 startLine = pa & ~(CACHE_LINE_SIZE - 1);
			quint64 endLine = (pa + size + CACHE_LINE_SIZE - 1) & ~(CACHE_LINE_SIZE - 1);

			for (quint64 linePA = startLine; linePA < endLine; linePA += CACHE_LINE_SIZE) {
				m_l3->flushLine(linePA);
			}
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_DMACoherencyManager.h
LINE: 463
SIGNATURE:
	 for(quint64 linePA = startLine; linePA < endLine; linePA += CACHE_LINE_SIZE) 

BODY (preview):
			for (quint64 linePA = startLine; linePA < endLine; linePA += CACHE_LINE_SIZE) {
				m_l3->flushLine(linePA);
			}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_DMACoherencyManager.h
LINE: 479
SIGNATURE:
 if(m_l3) 

BODY (preview):
		if (m_l3) {
			const quint64 CACHE_LINE_SIZE = 64;
			quint64 startLine = pa & ~(CACHE_LINE_SIZE - 1);
			quint64 endLine = (pa + size + CACHE_LINE_SIZE - 1) & ~(CACHE_LINE_SIZE - 1);

			for (quint64 linePA = startLine; linePA < endLine; linePA += CACHE_LINE_SIZE) {
				m_l3->invalidateLine(linePA);
			}
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_DMACoherencyManager.h
LINE: 484
SIGNATURE:
	 for(quint64 linePA = startLine; linePA < endLine; linePA += CACHE_LINE_SIZE) 

BODY (preview):
			for (quint64 linePA = startLine; linePA < endLine; linePA += CACHE_LINE_SIZE) {
				m_l3->invalidateLine(linePA);
			}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_DMACoherencyManager.h
LINE: 498
SIGNATURE:
 if(!resMgr) 

BODY (preview):
		if (!resMgr) {
			WARN_LOG("DMACoherencyManager: No ReservationManager attached");
			return;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 98
SIGNATURE:
 for(auto& entry : m_regions) 

BODY (preview):
		for (auto& entry : m_regions) {
			if (entry.orderLock) {
				delete entry.orderLock;
				entry.orderLock = nullptr;
			}
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 99
SIGNATURE:
	 if(entry.orderLock) 

BODY (preview):
			if (entry.orderLock) {
				delete entry.orderLock;
				entry.orderLock = nullptr;
			}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 134
SIGNATURE:
 if(desc.size == 0) 

BODY (preview):
		if (desc.size == 0) {
			ERROR_LOG(QString("registerRegion: Device UID=%1 has zero size")
				.arg(desc.deviceUid));
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 140
SIGNATURE:
 if(desc.basePA + desc.size < desc.basePA) 

BODY (preview):
		if (desc.basePA + desc.size < desc.basePA) {
			ERROR_LOG(QString("registerRegion: Device UID=%1 PA range wraps around")
				.arg(desc.deviceUid));
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 157
SIGNATURE:
 for(const auto& range : m_sortedRanges) 

BODY (preview):
		for (const auto& range : m_sortedRanges) {
			if (newBase < range.limitPA && range.basePA < newLimit) {
				ERROR_LOG(QString("registerRegion: Device UID=%1 [0x%2-0x%3) overlaps with UID=%4 [0x%5-0x%6)")
					.arg(desc.deviceUid)
					.arg(newBase, 16, 16, QChar('0'))
					.arg(newLimit, 16, 16, QChar('0'))
					.arg(range.deviceUid)
					.arg(range.basePA, 16, 16, QChar('0'))
					.arg(range.limitPA, 16, 16, QChar('0')));
				return false;
			}
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 158
SIGNATURE:
	 if(newBase < range.limitPA && range.basePA < newLimit) 

BODY (preview):
			if (newBase < range.limitPA && range.basePA < newLimit) {
				ERROR_LOG(QString("registerRegion: Device UID=%1 [0x%2-0x%3) overlaps with UID=%4 [0x%5-0x%6)")
					.arg(desc.deviceUid)
					.arg(newBase, 16, 16, QChar('0'))
					.arg(newLimit, 16, 16, QChar('0'))
					.arg(range.deviceUid)
					.arg(range.basePA, 16, 16, QChar('0'))
					.arg(range.limitPA, 16, 16, QChar('0')));
				return false;
			}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 177
SIGNATURE:
 if(desc.attrs.stronglyOrdered) 

BODY (preview):
		if (desc.attrs.stronglyOrdered) {
			entry.orderLock = new QMutex();
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 214
SIGNATURE:
 if(it->orderLock) 

BODY (preview):
		if (it->orderLock) {
			delete it->orderLock;
			it->orderLock = nullptr;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 251
SIGNATURE:
 if(!handlers.onRead || !handlers.onWrite) 

BODY (preview):
		if (!handlers.onRead || !handlers.onWrite) {
			ERROR_LOG(QString("setDeviceHandlers: Device UID=%1 missing required handlers")
				.arg(deviceUid));
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 267
SIGNATURE:
    void registerDevice(DeviceNode* node, IDeviceEmulator* emulator, MMIOWindow* mmioWindow) 

BODY (preview):
    void registerDevice(DeviceNode* node, IDeviceEmulator* emulator, MMIOWindow* mmioWindow) {
        //TODO
    }

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 270
SIGNATURE:
    void unregisterDevice(quint32 deviceUID) 

BODY (preview):
    void unregisterDevice(quint32 deviceUID) {
        //TODO
    }

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 322
SIGNATURE:
 if(!entry) 

BODY (preview):
		if (!entry) {
			ERROR_LOG(QString("MMIO Read: PA=0x%1 width=%2 - no region found (BUS ERROR)")
				.arg(pa, 16, 16, QChar('0'))
				.arg(width));
			return MMIOStatus::BUS_ERROR;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 330
SIGNATURE:
 if(!entry->handlersSet) 

BODY (preview):
		if (!entry->handlersSet) {
			ERROR_LOG(QString("MMIO Read: PA=0x%1 [%2] - handlers not set")
				.arg(pa, 16, 16, QChar('0'))
				.arg(entry->desc.debugName));
			return MMIOStatus::BUS_ERROR;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 350
SIGNATURE:
 if(entry->orderLock) 

BODY (preview):
		if (entry->orderLock) {
			orderLocker = new QMutexLocker(entry->orderLock);
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 363
SIGNATURE:
 if(orderLocker) 

BODY (preview):
		if (orderLocker) {
			delete orderLocker;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 382
SIGNATURE:
 if(!entry) 

BODY (preview):
		if (!entry) {
			ERROR_LOG(QString("MMIO Write: PA=0x%1 width=%2 value=0x%3 - no region found (BUS ERROR)")
				.arg(pa, 16, 16, QChar('0'))
				.arg(width)
				.arg(value, width * 2, 16, QChar('0')));
			return MMIOStatus::BUS_ERROR;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 391
SIGNATURE:
 if(!entry->handlersSet) 

BODY (preview):
		if (!entry->handlersSet) {
			ERROR_LOG(QString("MMIO Write: PA=0x%1 [%2] - handlers not set")
				.arg(pa, 16, 16, QChar('0'))
				.arg(entry->desc.debugName));
			return MMIOStatus::BUS_ERROR;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 411
SIGNATURE:
 if(entry->desc.attrs.regEndian != mmio_Endianness::LITTLE) 

BODY (preview):
		if (entry->desc.attrs.regEndian != mmio_Endianness::LITTLE) {
			deviceValue = convertEndianness(value, width, entry->desc.attrs.regEndian);
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 417
SIGNATURE:
 if(entry->orderLock) 

BODY (preview):
		if (entry->orderLock) {
			orderLocker = new QMutexLocker(entry->orderLock);
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 424
SIGNATURE:
 if(orderLocker) 

BODY (preview):
		if (orderLocker) {
			delete orderLocker;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 444
SIGNATURE:
 if(kind == palCore_FenceKind::WMB || kind == palCore_FenceKind::MB) 

BODY (preview):
		if (kind == palCore_FenceKind::WMB || kind == palCore_FenceKind::MB) {
			// Platform-specific: ensure all posted writes reach devices
			// (On x86, this might be a SFENCE; on ARM, DMB ST)
			std::atomic_thread_fence(std::memory_order_release);
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 451
SIGNATURE:
 if(kind == palCore_FenceKind::RMB || kind == palCore_FenceKind::MB) 

BODY (preview):
		if (kind == palCore_FenceKind::RMB || kind == palCore_FenceKind::MB) {
			std::atomic_thread_fence(std::memory_order_acquire);
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 456
SIGNATURE:
 for(auto& entry : m_regions) 

BODY (preview):
		for (auto& entry : m_regions) {
			if (entry.handlersSet && entry.handlers.onFence) {
				entry.handlers.onFence(kind);
			}
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 457
SIGNATURE:
	 if(entry.handlersSet && entry.handlers.onFence) 

BODY (preview):
			if (entry.handlersSet && entry.handlers.onFence) {
				entry.handlers.onFence(kind);
			}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 482
SIGNATURE:
 if(it->handlersSet && it->handlers.onFence) 

BODY (preview):
		if (it->handlersSet && it->handlers.onFence) {
			it->handlers.onFence(palCore_FenceKind::WMB);
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 500
SIGNATURE:
 for(auto& entry : m_regions) 

BODY (preview):
		for (auto& entry : m_regions) {
			if (entry.handlersSet && entry.handlers.onReset) {
				entry.handlers.onReset();
			}
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 501
SIGNATURE:
	 if(entry.handlersSet && entry.handlers.onReset) 

BODY (preview):
			if (entry.handlersSet && entry.handlers.onReset) {
				entry.handlers.onReset();
			}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 525
SIGNATURE:
 for(const auto& entry : m_regions) 

BODY (preview):
		for (const auto& entry : m_regions) {
			const auto& desc = entry.desc;
			lines << QString("UID=%1 [%2]")
				.arg(desc.deviceUid)
				.arg(desc.debugName);
			lines << QString("  PA: 0x%1 - 0x%2 (size=0x%3)")
				.arg(desc.basePA, 16, 16, QChar('0'))
				.arg(entry.limitPA, 16, 16, QChar('0'))
				.arg(desc.size, 0, 16);
			lines << QString("  Alignment: %1 bytes, Widths: 0x%2")
				.arg(desc.attrs.minAlignment)
				.arg(desc.attrs.supportedWidths, 2, 16, QChar('0'));
			lines << QString("  Side Effects: Read=%1 Write=%2, StronglyOrdered=%3")
				.arg(desc.attrs.sideEffectOnRead ? "yes" : "no")
				.arg(desc.attrs.sideEffectOnWrite ? "yes" : "no")

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 608
SIGNATURE:
 if(offset + width > desc.size) 

BODY (preview):
		if (offset + width > desc.size) {
			if (errorMsg) {
				*errorMsg = QString("out of bounds (offset=0x%1 + width=%2 > size=0x%3)")
					.arg(offset, 0, 16)
					.arg(width)
					.arg(desc.size, 0, 16);
			}
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 609
SIGNATURE:
	 if(errorMsg) 

BODY (preview):
			if (errorMsg) {
				*errorMsg = QString("out of bounds (offset=0x%1 + width=%2 > size=0x%3)")
					.arg(offset, 0, 16)
					.arg(width)
					.arg(desc.size, 0, 16);
			}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 619
SIGNATURE:
 if(offset % attrs.minAlignment != 0) 

BODY (preview):
		if (offset % attrs.minAlignment != 0) {
			if (errorMsg) {
				*errorMsg = QString("misaligned (offset=0x%1 not aligned to %2 bytes)")
					.arg(offset, 0, 16)
					.arg(attrs.minAlignment);
			}
			return false;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 620
SIGNATURE:
	 if(errorMsg) 

BODY (preview):
			if (errorMsg) {
				*errorMsg = QString("misaligned (offset=0x%1 not aligned to %2 bytes)")
					.arg(offset, 0, 16)
					.arg(attrs.minAlignment);
			}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 631
SIGNATURE:
	 if(errorMsg) 

BODY (preview):
			if (errorMsg) {
				*errorMsg = QString("unsupported width %1 bytes (allowed=0x%2)")
					.arg(width)
					.arg(attrs.supportedWidths, 2, 16, QChar('0'));
			}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 654
SIGNATURE:
 if(regEndian == mmio_Endianness::LITTLE) 

BODY (preview):
		if (regEndian == mmio_Endianness::LITTLE) {
			// Device is little-endian => host and device match.
			return value;
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 660
SIGNATURE:
 switch(width) 

BODY (preview):
		switch (width) {
		case 1:
			// Single byte is the same in any endian.
			return value;

		case 2:
			return quint64(qbswap(static_cast<quint16>(value)));

		case 4:
			return quint64(qbswap(static_cast<quint32>(value)));

		case 8:
			// qbswap is templated; here value is already quint64.
			return qbswap(value);


================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_Manager.h
LINE: 688
SIGNATURE:
 for(const auto& entry : m_regions) 

BODY (preview):
		for (const auto& entry : m_regions) {
			PARange range;
			range.basePA = entry.desc.basePA;
			range.limitPA = entry.limitPA;
			range.deviceUid = entry.desc.deviceUid;
			m_sortedRanges.append(range);
		}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_PlatformTemplates.h
LINE: 34
SIGNATURE:
PlatformTemplate loadES40Template() 

BODY (preview):
PlatformTemplate loadES40Template() {
	PlatformTemplate tpl;
	tpl.modelName = "ES40";
	tpl.numHoses = 2;
	tpl.hoses.reserve(tpl.numHoses);

	// two hoses, each with distinct 32-bit MMIO, 64-bit MMIO, and an IRQ sub-range
	// Provides deterministic spaces to the ResourceAllocated to carve 
	// BARs and assign device vectors without colliding with exceptions/software-int/AST vector domains.
	// 
	// IRQ vector pool sizes: 
	//  - TODO calculate the per-hose IRQ pools, for a 4-CPU config (typical in larger systems)
	//         enlarge per-hose IRQ pools (e.g., Hose0 0x400..0x460, Hose1 0x460..0x4A0) so the allocator 
	//         never exhausts routes.
	//

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_PlatformTemplates.h
LINE: 110
SIGNATURE:
PlatformTemplate loadES40_4CPU_Template() 

BODY (preview):
PlatformTemplate loadES40_4CPU_Template() {
	auto tpl = loadES40Template(); // start from your ES40
	// Enlarge per-hose IRQ pools to accommodate more devices/queues
	tpl.hoses[0].irqDomain.base = 0x400;
	tpl.hoses[0].irqDomain.limit = 0x460; // +96
	tpl.hoses[1].irqDomain.base = 0x460;
	tpl.hoses[1].irqDomain.limit = 0x4A0; // +64
	// (Optional) widen MMIO windows if you expect more/larger BARs
	return tpl;
}

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_PlatformTemplates.h
LINE: 121
SIGNATURE:
PlatformTemplate loadGXTemplate() 

BODY (preview):
PlatformTemplate loadGXTemplate() {
	PlatformTemplate tpl;
	tpl.modelName = "GX-Series";
	tpl.numHoses = 4;
	tpl.hoses.reserve(tpl.numHoses);
	for (int h = 0; h < 4; ++h) {
		Hose a(h);
		a.hoseId = h;
		// Make bigger apertures to host many 64-bit BAR devices
		a.mmio32.base = 0x0000'B000'0000ull + (quint64)h * 0x0100'0000ull; // per-hose 256 MiB
		a.mmio32.size = a.mmio32.base + 0x0100'0000ull;
		a.mmio64.base = 0x0001'0000'0000ull + (quint64)h * 0x0400'0000ull; // 1 GiB per hose
		a.mmio64.size = a.mmio64.base + 0x0400'0000ull;

		// Non-overlapping 128-vector slabs

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_PlatformTemplates.h
LINE: 147
SIGNATURE:
PlatformTemplate loadDS20Template() 

BODY (preview):
PlatformTemplate loadDS20Template() {
	PlatformTemplate tpl;
	tpl.modelName = "DS20";
	tpl.numHoses = 2;
	tpl.hoses.reserve(2);

	// Hose 0
	{
		Hose a(0);
		a.hoseId = 0;
		a.mmio32.base = 0x0000'B800'0000ull; a.mmio32.size = a.mmio32.base + 0x0200'0000ull; // 32?64-bit friendly
		a.mmio64.base = 0x0000'9000'0000ull; a.mmio64.size = a.mmio64.base + 0x0200'0000ull; // 512 MiB each
		a.irqDomain.base = 0x300; a.irqDomain.limit = 0x340; // 64 vectors
		a.mmio32.cursor = a.mmio32.base; a.mmio64.cursor = a.mmio64.base; a.irqDomain.cursor = a.irqDomain.base;
		tpl.hoses.push_back(a);

================================================================================
FILE: z:\EmulatRApp\mmioLib\mmio_PlatformTemplates.h
LINE: 176
SIGNATURE:
PlatformTemplate loadDS10Template() 

BODY (preview):
PlatformTemplate loadDS10Template() {
	PlatformTemplate tpl;
	tpl.modelName = "DS10";
	tpl.numHoses = 1;
	tpl.hoses.reserve(1);

	Hose  a(0);
	a.hoseId = 0;
	a.mmio32.base = 0x0000'BC00'0000ull; a.mmio32.size = a.mmio32.base + 0x0100'0000ull; // 256 MiB
	a.mmio64.base = 0x0000'9400'0000ull; a.mmio64.size = a.mmio64.base + 0x0200'0000ull; // 512 MiB (optional)
	a.irqDomain.base = 0x280; a.irqDomain.limit = 0x2A0; // 32 vectors
	a.mmio32.cursor = a.mmio32.base; a.mmio64.cursor = a.mmio64.base; a.irqDomain.cursor = a.irqDomain.base;
	tpl.hoses.push_back(a);

	return tpl;

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\astsr_clear_inl.h
LINE: 7
SIGNATURE:
inline void clearASTSR(CPUIdType cpuId AlphaInstructionGrain* grain, quint8 deliveredLevel) noexcept

BODY (preview):
inline void clearASTSR(CPUIdType cpuId AlphaInstructionGrain* grain, quint8 deliveredLevel) noexcept {
	auto& iprs = globalIPRBank()[cpuId];
	iprs.astsr &= ~(1u << deliveredLevel);
}

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\executeRETSYS_iface.h
LINE: 20
SIGNATURE:
inline void executePALRetsys_iface(CPUStateIPRInterface* cpuState) 

BODY (preview):
inline void executePALRetsys_iface(CPUStateIPRInterface* cpuState) {

}

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\executeRTI_iface.h
LINE: 19
SIGNATURE:
   if(!cpuState) 

BODY (preview):
    if (!cpuState) {
        return;
    }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\executeSWPCTX.h
LINE: 20
SIGNATURE:
inline void executeSWPCTX(CPUStateIPRInterface* cpuState) 

BODY (preview):
inline void executeSWPCTX(CPUStateIPRInterface* cpuState) {

	

}

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\executeSWPIPL_iface.h
LINE: 21
SIGNATURE:
inline void executePALSwpipl_iface(CPUStateIPRInterface* cpuState) 

BODY (preview):
inline void executePALSwpipl_iface(CPUStateIPRInterface* cpuState) {

}

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\Global_PALVectorTable.h
LINE: 380
SIGNATURE:
	inline QVector<PalVectorEntry>& rawEntries() noexcept

BODY (preview):
	inline QVector<PalVectorEntry>& rawEntries() noexcept { return entries_; }


================================================================================
FILE: z:\EmulatRApp\palLib_EV6\onValidatePALcodeBaseAddress_inl.h
LINE: 33
SIGNATURE:
   if(palEnd > physicalMemoryLimit) 

BODY (preview):
    if (palEnd > physicalMemoryLimit) {
        qWarning() << "PAL_BASE exceeds physical memory:"
                   << Qt::hex << palBase
                   << "limit:" << physicalMemoryLimit;
        return false;
    }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\onValidatePALcodeBaseAddress_inl.h
LINE: 62
SIGNATURE:
   if(memType != MemoryType::RAM && memType != MemoryType::ROM) 

BODY (preview):
    if (memType != MemoryType::RAM && memType != MemoryType::ROM) {
        qWarning() << "PAL_BASE not in RAM/ROM:" << Qt::hex << palBase;
        return false;
    }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\onValidatePALcodeBaseAddress_inl.h
LINE: 73
SIGNATURE:
   if(palStart < 0x1000ULL) 

BODY (preview):
    if (palStart < 0x1000ULL) {
        qWarning() << "PAL_BASE conflicts with scratch area:" << Qt::hex << palBase;
        return false;
    }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\onValidatePALcodeBaseAddress_inl.h
LINE: 84
SIGNATURE:
   if(palBase > 0x100000000ULL) 

BODY (preview):
    if (palBase > 0x100000000ULL) {  // > 4GB is unusual
        qWarning() << "PAL_BASE unusually high:" << Qt::hex << palBase;
        // Not fatal, but suspicious
    }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalCodeEmulator.h
LINE: 103
SIGNATURE:
       if(newASN == oldASN) 

BODY (preview):
        if (newASN == oldASN) {
            // ASN unchanged - skip to done
            goto done;
        }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalCodeEmulator.h
LINE: 117
SIGNATURE:
       catch(...) 

BODY (preview):
        catch (...) {
            // If this fails, it's a MACHINE_CHECK (fatal)
            cpu.raiseMachineCheck("Failed to write ASN");
            return;
        }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalCodeEmulator.h
LINE: 204
SIGNATURE:
       catch(const DTBMissException& e) 

BODY (preview):
        catch (const DTBMissException& e) {
            // Nested exception during TLB flush
            // This should be handled by DtbMiss_Pal vector
            cpu.trapToPAL(PalVectorId::DtbMiss_Pal);
        }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalCodeEmulator.h
LINE: 223
SIGNATURE:
       catch(const DTBMissException& e) 

BODY (preview):
        catch (const DTBMissException& e) {
            // Nested exception during selective flush
            cpu.trapToPAL(PalVectorId::DtbMiss_Pal);
        }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalCodeEmulator.h
LINE: 235
SIGNATURE:
  while(running) 

BODY (preview):
//   while (running) {
//       quint64 pc = cpu.getPC();
//
//       // Check if PC is in PAL region
//       if (cpu.isInPALmode() && cpu.isPALaddress(pc)) {
//           // Execute PALcode
//           quint16 vector = (pc - cpu.getPAL_BASE()) & 0xFFFF;
//           PALcodeEmulator::executePALvector(vector, cpu);
//       } else {
//           // Normal instruction execution
//           DecodedInstruction* di = fetchDecoded(pc);
//           di->grain->execute(*di, cpu);
//       }
//   }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorId_inl.h
LINE: 51
SIGNATURE:
 if(currentMode != 0) 

BODY (preview):
		if (currentMode != 0) {
			return true;
		}

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorId_inl.h
LINE: 193
SIGNATURE:
 if(func <= 0x3F) 

BODY (preview):
		if (func <= 0x3F) {
			return 0;  // Privileged (0x00-0x3F)
		}

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorId_inl.h
LINE: 196
SIGNATURE:
		else if(func >= 0x80 && func <= 0xBF) 

BODY (preview):
		else if (func >= 0x80 && func <= 0xBF) {
			return 1;  // Unprivileged (0x80-0xBF)
		}

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorId_inl.h
LINE: 216
SIGNATURE:
 if(func <= 0x3F) 

BODY (preview):
		if (func <= 0x3F) {
			return 0x2000;  // Privileged base
		}

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 219
SIGNATURE:
	PalVectorId resolveDTBMiss(const AlphaProcessorContext& ctx, const PendingEvent& ev) 

BODY (preview):
	PalVectorId resolveDTBMiss(const AlphaProcessorContext& ctx, const PendingEvent& ev) {
		// Use the exception class, not runtime context
		switch (ev.exceptionClass) {
		case ExceptionClass::DTB_MISS_SINGLE:
			return PalVectorId::DTB_MISS_SINGLE;

		case ExceptionClass::DTB_MISS_DOUBLE_3:
			return PalVectorId::DTB_MISS_DOUBLE_3;

		case ExceptionClass::DTB_MISS_DOUBLE_4:
			return PalVectorId::DTB_MISS_DOUBLE_4;

		default:
			return PalVectorId::INVALID;
		}

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 221
SIGNATURE:
 switch(ev.exceptionClass) 

BODY (preview):
		switch (ev.exceptionClass) {
		case ExceptionClass::DTB_MISS_SINGLE:
			return PalVectorId::DTB_MISS_SINGLE;

		case ExceptionClass::DTB_MISS_DOUBLE_3:
			return PalVectorId::DTB_MISS_DOUBLE_3;

		case ExceptionClass::DTB_MISS_DOUBLE_4:
			return PalVectorId::DTB_MISS_DOUBLE_4;

		default:
			return PalVectorId::INVALID;
		}

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 502
SIGNATURE:
    inline void handleReset() 

BODY (preview):
    inline void handleReset()            { /* TODO: RESET PAL handler */ }
    inline void handleMachineCheck()     { /* TODO: MCHK PAL handler */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 503
SIGNATURE:
    inline void handleMachineCheck() 

BODY (preview):
    inline void handleMachineCheck()     { /* TODO: MCHK PAL handler */ }
    inline void handleArithmetic()       { /* TODO: ARITH PAL handler */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 504
SIGNATURE:
    inline void handleArithmetic() 

BODY (preview):
    inline void handleArithmetic()       { /* TODO: ARITH PAL handler */ }
    inline void handleInterrupt()        { /* TODO: INTERRUPT PAL handler */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 505
SIGNATURE:
    inline void handleInterrupt() 

BODY (preview):
    inline void handleInterrupt()        { /* TODO: INTERRUPT PAL handler */ }
    inline void handleDStream(PalVectorId /*vectorId*/)

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 511
SIGNATURE:
    inline void handleItbMiss() 

BODY (preview):
    inline void handleItbMiss()          { /* TODO: ITB_MISS PAL handler */ }
    inline void handleItbAcv()           { /* TODO: ITB_ACV PAL handler */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 512
SIGNATURE:
    inline void handleItbAcv() 

BODY (preview):
    inline void handleItbAcv()           { /* TODO: ITB_ACV PAL handler */ }
    inline void handleOpcDec()           { /* TODO: OPCDEC PAL handler */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 513
SIGNATURE:
    inline void handleOpcDec() 

BODY (preview):
    inline void handleOpcDec()           { /* TODO: OPCDEC PAL handler */ }
    inline void handleFen()              { /* TODO: FEN PAL handler */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 514
SIGNATURE:
    inline void handleFen() 

BODY (preview):
    inline void handleFen()              { /* TODO: FEN PAL handler */ }


================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 542
SIGNATURE:
    inline void handleCallPal_00() 

BODY (preview):
    inline void handleCallPal_00() { /* TODO */ }
    inline void handleCallPal_01() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 543
SIGNATURE:
    inline void handleCallPal_01() 

BODY (preview):
    inline void handleCallPal_01() { /* TODO */ }
    inline void handleCallPal_02() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 544
SIGNATURE:
    inline void handleCallPal_02() 

BODY (preview):
    inline void handleCallPal_02() { /* TODO */ }
    inline void handleCallPal_03() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 545
SIGNATURE:
    inline void handleCallPal_03() 

BODY (preview):
    inline void handleCallPal_03() { /* TODO */ }
    inline void handleCallPal_04() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 546
SIGNATURE:
    inline void handleCallPal_04() 

BODY (preview):
    inline void handleCallPal_04() { /* TODO */ }
    inline void handleCallPal_05() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 547
SIGNATURE:
    inline void handleCallPal_05() 

BODY (preview):
    inline void handleCallPal_05() { /* TODO */ }
    inline void handleCallPal_06() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 548
SIGNATURE:
    inline void handleCallPal_06() 

BODY (preview):
    inline void handleCallPal_06() { /* TODO */ }
    inline void handleCallPal_07() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 549
SIGNATURE:
    inline void handleCallPal_07() 

BODY (preview):
    inline void handleCallPal_07() { /* TODO */ }


================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 551
SIGNATURE:
    inline void handleCallPal_08() 

BODY (preview):
    inline void handleCallPal_08() { /* TODO */ }
    inline void handleCallPal_09() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 552
SIGNATURE:
    inline void handleCallPal_09() 

BODY (preview):
    inline void handleCallPal_09() { /* TODO */ }
    inline void handleCallPal_0A() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 553
SIGNATURE:
    inline void handleCallPal_0A() 

BODY (preview):
    inline void handleCallPal_0A() { /* TODO */ }
    inline void handleCallPal_0B() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 554
SIGNATURE:
    inline void handleCallPal_0B() 

BODY (preview):
    inline void handleCallPal_0B() { /* TODO */ }
    inline void handleCallPal_0C() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 555
SIGNATURE:
    inline void handleCallPal_0C() 

BODY (preview):
    inline void handleCallPal_0C() { /* TODO */ }
    inline void handleCallPal_0D() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 556
SIGNATURE:
    inline void handleCallPal_0D() 

BODY (preview):
    inline void handleCallPal_0D() { /* TODO */ }
    inline void handleCallPal_0E() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 557
SIGNATURE:
    inline void handleCallPal_0E() 

BODY (preview):
    inline void handleCallPal_0E() { /* TODO */ }
    inline void handleCallPal_0F() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 558
SIGNATURE:
    inline void handleCallPal_0F() 

BODY (preview):
    inline void handleCallPal_0F() { /* TODO */ }


================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 560
SIGNATURE:
    inline void handleCallPal_10() 

BODY (preview):
    inline void handleCallPal_10() { /* TODO */ }
    inline void handleCallPal_11() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 561
SIGNATURE:
    inline void handleCallPal_11() 

BODY (preview):
    inline void handleCallPal_11() { /* TODO */ }
    inline void handleCallPal_12() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 562
SIGNATURE:
    inline void handleCallPal_12() 

BODY (preview):
    inline void handleCallPal_12() { /* TODO */ }
    inline void handleCallPal_13() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 563
SIGNATURE:
    inline void handleCallPal_13() 

BODY (preview):
    inline void handleCallPal_13() { /* TODO */ }
    inline void handleCallPal_14() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 564
SIGNATURE:
    inline void handleCallPal_14() 

BODY (preview):
    inline void handleCallPal_14() { /* TODO */ }
    inline void handleCallPal_15() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 565
SIGNATURE:
    inline void handleCallPal_15() 

BODY (preview):
    inline void handleCallPal_15() { /* TODO */ }
    inline void handleCallPal_16() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 566
SIGNATURE:
    inline void handleCallPal_16() 

BODY (preview):
    inline void handleCallPal_16() { /* TODO */ }
    inline void handleCallPal_17() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 567
SIGNATURE:
    inline void handleCallPal_17() 

BODY (preview):
    inline void handleCallPal_17() { /* TODO */ }
    inline void handleCallPal_18() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 568
SIGNATURE:
    inline void handleCallPal_18() 

BODY (preview):
    inline void handleCallPal_18() { /* TODO */ }
    inline void handleCallPal_19() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 569
SIGNATURE:
    inline void handleCallPal_19() 

BODY (preview):
    inline void handleCallPal_19() { /* TODO */ }
    inline void handleCallPal_1A() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 570
SIGNATURE:
    inline void handleCallPal_1A() 

BODY (preview):
    inline void handleCallPal_1A() { /* TODO */ }
    inline void handleCallPal_1B() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 571
SIGNATURE:
    inline void handleCallPal_1B() 

BODY (preview):
    inline void handleCallPal_1B() { /* TODO */ }
    inline void handleCallPal_1C() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 572
SIGNATURE:
    inline void handleCallPal_1C() 

BODY (preview):
    inline void handleCallPal_1C() { /* TODO */ }
    inline void handleCallPal_1D() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 573
SIGNATURE:
    inline void handleCallPal_1D() 

BODY (preview):
    inline void handleCallPal_1D() { /* TODO */ }
    inline void handleCallPal_1E() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 574
SIGNATURE:
    inline void handleCallPal_1E() 

BODY (preview):
    inline void handleCallPal_1E() { /* TODO */ }
    inline void handleCallPal_1F() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 575
SIGNATURE:
    inline void handleCallPal_1F() 

BODY (preview):
    inline void handleCallPal_1F() { /* TODO */ }


================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 577
SIGNATURE:
    inline void handleCallPal_20() 

BODY (preview):
    inline void handleCallPal_20() { /* TODO */ }
    inline void handleCallPal_21() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 578
SIGNATURE:
    inline void handleCallPal_21() 

BODY (preview):
    inline void handleCallPal_21() { /* TODO */ }
    inline void handleCallPal_22() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 579
SIGNATURE:
    inline void handleCallPal_22() 

BODY (preview):
    inline void handleCallPal_22() { /* TODO */ }
    inline void handleCallPal_23() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 580
SIGNATURE:
    inline void handleCallPal_23() 

BODY (preview):
    inline void handleCallPal_23() { /* TODO */ }
    inline void handleCallPal_24() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 581
SIGNATURE:
    inline void handleCallPal_24() 

BODY (preview):
    inline void handleCallPal_24() { /* TODO */ }
    inline void handleCallPal_25() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 582
SIGNATURE:
    inline void handleCallPal_25() 

BODY (preview):
    inline void handleCallPal_25() { /* TODO */ }
    inline void handleCallPal_26() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 583
SIGNATURE:
    inline void handleCallPal_26() 

BODY (preview):
    inline void handleCallPal_26() { /* TODO */ }
    inline void handleCallPal_27() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 584
SIGNATURE:
    inline void handleCallPal_27() 

BODY (preview):
    inline void handleCallPal_27() { /* TODO */ }
    inline void handleCallPal_28() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 585
SIGNATURE:
    inline void handleCallPal_28() 

BODY (preview):
    inline void handleCallPal_28() { /* TODO */ }
    inline void handleCallPal_29() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 586
SIGNATURE:
    inline void handleCallPal_29() 

BODY (preview):
    inline void handleCallPal_29() { /* TODO */ }
    inline void handleCallPal_2A() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 587
SIGNATURE:
    inline void handleCallPal_2A() 

BODY (preview):
    inline void handleCallPal_2A() { /* TODO */ }
    inline void handleCallPal_2B() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 588
SIGNATURE:
    inline void handleCallPal_2B() 

BODY (preview):
    inline void handleCallPal_2B() { /* TODO */ }
    inline void handleCallPal_2C() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 589
SIGNATURE:
    inline void handleCallPal_2C() 

BODY (preview):
    inline void handleCallPal_2C() { /* TODO */ }
    inline void handleCallPal_2D() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 590
SIGNATURE:
    inline void handleCallPal_2D() 

BODY (preview):
    inline void handleCallPal_2D() { /* TODO */ }
    inline void handleCallPal_2E() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 591
SIGNATURE:
    inline void handleCallPal_2E() 

BODY (preview):
    inline void handleCallPal_2E() { /* TODO */ }
    inline void handleCallPal_2F() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 592
SIGNATURE:
    inline void handleCallPal_2F() 

BODY (preview):
    inline void handleCallPal_2F() { /* TODO */ }


================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 594
SIGNATURE:
    inline void handleCallPal_30() 

BODY (preview):
    inline void handleCallPal_30() { /* TODO */ }
    inline void handleCallPal_31() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 595
SIGNATURE:
    inline void handleCallPal_31() 

BODY (preview):
    inline void handleCallPal_31() { /* TODO */ }
    inline void handleCallPal_32() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 596
SIGNATURE:
    inline void handleCallPal_32() 

BODY (preview):
    inline void handleCallPal_32() { /* TODO */ }
    inline void handleCallPal_33() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 597
SIGNATURE:
    inline void handleCallPal_33() 

BODY (preview):
    inline void handleCallPal_33() { /* TODO */ }
    inline void handleCallPal_34() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 598
SIGNATURE:
    inline void handleCallPal_34() 

BODY (preview):
    inline void handleCallPal_34() { /* TODO */ }
    inline void handleCallPal_35() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 599
SIGNATURE:
    inline void handleCallPal_35() 

BODY (preview):
    inline void handleCallPal_35() { /* TODO */ }
    inline void handleCallPal_36() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 600
SIGNATURE:
    inline void handleCallPal_36() 

BODY (preview):
    inline void handleCallPal_36() { /* TODO */ }
    inline void handleCallPal_37() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 601
SIGNATURE:
    inline void handleCallPal_37() 

BODY (preview):
    inline void handleCallPal_37() { /* TODO */ }
    inline void handleCallPal_38() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 602
SIGNATURE:
    inline void handleCallPal_38() 

BODY (preview):
    inline void handleCallPal_38() { /* TODO */ }
    inline void handleCallPal_39() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 603
SIGNATURE:
    inline void handleCallPal_39() 

BODY (preview):
    inline void handleCallPal_39() { /* TODO */ }
    inline void handleCallPal_3A() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 604
SIGNATURE:
    inline void handleCallPal_3A() 

BODY (preview):
    inline void handleCallPal_3A() { /* TODO */ }
    inline void handleCallPal_3B() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 605
SIGNATURE:
    inline void handleCallPal_3B() 

BODY (preview):
    inline void handleCallPal_3B() { /* TODO */ }
    inline void handleCallPal_3C() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 606
SIGNATURE:
    inline void handleCallPal_3C() 

BODY (preview):
    inline void handleCallPal_3C() { /* TODO */ }
    inline void handleCallPal_3D() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 607
SIGNATURE:
    inline void handleCallPal_3D() 

BODY (preview):
    inline void handleCallPal_3D() { /* TODO */ }
    inline void handleCallPal_3E() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 608
SIGNATURE:
    inline void handleCallPal_3E() 

BODY (preview):
    inline void handleCallPal_3E() { /* TODO */ }
    inline void handleCallPal_3F() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 609
SIGNATURE:
    inline void handleCallPal_3F() 

BODY (preview):
    inline void handleCallPal_3F() { /* TODO */ }


================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 611
SIGNATURE:
    inline void handleCallPal_40() 

BODY (preview):
    inline void handleCallPal_40() { /* TODO */ }
    inline void handleCallPal_41() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 612
SIGNATURE:
    inline void handleCallPal_41() 

BODY (preview):
    inline void handleCallPal_41() { /* TODO */ }
    inline void handleCallPal_42() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 613
SIGNATURE:
    inline void handleCallPal_42() 

BODY (preview):
    inline void handleCallPal_42() { /* TODO */ }
    inline void handleCallPal_43() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 614
SIGNATURE:
    inline void handleCallPal_43() 

BODY (preview):
    inline void handleCallPal_43() { /* TODO */ }
    inline void handleCallPal_44() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 615
SIGNATURE:
    inline void handleCallPal_44() 

BODY (preview):
    inline void handleCallPal_44() { /* TODO */ }
    inline void handleCallPal_45() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 616
SIGNATURE:
    inline void handleCallPal_45() 

BODY (preview):
    inline void handleCallPal_45() { /* TODO */ }
    inline void handleCallPal_46() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 617
SIGNATURE:
    inline void handleCallPal_46() 

BODY (preview):
    inline void handleCallPal_46() { /* TODO */ }
    inline void handleCallPal_47() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 618
SIGNATURE:
    inline void handleCallPal_47() 

BODY (preview):
    inline void handleCallPal_47() { /* TODO */ }
    inline void handleCallPal_48() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 619
SIGNATURE:
    inline void handleCallPal_48() 

BODY (preview):
    inline void handleCallPal_48() { /* TODO */ }
    inline void handleCallPal_49() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 620
SIGNATURE:
    inline void handleCallPal_49() 

BODY (preview):
    inline void handleCallPal_49() { /* TODO */ }
    inline void handleCallPal_4A() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 621
SIGNATURE:
    inline void handleCallPal_4A() 

BODY (preview):
    inline void handleCallPal_4A() { /* TODO */ }
    inline void handleCallPal_4B() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 622
SIGNATURE:
    inline void handleCallPal_4B() 

BODY (preview):
    inline void handleCallPal_4B() { /* TODO */ }
    inline void handleCallPal_4C() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 623
SIGNATURE:
    inline void handleCallPal_4C() 

BODY (preview):
    inline void handleCallPal_4C() { /* TODO */ }
    inline void handleCallPal_4D() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 624
SIGNATURE:
    inline void handleCallPal_4D() 

BODY (preview):
    inline void handleCallPal_4D() { /* TODO */ }
    inline void handleCallPal_4E() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 625
SIGNATURE:
    inline void handleCallPal_4E() 

BODY (preview):
    inline void handleCallPal_4E() { /* TODO */ }
    inline void handleCallPal_4F() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 626
SIGNATURE:
    inline void handleCallPal_4F() 

BODY (preview):
    inline void handleCallPal_4F() { /* TODO */ }


================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 628
SIGNATURE:
    inline void handleCallPal_50() 

BODY (preview):
    inline void handleCallPal_50() { /* TODO */ }
    inline void handleCallPal_51() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 629
SIGNATURE:
    inline void handleCallPal_51() 

BODY (preview):
    inline void handleCallPal_51() { /* TODO */ }
    inline void handleCallPal_52() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 630
SIGNATURE:
    inline void handleCallPal_52() 

BODY (preview):
    inline void handleCallPal_52() { /* TODO */ }
    inline void handleCallPal_53() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 631
SIGNATURE:
    inline void handleCallPal_53() 

BODY (preview):
    inline void handleCallPal_53() { /* TODO */ }
    inline void handleCallPal_54() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 632
SIGNATURE:
    inline void handleCallPal_54() 

BODY (preview):
    inline void handleCallPal_54() { /* TODO */ }
    inline void handleCallPal_55() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 633
SIGNATURE:
    inline void handleCallPal_55() 

BODY (preview):
    inline void handleCallPal_55() { /* TODO */ }
    inline void handleCallPal_56() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 634
SIGNATURE:
    inline void handleCallPal_56() 

BODY (preview):
    inline void handleCallPal_56() { /* TODO */ }
    inline void handleCallPal_57() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 635
SIGNATURE:
    inline void handleCallPal_57() 

BODY (preview):
    inline void handleCallPal_57() { /* TODO */ }
    inline void handleCallPal_58() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 636
SIGNATURE:
    inline void handleCallPal_58() 

BODY (preview):
    inline void handleCallPal_58() { /* TODO */ }
    inline void handleCallPal_59() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 637
SIGNATURE:
    inline void handleCallPal_59() 

BODY (preview):
    inline void handleCallPal_59() { /* TODO */ }
    inline void handleCallPal_5A() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 638
SIGNATURE:
    inline void handleCallPal_5A() 

BODY (preview):
    inline void handleCallPal_5A() { /* TODO */ }
    inline void handleCallPal_5B() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 639
SIGNATURE:
    inline void handleCallPal_5B() 

BODY (preview):
    inline void handleCallPal_5B() { /* TODO */ }
    inline void handleCallPal_5C() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 640
SIGNATURE:
    inline void handleCallPal_5C() 

BODY (preview):
    inline void handleCallPal_5C() { /* TODO */ }
    inline void handleCallPal_5D() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 641
SIGNATURE:
    inline void handleCallPal_5D() 

BODY (preview):
    inline void handleCallPal_5D() { /* TODO */ }
    inline void handleCallPal_5E() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 642
SIGNATURE:
    inline void handleCallPal_5E() 

BODY (preview):
    inline void handleCallPal_5E() { /* TODO */ }
    inline void handleCallPal_5F() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 643
SIGNATURE:
    inline void handleCallPal_5F() 

BODY (preview):
    inline void handleCallPal_5F() { /* TODO */ }


================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 645
SIGNATURE:
    inline void handleCallPal_60() 

BODY (preview):
    inline void handleCallPal_60() { /* TODO */ }
    inline void handleCallPal_61() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 646
SIGNATURE:
    inline void handleCallPal_61() 

BODY (preview):
    inline void handleCallPal_61() { /* TODO */ }
    inline void handleCallPal_62() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 647
SIGNATURE:
    inline void handleCallPal_62() 

BODY (preview):
    inline void handleCallPal_62() { /* TODO */ }
    inline void handleCallPal_63() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 648
SIGNATURE:
    inline void handleCallPal_63() 

BODY (preview):
    inline void handleCallPal_63() { /* TODO */ }
    inline void handleCallPal_64() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 649
SIGNATURE:
    inline void handleCallPal_64() 

BODY (preview):
    inline void handleCallPal_64() { /* TODO */ }
    inline void handleCallPal_65() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 650
SIGNATURE:
    inline void handleCallPal_65() 

BODY (preview):
    inline void handleCallPal_65() { /* TODO */ }
    inline void handleCallPal_66() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 651
SIGNATURE:
    inline void handleCallPal_66() 

BODY (preview):
    inline void handleCallPal_66() { /* TODO */ }
    inline void handleCallPal_67() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 652
SIGNATURE:
    inline void handleCallPal_67() 

BODY (preview):
    inline void handleCallPal_67() { /* TODO */ }
    inline void handleCallPal_68() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 653
SIGNATURE:
    inline void handleCallPal_68() 

BODY (preview):
    inline void handleCallPal_68() { /* TODO */ }
    inline void handleCallPal_69() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 654
SIGNATURE:
    inline void handleCallPal_69() 

BODY (preview):
    inline void handleCallPal_69() { /* TODO */ }
    inline void handleCallPal_6A() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 655
SIGNATURE:
    inline void handleCallPal_6A() 

BODY (preview):
    inline void handleCallPal_6A() { /* TODO */ }
    inline void handleCallPal_6B() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 656
SIGNATURE:
    inline void handleCallPal_6B() 

BODY (preview):
    inline void handleCallPal_6B() { /* TODO */ }
    inline void handleCallPal_6C() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 657
SIGNATURE:
    inline void handleCallPal_6C() 

BODY (preview):
    inline void handleCallPal_6C() { /* TODO */ }
    inline void handleCallPal_6D() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 658
SIGNATURE:
    inline void handleCallPal_6D() 

BODY (preview):
    inline void handleCallPal_6D() { /* TODO */ }
    inline void handleCallPal_6E() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 659
SIGNATURE:
    inline void handleCallPal_6E() 

BODY (preview):
    inline void handleCallPal_6E() { /* TODO */ }
    inline void handleCallPal_6F() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 660
SIGNATURE:
    inline void handleCallPal_6F() 

BODY (preview):
    inline void handleCallPal_6F() { /* TODO */ }


================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 662
SIGNATURE:
    inline void handleCallPal_70() 

BODY (preview):
    inline void handleCallPal_70() { /* TODO */ }
    inline void handleCallPal_71() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 663
SIGNATURE:
    inline void handleCallPal_71() 

BODY (preview):
    inline void handleCallPal_71() { /* TODO */ }
    inline void handleCallPal_72() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 664
SIGNATURE:
    inline void handleCallPal_72() 

BODY (preview):
    inline void handleCallPal_72() { /* TODO */ }
    inline void handleCallPal_73() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 665
SIGNATURE:
    inline void handleCallPal_73() 

BODY (preview):
    inline void handleCallPal_73() { /* TODO */ }
    inline void handleCallPal_74() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 666
SIGNATURE:
    inline void handleCallPal_74() 

BODY (preview):
    inline void handleCallPal_74() { /* TODO */ }
    inline void handleCallPal_75() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 667
SIGNATURE:
    inline void handleCallPal_75() 

BODY (preview):
    inline void handleCallPal_75() { /* TODO */ }
    inline void handleCallPal_76() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 668
SIGNATURE:
    inline void handleCallPal_76() 

BODY (preview):
    inline void handleCallPal_76() { /* TODO */ }
    inline void handleCallPal_77() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 669
SIGNATURE:
    inline void handleCallPal_77() 

BODY (preview):
    inline void handleCallPal_77() { /* TODO */ }
    inline void handleCallPal_78() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 670
SIGNATURE:
    inline void handleCallPal_78() 

BODY (preview):
    inline void handleCallPal_78() { /* TODO */ }
    inline void handleCallPal_79() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 671
SIGNATURE:
    inline void handleCallPal_79() 

BODY (preview):
    inline void handleCallPal_79() { /* TODO */ }
    inline void handleCallPal_7A() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 672
SIGNATURE:
    inline void handleCallPal_7A() 

BODY (preview):
    inline void handleCallPal_7A() { /* TODO */ }
    inline void handleCallPal_7B() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 673
SIGNATURE:
    inline void handleCallPal_7B() 

BODY (preview):
    inline void handleCallPal_7B() { /* TODO */ }
    inline void handleCallPal_7C() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 674
SIGNATURE:
    inline void handleCallPal_7C() 

BODY (preview):
    inline void handleCallPal_7C() { /* TODO */ }
    inline void handleCallPal_7D() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 675
SIGNATURE:
    inline void handleCallPal_7D() 

BODY (preview):
    inline void handleCallPal_7D() { /* TODO */ }
    inline void handleCallPal_7E() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 676
SIGNATURE:
    inline void handleCallPal_7E() 

BODY (preview):
    inline void handleCallPal_7E() { /* TODO */ }
    inline void handleCallPal_7F() { /* TODO */ }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PalVectorResolver.h
LINE: 677
SIGNATURE:
    inline void handleCallPal_7F() 

BODY (preview):
    inline void handleCallPal_7F() { /* TODO */ }


================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PAL_core.h
LINE: 135
SIGNATURE:
 constexpr quint16 palVectorOffset(PalVectorId vec) 

BODY (preview):
// constexpr quint16 palVectorOffset(PalVectorId vec) {
// 	return static_cast<quint16>(vec);
// }

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\PAL_core.h
LINE: 139
SIGNATURE:
 constexpr quint64 palVectorAddress(quint64 palBase, PalVectorId vec) 

BODY (preview):
// constexpr quint64 palVectorAddress(quint64 palBase, PalVectorId vec) {
// 	return palBase + palVectorOffset(vec);
// }

================================================================================
FILE: z:\EmulatRApp\pipelineLib\adjustPipeline_inl.h
LINE: 11
SIGNATURE:
inline void adjustPipeline(VAType va) noexcept

BODY (preview):
inline void adjustPipeline(VAType va) noexcept {
	// Enqueue prefetch...
	// PipelineSimulator::enqueuePrefetch(va);

	// Track potential hazard...  
	// PipelineSimulator::trackHazard(va);

	DEBUG_LOG(QString("PIPELINE_ADJUST VA: 0x%1").arg(0, 16, va));
}

================================================================================
FILE: z:\EmulatRApp\pipelineLib\stallPipeLine_inl.h
LINE: 12
SIGNATURE:
inline void stallPipeline_inl(AlphaCPU& cpuState, quint32 delay) noexcept

BODY (preview):
inline void stallPipeline_inl(AlphaCPU& cpuState, quint32 delay) noexcept {

}

================================================================================
FILE: z:\EmulatRApp\pteLib\AlphaPTE_Core.h
LINE: 129
SIGNATURE:
    static inline quint8 pteGH(PTEType raw) noexcept

BODY (preview):
    static inline quint8 pteGH(PTEType raw) noexcept {
        return (raw >> PTE_BIT_GH0) & 0x7;
    }

================================================================================
FILE: z:\EmulatRApp\pteLib\AlphaPTE_Core.h
LINE: 151
SIGNATURE:
	inline void clear() 

BODY (preview):
	inline void clear() { raw = 0; }
	//constexpr AlphaPTE() noexcept : raw(0) {}

================================================================================
FILE: z:\EmulatRApp\pteLib\AlphaPTE_Core.h
LINE: 152
SIGNATURE:
 noexcept : raw(0) 

BODY (preview):
	//constexpr AlphaPTE() noexcept : raw(0) {}
	constexpr AlphaPTE() noexcept : raw(0), cow(false) {}

================================================================================
FILE: z:\EmulatRApp\pteLib\AlphaPTE_Core.h
LINE: 164
SIGNATURE:
	static constexpr AlphaPTE fromRaw(quint64 rawValue) noexcept

BODY (preview):
	static constexpr AlphaPTE fromRaw(quint64 rawValue) noexcept {
		return AlphaPTE(rawValue);
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\AlphaPTE_Core.h
LINE: 170
SIGNATURE:
	static constexpr AlphaPTE makeInvalid() noexcept

BODY (preview):
	static constexpr AlphaPTE makeInvalid() noexcept {
		return AlphaPTE(0);
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\AlphaPTE_Core.h
LINE: 219
SIGNATURE:
	constexpr void insert(quint64 value) noexcept

BODY (preview):
	constexpr void insert(quint64 value) noexcept {
		static_assert(Start + Len <= 64, "Bit range exceeds 64-bit width");
		constexpr quint64 maskCore = (Len == 64) ? ~0ULL : ((1ULL << Len) - 1ULL);
		const quint64 mask = (maskCore << Start);
		raw = (raw & ~mask) | ((value << Start) & mask);
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\AlphaPTE_Core.h
LINE: 294
SIGNATURE:
	constexpr void setPfn(PFNType pfnValue) noexcept

BODY (preview):
	constexpr void setPfn(PFNType pfnValue) noexcept {
		insert<32, 28>(static_cast<PFNType>(pfnValue));
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\AlphaPTE_Core.h
LINE: 324
SIGNATURE:
	constexpr void setAsm(bool asmFlag) noexcept

BODY (preview):
	constexpr void setAsm(bool asmFlag)  noexcept {
		insert<PTE_BIT_ASM, 1>(asmFlag ? 1ULL : 0ULL);
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\AlphaPTE_Core.h
LINE: 362
SIGNATURE:
	constexpr void setReadPermissions(bool kre, bool ure) noexcept

BODY (preview):
	constexpr void setReadPermissions(bool kre, bool ure) noexcept {
		insert<PTE_BIT_KRE, 1>(kre ? 1ULL : 0ULL);
		insert<PTE_BIT_URE, 1>(ure ? 1ULL : 0ULL);
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\AlphaPTE_Core.h
LINE: 369
SIGNATURE:
	constexpr void setReadPermissions(bool kre, bool ere, bool sre, bool ure) noexcept

BODY (preview):
	constexpr void setReadPermissions(bool kre, bool ere, bool sre, bool ure) noexcept {
		const bool kreCanonical = kre || ere || sre;
		setReadPermissions(kreCanonical, ure);
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\AlphaPTE_Core.h
LINE: 374
SIGNATURE:
	constexpr void setWritePermissions(bool kwe, bool uwe) noexcept

BODY (preview):
	constexpr void setWritePermissions(bool kwe, bool uwe) noexcept {
		insert<PTE_BIT_KWE, 1>(kwe ? 1ULL : 0ULL);
		insert<PTE_BIT_UWE, 1>(uwe ? 1ULL : 0ULL);
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\AlphaPTE_Core.h
LINE: 381
SIGNATURE:
	constexpr void setWritePermissions(bool kwe, bool ewe, bool swe, bool uwe) noexcept

BODY (preview):
	constexpr void setWritePermissions(bool kwe, bool ewe, bool swe, bool uwe) noexcept {
		const bool kweCanonical = kwe || ewe || swe;
		setWritePermissions(kweCanonical, uwe);
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_pte_core.h
LINE: 144
SIGNATURE:
 noexcept : raw(0) 

BODY (preview):
// 		constexpr AlphaPTE() noexcept : raw(0) {}
// 		explicit constexpr AlphaPTE(quint64 value) noexcept : raw(value) {}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_pte_core.h
LINE: 145
SIGNATURE:
 noexcept : raw(value) 

BODY (preview):
// 		explicit constexpr AlphaPTE(quint64 value) noexcept : raw(value) {}
// 

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_pte_core.h
LINE: 162
SIGNATURE:
 		constexpr void insert(quint64 value) noexcept

BODY (preview):
// 		constexpr void insert(quint64 value) noexcept {
// 			static_assert(Start + Len <= 64, "Bit range exceeds 64-bit width");
// 			constexpr quint64 mask = ((1ULL << Len) - 1) << Start;
// 			raw = (raw & ~mask) | ((value << Start) & mask);
// 		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_pte_core.h
LINE: 172
SIGNATURE:
 static constexpr quint64 pageShift(PageSizeCode code) noexcept

BODY (preview):
		[[nodiscard]] static constexpr quint64 pageShift(PageSizeCode code) noexcept {
			switch (code) {
			case PageSizeCode::PageSize_4K:  return 12;
			case PageSizeCode::PageSize_8K:  return 13;
			case PageSizeCode::PageSize_64K: return 16;
			default: return 12;  // Default 4K
			}
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_pte_core.h
LINE: 173
SIGNATURE:
	 switch(code) 

BODY (preview):
			switch (code) {
			case PageSizeCode::PageSize_4K:  return 12;
			case PageSizeCode::PageSize_8K:  return 13;
			case PageSizeCode::PageSize_64K: return 16;
			default: return 12;  // Default 4K
			}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_pte_core.h
LINE: 181
SIGNATURE:
 static constexpr quint64 pageSizeBytes(PageSizeCode code) noexcept

BODY (preview):
		[[nodiscard]] static constexpr quint64 pageSizeBytes(PageSizeCode code) noexcept {
			return 1ULL << pageShift(code);
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_pte_core.h
LINE: 189
SIGNATURE:
 static constexpr bool allowRead(AccessPerm perm, bool userMode) noexcept

BODY (preview):
		[[nodiscard]] static constexpr bool allowRead(AccessPerm perm, bool userMode) noexcept {
			switch (perm) {
			case AccessPerm::Read:
			case AccessPerm::ReadExec:
			case AccessPerm::ReadWrite:
			case AccessPerm::Full:
				return true;
			default:
				return false;
			}
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_pte_core.h
LINE: 190
SIGNATURE:
	 switch(perm) 

BODY (preview):
			switch (perm) {
			case AccessPerm::Read:
			case AccessPerm::ReadExec:
			case AccessPerm::ReadWrite:
			case AccessPerm::Full:
				return true;
			default:
				return false;
			}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_pte_core.h
LINE: 201
SIGNATURE:
 static constexpr bool allowWrite(AccessPerm perm, bool userMode) noexcept

BODY (preview):
		[[nodiscard]] static constexpr bool allowWrite(AccessPerm perm, bool userMode) noexcept {
			switch (perm) {
			case AccessPerm::Write:
			case AccessPerm::WriteExec:
			case AccessPerm::ReadWrite:
			case AccessPerm::Full:
				return true;
			default:
				return false;
			}
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_pte_core.h
LINE: 202
SIGNATURE:
	 switch(perm) 

BODY (preview):
			switch (perm) {
			case AccessPerm::Write:
			case AccessPerm::WriteExec:
			case AccessPerm::ReadWrite:
			case AccessPerm::Full:
				return true;
			default:
				return false;
			}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_pte_core.h
LINE: 213
SIGNATURE:
 static constexpr bool allowExecute(AccessPerm perm, bool userMode) noexcept

BODY (preview):
		[[nodiscard]] static constexpr bool allowExecute(AccessPerm perm, bool userMode) noexcept {
			switch (perm) {
			case AccessPerm::Execute:
			case AccessPerm::ReadExec:
			case AccessPerm::WriteExec:
			case AccessPerm::Full:
				return true;
			default:
				return false;
			}
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_pte_core.h
LINE: 214
SIGNATURE:
	 switch(perm) 

BODY (preview):
			switch (perm) {
			case AccessPerm::Execute:
			case AccessPerm::ReadExec:
			case AccessPerm::WriteExec:
			case AccessPerm::Full:
				return true;
			default:
				return false;
			}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_pte_traits_ev6_itb.h
LINE: 110
SIGNATURE:
           if(pfn != 0) 

BODY (preview):
            if (pfn != 0) {
                pte.setValid(true);
            }

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_bucket.h
LINE: 38
SIGNATURE:
		void attachAsnEpochs(const AsnGenTable* tbl) noexcept

BODY (preview):
		void attachAsnEpochs(const AsnGenTable* tbl) noexcept { m_asnEpochs = tbl; }
		Entry                   m_entries[AssocWays]{};

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_bucket.h
LINE: 45
SIGNATURE:
		bool tryClaimSlot(unsigned& idx) noexcept

BODY (preview):
		bool tryClaimSlot(unsigned& idx) noexcept {
			for (;;) {
				const quint64 cur = m_occ.loadRelaxed();
				const quint64 used = cur & FULL_MASK;
				if (used == FULL_MASK) return false;
				const quint64 freeBits = (~used) & FULL_MASK;
				const int     bit = qCountTrailingZeroBits(freeBits);
				const quint64 want = cur | (1ULL << bit);
				if (m_occ.testAndSetRelaxed(cur, want)) {
					idx = static_cast<unsigned>(bit);
					return true;
				}
			}
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_bucket.h
LINE: 46
SIGNATURE:
	 for(;;) 

BODY (preview):
			for (;;) {
				const quint64 cur = m_occ.loadRelaxed();
				const quint64 used = cur & FULL_MASK;
				if (used == FULL_MASK) return false;
				const quint64 freeBits = (~used) & FULL_MASK;
				const int     bit = qCountTrailingZeroBits(freeBits);
				const quint64 want = cur | (1ULL << bit);
				if (m_occ.testAndSetRelaxed(cur, want)) {
					idx = static_cast<unsigned>(bit);
					return true;
				}
			}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_bucket.h
LINE: 60
SIGNATURE:
		inline void beginWrite() noexcept

BODY (preview):
		inline void beginWrite() noexcept { m_ver.fetchAndAddRelease(1); } // odd
		inline void endWrite()   noexcept { m_ver.fetchAndAddRelease(1); } // even

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_bucket.h
LINE: 61
SIGNATURE:
		inline void endWrite() noexcept

BODY (preview):
		inline void endWrite()   noexcept { m_ver.fetchAndAddRelease(1); } // even


================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_bucket.h
LINE: 64
SIGNATURE:
		bool insert(Entry e) noexcept

BODY (preview):
		bool insert(Entry e) noexcept {
			unsigned slot;
			if (!tryClaimSlot(slot)) return false;
			beginWrite();
			e.flags.transitioning = false;
			e.flags.valid = false;
			m_entries[slot] = e;
			m_entries[slot].flags.valid = true; // publish last
			endWrite();
			return true;
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_bucket.h
LINE: 76
SIGNATURE:
		void invalidate(unsigned slot) noexcept

BODY (preview):
		void invalidate(unsigned slot) noexcept {
			if (slot >= AssocWays) return;
			beginWrite();
			m_entries[slot].flags.valid = false;
			quint64 cur;
			const quint64 mask = ~(1ULL << slot);
			do { cur = m_occ.loadRelaxed(); } while (!m_occ.testAndSetRelaxed(cur, cur & mask));
			endWrite();
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_bucket.h
LINE: 86
SIGNATURE:
		bool invalidateMatching(const Tag& tag,  ASNType asn) noexcept

BODY (preview):
		bool invalidateMatching(const Tag& tag,  ASNType asn) noexcept {
			const quint64 used = m_occ.loadRelaxed() & FULL_MASK;
			for (unsigned i = 0; i < AssocWays; ++i) {
				if (((used >> i) & 1ULL) == 0ULL) continue;
				Entry* e = &m_entries[i];
				if (!e->flags.valid) continue;
				if (e->tag == tag) {
					const bool match =
						e->flags.global ||
						(e->asn == asn && e->asnGenAtFill == currentAsnGen(asn));
					if (match) {
						invalidate(i);
						return true;
					}
				}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_bucket.h
LINE: 88
SIGNATURE:
	 for(unsigned i = 0; i < AssocWays; ++i) 

BODY (preview):
			for (unsigned i = 0; i < AssocWays; ++i) {
				if (((used >> i) & 1ULL) == 0ULL) continue;
				Entry* e = &m_entries[i];
				if (!e->flags.valid) continue;
				if (e->tag == tag) {
					const bool match =
						e->flags.global ||
						(e->asn == asn && e->asnGenAtFill == currentAsnGen(asn));
					if (match) {
						invalidate(i);
						return true;
					}
				}
			}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_bucket.h
LINE: 92
SIGNATURE:
		 if(e->tag == tag) 

BODY (preview):
				if (e->tag == tag) {
					const bool match =
						e->flags.global ||
						(e->asn == asn && e->asnGenAtFill == currentAsnGen(asn));
					if (match) {
						invalidate(i);
						return true;
					}
				}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_bucket.h
LINE: 96
SIGNATURE:
			 if(match) 

BODY (preview):
					if (match) {
						invalidate(i);
						return true;
					}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_bucket.h
LINE: 106
SIGNATURE:
		void sweepDeadForASN(quint8 asn, quint16 curGen) noexcept

BODY (preview):
		void sweepDeadForASN(quint8 asn, quint16 curGen) noexcept {
			// Sweep entries belonging to the given ASN whose epoch snapshot
			// no longer matches curGen. These are "dead" entries after an
			// ASN epoch bump (IAP / TBIA-like operations).
			//
			// Architectural intent:
			// - Entries with flags.global == true are NOT removed here; they
			//   remain valid across ASN changes (per Alpha SRM, global TBEs).
			// - Entries with e.asn == asn and e.asnGenAtFill != curGen are
			//   cleared, since they were filled under an older ASN epoch.
			//
			// NOTE:
			// - We call invalidate(i) per slot, which handles seqlock and
			//   occupancy bits. No need for additional beginWrite/endWrite here.


================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_bucket.h
LINE: 122
SIGNATURE:
	 for(unsigned i = 0; i < AssocWays; ++i) 

BODY (preview):
			for (unsigned i = 0; i < AssocWays; ++i) {
				if (((used >> i) & 1ULL) == 0ULL)
					continue; // slot not in use

				Entry* e = &m_entries[i];

				// Skip invalid or transitioning entries
				if (!e->flags.valid || e->flags.transitioning)
					continue;

				// Global entries are not swept by per-ASN sweep
				if (e->flags.global)
					continue;

				// Only entries belonging to this ASN are candidates

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_bucket.h
LINE: 149
SIGNATURE:
		Entry* find(const Tag& tag, quint8 asn) noexcept

BODY (preview):
		Entry* find(const Tag& tag, quint8 asn) noexcept {
			for (;;) {
				const quint32 v0 = m_ver.loadAcquire();
				if (v0 & 1u) continue; // writer active
				const quint64 used = m_occ.loadRelaxed() & FULL_MASK;

				for (unsigned i = 0; i < AssocWays; ++i) {
					if (((used >> i) & 1ULL) == 0ULL) continue;
					Entry* e = &m_entries[i];
					if (!e->flags.valid || e->flags.transitioning) continue;
					if (!(e->tag == tag)) continue;

					const bool ok = e->flags.global ||
						(e->asn == asn && e->asnGenAtFill == currentAsnGen(asn));
					if (!ok) continue;

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_bucket.h
LINE: 150
SIGNATURE:
	 for(;;) 

BODY (preview):
			for (;;) {
				const quint32 v0 = m_ver.loadAcquire();
				if (v0 & 1u) continue; // writer active
				const quint64 used = m_occ.loadRelaxed() & FULL_MASK;

				for (unsigned i = 0; i < AssocWays; ++i) {
					if (((used >> i) & 1ULL) == 0ULL) continue;
					Entry* e = &m_entries[i];
					if (!e->flags.valid || e->flags.transitioning) continue;
					if (!(e->tag == tag)) continue;

					const bool ok = e->flags.global ||
						(e->asn == asn && e->asnGenAtFill == currentAsnGen(asn));
					if (!ok) continue;


================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_bucket.h
LINE: 155
SIGNATURE:
		 for(unsigned i = 0; i < AssocWays; ++i) 

BODY (preview):
				for (unsigned i = 0; i < AssocWays; ++i) {
					if (((used >> i) & 1ULL) == 0ULL) continue;
					Entry* e = &m_entries[i];
					if (!e->flags.valid || e->flags.transitioning) continue;
					if (!(e->tag == tag)) continue;

					const bool ok = e->flags.global ||
						(e->asn == asn && e->asnGenAtFill == currentAsnGen(asn));
					if (!ok) continue;

					const quint32 v1 = m_ver.loadAcquire();
					if (v0 == v1) return e; // seqlock stable
					// else retry outer loop
				}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 48
SIGNATURE:
	unsigned chooseVictim(Realm realm, SC_Type sizeClass, unsigned bucketIndex) noexcept

BODY (preview):
	unsigned chooseVictim(Realm realm, SC_Type sizeClass, unsigned bucketIndex) noexcept {
		CPUIdType cpuId = CurrentCpuTLS::get();
		// Default implementation can be overridden
		for (unsigned i = 0; i < AssocWays; ++i) {
			// Find first non-locked entry
			auto& buck = bucket(cpuId, realm, sizeClass, bucketIndex);
			const Entry& e = buck.m_entries[i];
			if (!e.flags.locked) return i;
		}
		return AssocWays;  // No victim found
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 51
SIGNATURE:
 for(unsigned i = 0; i < AssocWays; ++i) 

BODY (preview):
		for (unsigned i = 0; i < AssocWays; ++i) {
			// Find first non-locked entry
			auto& buck = bucket(cpuId, realm, sizeClass, bucketIndex);
			const Entry& e = buck.m_entries[i];
			if (!e.flags.locked) return i;
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 99
SIGNATURE:
 for(int c = 0; c < m_cpuCount; ++c) 

BODY (preview):
		for (int c = 0; c < m_cpuCount; ++c) {
			for (unsigned a = 0; a < MaxASN; ++a) {
				m_sweepScheduled[c].flag[a].storeRelaxed(0);
			}
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 100
SIGNATURE:
	 for(unsigned a = 0; a < MaxASN; ++a) 

BODY (preview):
			for (unsigned a = 0; a < MaxASN; ++a) {
				m_sweepScheduled[c].flag[a].storeRelaxed(0);
			}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 119
SIGNATURE:
 for(int c = 0; c < m_cpuCount; ++c) 

BODY (preview):
		for (int c = 0; c < m_cpuCount; ++c) {

			// number of active size classes (1 if ShardBySize=false)
			const int sizeSlots = ShardBySize ? kSizeClassCount : 1;

			for (int r = 0; r < kRealmCount; ++r) {
				for (int s = 0; s < sizeSlots; ++s) {
					for (unsigned b = 0; b < BucketCount; ++b) {

						// compute flat index
						const size_t flatIndex = idx(c, r, s, b);

						// attach this bucket to the per-CPU ASN epoch table
						m_buckets[flatIndex].attachAsnEpochs(&m_asnEpochs[c]);
					}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 124
SIGNATURE:
	 for(int r = 0; r < kRealmCount; ++r) 

BODY (preview):
			for (int r = 0; r < kRealmCount; ++r) {
				for (int s = 0; s < sizeSlots; ++s) {
					for (unsigned b = 0; b < BucketCount; ++b) {

						// compute flat index
						const size_t flatIndex = idx(c, r, s, b);

						// attach this bucket to the per-CPU ASN epoch table
						m_buckets[flatIndex].attachAsnEpochs(&m_asnEpochs[c]);
					}
				}
			}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 125
SIGNATURE:
		 for(int s = 0; s < sizeSlots; ++s) 

BODY (preview):
				for (int s = 0; s < sizeSlots; ++s) {
					for (unsigned b = 0; b < BucketCount; ++b) {

						// compute flat index
						const size_t flatIndex = idx(c, r, s, b);

						// attach this bucket to the per-CPU ASN epoch table
						m_buckets[flatIndex].attachAsnEpochs(&m_asnEpochs[c]);
					}
				}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 126
SIGNATURE:
			 for(unsigned b = 0; b < BucketCount; ++b) 

BODY (preview):
					for (unsigned b = 0; b < BucketCount; ++b) {

						// compute flat index
						const size_t flatIndex = idx(c, r, s, b);

						// attach this bucket to the per-CPU ASN epoch table
						m_buckets[flatIndex].attachAsnEpochs(&m_asnEpochs[c]);
					}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 168
SIGNATURE:
	void maintenanceTick(CPUIdType cpuId, int bucketBudgetPerASN = -1) 

BODY (preview):
	void maintenanceTick(CPUIdType cpuId, int bucketBudgetPerASN = -1) {
		// Snapshot all ASNs that requested a sweep
		for (unsigned asn = 0; asn < MAX_ASN; ++asn) {
			// 
			if (m_sweepScheduled[cpuId].flag[asn].loadRelaxed() == 0)
				continue;

			// Confirm current epoch; entries with a different snapshot are "dead"
			const quint16 curGen = m_asnEpochs[cpuId].gen[asn].loadRelaxed();  // <- Also check this!

			// Sweep this shard: [Realm][SizeClass][Bucket]
			const int rCount = kRealmCount;
			const int sCount = (ShardBySize ? kSizeClassCount : 1);

			int sweptBuckets = 0;

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 170
SIGNATURE:
 for(unsigned asn = 0; asn < MAX_ASN; ++asn) 

BODY (preview):
		for (unsigned asn = 0; asn < MAX_ASN; ++asn) {
			// 
			if (m_sweepScheduled[cpuId].flag[asn].loadRelaxed() == 0)
				continue;

			// Confirm current epoch; entries with a different snapshot are "dead"
			const quint16 curGen = m_asnEpochs[cpuId].gen[asn].loadRelaxed();  // <- Also check this!

			// Sweep this shard: [Realm][SizeClass][Bucket]
			const int rCount = kRealmCount;
			const int sCount = (ShardBySize ? kSizeClassCount : 1);

			int sweptBuckets = 0;
			for (int r = 0; r < rCount; ++r) {
				for (int s = 0; s < sCount; ++s) {

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 183
SIGNATURE:
	 for(int r = 0; r < rCount; ++r) 

BODY (preview):
			for (int r = 0; r < rCount; ++r) {
				for (int s = 0; s < sCount; ++s) {
					// NOTE: This line also needs fixing - see below
					auto& row = m_buckets[cpuId][r][s];
					const int B = int(row.size());
					for (int b = 0; b < B; ++b) {
						row[b].sweepDeadForASN(quint8(asn), curGen);
						if (bucketBudgetPerASN > 0 && ++sweptBuckets >= bucketBudgetPerASN) {
							goto partial_done;
						}
					}
				}
			}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 184
SIGNATURE:
		 for(int s = 0; s < sCount; ++s) 

BODY (preview):
				for (int s = 0; s < sCount; ++s) {
					// NOTE: This line also needs fixing - see below
					auto& row = m_buckets[cpuId][r][s];
					const int B = int(row.size());
					for (int b = 0; b < B; ++b) {
						row[b].sweepDeadForASN(quint8(asn), curGen);
						if (bucketBudgetPerASN > 0 && ++sweptBuckets >= bucketBudgetPerASN) {
							goto partial_done;
						}
					}
				}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 188
SIGNATURE:
			 for(int b = 0; b < B; ++b) 

BODY (preview):
					for (int b = 0; b < B; ++b) {
						row[b].sweepDeadForASN(quint8(asn), curGen);
						if (bucketBudgetPerASN > 0 && ++sweptBuckets >= bucketBudgetPerASN) {
							goto partial_done;
						}
					}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 190
SIGNATURE:
				 if(bucketBudgetPerASN > 0 && ++sweptBuckets >= bucketBudgetPerASN) 

BODY (preview):
						if (bucketBudgetPerASN > 0 && ++sweptBuckets >= bucketBudgetPerASN) {
							goto partial_done;
						}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 214
SIGNATURE:
	bool lookupPTE(VAType va, AlphaPTE& pteOut) 

BODY (preview):
	bool lookupPTE(VAType va, AlphaPTE& pteOut) {

		// 1. Determine which CPU shard to use (you may want to pass cpuId as an argument if not always 0)
		// For now, use CPU 0. In SMP, you'll want to parameterize this!
		CPUIdType cpuId = 0;

		// 2. Determine realm and sizeClass (could be parameterized too)
		// For demonstration, assume data realm and sizeClass 0 (no superpages).
		Realm realm = Realm::D;      // Or Realm::I for instruction
		SC_Type sizeClass = 0;        // Superpage support? Use the appropriate class.

		// 3. ASN (Address Space Number) - again, ideally parameterized!
		ASNType asn = currentAsn(cpuId);

		// 4. Make tag and find entry

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 262
SIGNATURE:
 if(result) 

BODY (preview):
		if (result) {
			m_telemetry.totalHits.fetchAndAddRelaxed(1);
			m_telemetry.totalProbes.fetchAndAddRelaxed(1);
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 279
SIGNATURE:
	void resetTelemetry() noexcept

BODY (preview):
	void resetTelemetry() noexcept {
		m_telemetry = ShardTelemetry{};
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 284
SIGNATURE:
	void itbTagWrite(CPUIdType cpuId, const Tag& tag, ASNType asn, quint8 gh, bool bITB1) 

BODY (preview):
	void itbTagWrite(CPUIdType cpuId, const Tag& tag, ASNType asn, quint8 gh, bool bITB1) {
		Q_UNUSED(cpuId);
		Q_UNUSED(tag);
		Q_UNUSED(asn);
		Q_UNUSED(gh);
		Q_UNUSED(bITB1);

		// TODO:
		// In a full implementation, this should:
		// - Cache the ITB tag information (tag, asn, gh, bITB1) in a per-CPU
		//   scratch structure, so that a subsequent ITB_PTE write can use it.
		// - Decode GH and bITB1 to determine the effective sizeClass and whether
		//   the entry belongs in ITB0 or ITB1.
		//
		// For now, we keep this as a no-op to avoid impacting functional behavior.

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 305
SIGNATURE:
 	static inline Tag makeTag(quint64 va, Realm realm, quint8 sizeClass) noexcept

BODY (preview):
// 	static inline Tag makeTag(quint64 va, Realm realm, quint8 sizeClass) noexcept {
// 		Tag t;
// 		t.vpn = va >> PAGE_SHIFT; // all gens fixed to 8 KiB per your traits
// 		t.realm = (realm == Realm::I) ? 1 : 0;
// 		t.sizeClass = sizeClass;                // encodeSizeClass(SizeClassId)
// 		return t;
// 	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 315
SIGNATURE:
	static inline unsigned bucketIndex(const Tag& t) noexcept

BODY (preview):
	static inline unsigned bucketIndex(const Tag& t) noexcept {
		// simple 64-bit mix (splitmix-like)
		quint64 x = t.vpn ^ (quint64(t.realm) << 1) ^ (SC_Type(t.sizeClass) << 2);
		x ^= x >> 33; x *= 0xff51afd7ed558ccdULL;
		x ^= x >> 33; x *= 0xc4ceb9fe1a85ec53ULL;
		x ^= x >> 33;
		return unsigned(x) & (BucketCount - 1);
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 350
SIGNATURE:
	void insertInstructionEntry(TAGType tag, const AlphaPTE& pte) 

BODY (preview):
	void insertInstructionEntry(TAGType tag, const AlphaPTE& pte) {
		// This is called by the ITB_PTE IPR write handler.
		//
		// Architectural intent (Alpha SRM, ITB_TAG/ITB_PTE):
		// - ITB_TAG holds VPN, ASN, GH, and bank selection (ITB0/ITB1).
		// - ITB_PTE provides the PTE bits.
		// - On ITB_PTE write, the hardware inserts a translation into the ITB.
		//
		// Simplified model:
		// - Treat 'tag' as page-aligned VA (VPN << PAGE_SHIFT).
		// - Use current ASN from CPU context.
		// - Realm = Instruction (Realm::I).
		// - Size class = 0 (no superpage modeling yet).
		// - Global bit derived from traits (if available) or assumed false.


================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 383
SIGNATURE:
	inline void invalidateASN(CPUIdType cpuId, ASNType asn) noexcept

BODY (preview):
	inline void invalidateASN(CPUIdType cpuId, ASNType asn) noexcept {
        m_asnEpochs[cpuId].gen[asn].fetchAndAddRelaxed(1);

		// Near-wrap threshold: 0xFF00 triggers a one-time lazy sweep request.
		// We only set the flag once; maintenanceTick() will clear it after sweeping.
// 			if (newVal >= 0xFF00) {
// 				// Set to 1 if currently 0; ignore if already scheduled.
// 				quint8 expected = 0;
// 				m_sweepScheduled[cpuId][asn].testAndSetRelaxed(expected, quint8(1));
// 			}
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 388
SIGNATURE:
 	 if(newVal >= 0xFF00) 

BODY (preview):
// 			if (newVal >= 0xFF00) {
// 				// Set to 1 if currently 0; ignore if already scheduled.
// 				quint8 expected = 0;
// 				m_sweepScheduled[cpuId][asn].testAndSetRelaxed(expected, quint8(1));
// 			}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 397
SIGNATURE:
	void invalidateASN_AllShards(quint8 asn) noexcept

BODY (preview):
	void invalidateASN_AllShards(quint8 asn) noexcept {
		const int cpuCount = m_cpuCount;   // or however you store it
		for (int c = 0; c < cpuCount; ++c) {
			// Local shard bump; Relaxed is fine with seqlock readers. Use Release if you prefer.
            m_asnEpochs[c].gen[asn].fetchAndAddRelaxed(1);
		}
		// We need to send an invalidation notice via SMP IPI layer, replace the loop above with queued IPIs
		// that call invalidateASN(localCpu, asn) on each CPU's shard thread.
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 399
SIGNATURE:
 for(int c = 0; c < cpuCount; ++c) 

BODY (preview):
		for (int c = 0; c < cpuCount; ++c) {
			// Local shard bump; Relaxed is fine with seqlock readers. Use Release if you prefer.
            m_asnEpochs[c].gen[asn].fetchAndAddRelaxed(1);
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 410
SIGNATURE:
	void tbis(CPUIdType cpuId, Realm realm, SC_Type sizeClass, VAType va, ASNType asn) noexcept

BODY (preview):
	void tbis(CPUIdType cpuId, Realm realm, SC_Type sizeClass, VAType va, ASNType asn) noexcept {
		const Tag t = makeTag(va, realm, sizeClassFor(sizeClass));
		auto& buck = bucket(cpuId, realm, sizeClass, bucketIndex(t));
		// simple victiming: probe occupied slots and invalidate matches
		buck.invalidateMatching(t, asn);
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 418
SIGNATURE:
	void tbia(CPUIdType cpuId) noexcept

BODY (preview):
	void tbia(CPUIdType cpuId) noexcept {
		for (unsigned a = 0; a < MaxASN; ++a)
            m_asnEpochs[cpuId].gen[a].fetchAndAddRelaxed(1);
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 424
SIGNATURE:
	static inline quint8 sizeClassFor(quint8 sc) noexcept

BODY (preview):
	static inline quint8 sizeClassFor(quint8 sc) noexcept {
		return ShardBySize ? sc : 0;
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 468
SIGNATURE:
 switch(bankPolicy) 

BODY (preview):
		switch (bankPolicy) {
		case DTBBankPolicy::AUTO_SELECT:
			// Use VA[12] to select appropriate bank (DEFAULT)
			if (isBank0VA(va)) {
				insertBank0 = true;
			}
			else {
				insertBank1 = true;
			}
			break;

		case DTBBankPolicy::DUAL_BANK:
			// Insert into BOTH banks
			insertBank0 = true;
			insertBank1 = true;

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 497
SIGNATURE:
 if(insertBank0) 

BODY (preview):
		if (insertBank0) {
			// Ensure VA has Bank 0 signature (clear bit 12)
			VAType bank0VA = va & ~(1ULL << 12);
			bool result = tlbInsert(cpuId, Realm::D, sizeClass,
				bank0VA, asn, isGlobal, pteRaw);
			success = success && result;
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 506
SIGNATURE:
 if(insertBank1) 

BODY (preview):
		if (insertBank1) {
			// Ensure VA has Bank 1 signature (set bit 12)
			VAType bank1VA = va | (1ULL << 12);
			bool result = tlbInsert(cpuId, Realm::D, sizeClass,
				bank1VA, asn, isGlobal, pteRaw);
			success = success && result;
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 531
SIGNATURE:
 switch(bankPolicy) 

BODY (preview):
		switch (bankPolicy) {
		case DTBBankPolicy::AUTO_SELECT:
			// Invalidate appropriate bank based on VA[12]
			if (isBank0VA(va)) {
				invalidateBank0 = true;
			}
			else {
				invalidateBank1 = true;
			}
			break;

		case DTBBankPolicy::DUAL_BANK:
			// Invalidate BOTH banks
			invalidateBank0 = true;
			invalidateBank1 = true;

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 558
SIGNATURE:
 if(invalidateBank0) 

BODY (preview):
		if (invalidateBank0) {
			VAType bank0VA = va & ~(1ULL << 12);
			tlbTBIS(cpuId, Realm::D, sizeClass, bank0VA, asn);
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 564
SIGNATURE:
 if(invalidateBank1) 

BODY (preview):
		if (invalidateBank1) {
			VAType bank1VA = va | (1ULL << 12);
			tlbTBIS(cpuId, Realm::D, sizeClass, bank1VA, asn);
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 591
SIGNATURE:
 if(tlbRealm == TLBRealm::ITB) 

BODY (preview):
		if (tlbRealm == TLBRealm::ITB) {
			return tlbInsert(cpuId, realm, sizeClass, va, asn, isGlobal, pteRaw);
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 599
SIGNATURE:
 switch(bankPolicy) 

BODY (preview):
		switch (bankPolicy) {
		case DTBBankPolicy::AUTO_SELECT:
			// Use VA[12] to select appropriate bank
			if (isBank0VA(va)) {
				insertBank0 = true;
			}
			else {
				insertBank1 = true;
			}
			break;

		case DTBBankPolicy::DUAL_BANK:
			insertBank0 = true;
			insertBank1 = true;
			break;

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 626
SIGNATURE:
 if(insertBank0) 

BODY (preview):
		if (insertBank0) {
			VAType bank0VA = va & ~(1ULL << 12);
			bool result = tlbInsert(cpuId, realm, sizeClass,
				bank0VA, asn, isGlobal, pteRaw);
			success = success && result;
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 633
SIGNATURE:
 if(insertBank1) 

BODY (preview):
		if (insertBank1) {
			VAType bank1VA = va | (1ULL << 12);
			bool result = tlbInsert(cpuId, realm, sizeClass,
				bank1VA, asn, isGlobal, pteRaw);
			success = success && result;
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 724
SIGNATURE:
 for(int c = 0; c < cpuCount; ++c) 

BODY (preview):
		for (int c = 0; c < cpuCount; ++c) {
            m_asnEpochs[c].gen[asn].fetchAndAddRelaxed(1);
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 825
SIGNATURE:
	 if(realm == Realm::I) 

BODY (preview):
			if (realm == Realm::I) {
				// ITB: Simple insertion (no bank concept)
				tlbInsert(cpuId, realm, sizeClass, va, asn, pte.bitASM() == 0, pte);
			}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 848
SIGNATURE:
	inline void adjustPipeline(VAType va) noexcept

BODY (preview):
	inline void adjustPipeline(VAType va) noexcept {
		// Enqueue prefetch...
		// PipelineSimulator::enqueuePrefetch(va);

		// Track potential hazard...  
		// PipelineSimulator::trackHazard(va);

        //DEBUG_LOG(QString("PIPELINE_ADJUST VA: 0x").arg(0, 16, va)); // << std::hex << va);
        DEBUG_LOG(std::format("PIPELINE_ADJUST VA: 0x{:X}", va));
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 880
SIGNATURE:
 	inline Bucket& bucket(quint8 cpuId, Realm realm, quint8 sizeClass, unsigned idx) noexcept

BODY (preview):
// 	inline Bucket& bucket(quint8 cpuId, Realm realm, quint8 sizeClass, unsigned idx) noexcept {
// 		const int c = qBound<CPUIdType>(0, int(cpuId), m_cpuCount - 1);
// 		const int r = (realm == Realm::I) ? 1 : 0;
// 		const int s = sizeClassFor(sizeClass);
// /*		return m_buckets[c][r][s][idx];  // Qt semantecs - Qt is vector peformance is inefficient for this.*/
// 		return m_buckets[idx(cpuId, (realm == Realm::I), sizeClass, b)];
// 
// 	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 924
SIGNATURE:
	void attachAsnEpochs(const AsnGenTable* table) noexcept

BODY (preview):
	void attachAsnEpochs(const AsnGenTable* table) noexcept {
		// For per-CPU manager, we already have our own m_asnEpochs[cpuId]
		// This method may not be needed if using per-CPU managers
		// 
		// However, for compatibility with GlobalPTESMP which uses a SHARED
		// epoch table across all CPUs, we'd need to update all buckets:

		for (size_t i = 0; i < m_buckets.size(); ++i) {
			m_buckets[i].attachAsnEpochs(table);
		}
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 946
SIGNATURE:
	bool invalidateMatching(const Tag& tag, ASNType asn) noexcept

BODY (preview):
	bool invalidateMatching(const Tag& tag, ASNType asn) noexcept {
		// Search across all shards
		for (int c = 0; c < m_cpuCount; ++c) {
			for (int r = 0; r < kRealmCount; ++r) {
				const int sCount = ShardBySize ? kSizeClassCount : 1;
				for (int s = 0; s < sCount; ++s) {
					// Get bucket for this tag
					const unsigned bucketIdx = bucketIndex(tag);
					auto& buck = bucket(c, static_cast<Realm>(r), s, bucketIdx);

					// Try to invalidate in this bucket
					if (buck.invalidateMatching(tag, asn)) {
						return true;  // Found and invalidated
					}
				}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 948
SIGNATURE:
 for(int c = 0; c < m_cpuCount; ++c) 

BODY (preview):
		for (int c = 0; c < m_cpuCount; ++c) {
			for (int r = 0; r < kRealmCount; ++r) {
				const int sCount = ShardBySize ? kSizeClassCount : 1;
				for (int s = 0; s < sCount; ++s) {
					// Get bucket for this tag
					const unsigned bucketIdx = bucketIndex(tag);
					auto& buck = bucket(c, static_cast<Realm>(r), s, bucketIdx);

					// Try to invalidate in this bucket
					if (buck.invalidateMatching(tag, asn)) {
						return true;  // Found and invalidated
					}
				}
			}
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 949
SIGNATURE:
	 for(int r = 0; r < kRealmCount; ++r) 

BODY (preview):
			for (int r = 0; r < kRealmCount; ++r) {
				const int sCount = ShardBySize ? kSizeClassCount : 1;
				for (int s = 0; s < sCount; ++s) {
					// Get bucket for this tag
					const unsigned bucketIdx = bucketIndex(tag);
					auto& buck = bucket(c, static_cast<Realm>(r), s, bucketIdx);

					// Try to invalidate in this bucket
					if (buck.invalidateMatching(tag, asn)) {
						return true;  // Found and invalidated
					}
				}
			}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 951
SIGNATURE:
		 for(int s = 0; s < sCount; ++s) 

BODY (preview):
				for (int s = 0; s < sCount; ++s) {
					// Get bucket for this tag
					const unsigned bucketIdx = bucketIndex(tag);
					auto& buck = bucket(c, static_cast<Realm>(r), s, bucketIdx);

					// Try to invalidate in this bucket
					if (buck.invalidateMatching(tag, asn)) {
						return true;  // Found and invalidated
					}
				}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 978
SIGNATURE:
	void sweepDeadForASN(ASNType asn, quint32 curGen) noexcept

BODY (preview):
	void sweepDeadForASN(ASNType asn, quint32 curGen) noexcept {
		// Sweep all buckets across all shards
		for (size_t i = 0; i < m_buckets.size(); ++i) {
			m_buckets[i].sweepDeadForASN(asn, curGen);
		}
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 993
SIGNATURE:
	void flushAll() noexcept

BODY (preview):
	void flushAll() noexcept {
		// Invalidate all buckets
		for (size_t i = 0; i < m_buckets.size(); ++i) {
			// Invalidate all ways in this bucket
			for (unsigned way = 0; way < AssocWays; ++way) {
				m_buckets[i].invalidate(way);
			}
		}
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 997
SIGNATURE:
	 for(unsigned way = 0; way < AssocWays; ++way) 

BODY (preview):
			for (unsigned way = 0; way < AssocWays; ++way) {
				m_buckets[i].invalidate(way);
			}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 1011
SIGNATURE:
	bool insert(const Entry& entry) noexcept

BODY (preview):
	bool insert(const Entry& entry) noexcept {
		// Extract routing information from entry
		const CPUIdType cpuId = 0;  // TODO: Get from entry or context
		const Realm realm = entry.tag.realm;
		const SC_Type sizeClass = entry.tag.sizeClass;
		const unsigned bucketIdx = bucketIndex(entry.tag);

		// Get appropriate bucket
		auto& buck = bucket(cpuId, realm, sizeClass, bucketIdx);

		// Insert entry
		return buck.insert(entry);
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 1034
SIGNATURE:
	Entry* find(const Tag& tag, ASNType asn) noexcept

BODY (preview):
	Entry* find(const Tag& tag, ASNType asn) noexcept {
		// Route to appropriate bucket
		const CPUIdType cpuId = 0;  // TODO: Get from context
		const Realm realm = tag.realm;
		const SC_Type sizeClass = tag.sizeClass;
		const unsigned bucketIdx = bucketIndex(tag);

		// Get bucket and search
		auto& buck = bucket(cpuId, realm, sizeClass, bucketIdx);
		return buck.find(tag, asn);
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 1064
SIGNATURE:
	quint32 incrementASNGeneration(ASNType asn) noexcept

BODY (preview):
	quint32 incrementASNGeneration(ASNType asn) noexcept {
		// For per-CPU manager, increment CPU 0's epoch
		// (or parameterize cpuId if needed)
		return m_asnEpochs[0].gen[asn].fetchAndAddRelaxed(1) + 1;
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 1086
SIGNATURE:
	 for(int cpu = 0; cpu < cpuCount; ++cpu) 

BODY (preview):
	  for (int cpu = 0; cpu < cpuCount; ++cpu) {
		  m_managers[cpu]->attachAsnEpochs(&sharedAsnTable);
	  }

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 1104
SIGNATURE:
	void incrementASNGenerationAllCPUs(ASNType asn) noexcept

BODY (preview):
	void incrementASNGenerationAllCPUs(ASNType asn) noexcept {
		// Increment generation on ALL CPUs' epoch tables
		for (int cpu = 0; cpu < m_cpuCount; ++cpu) {
			m_asnEpochs[cpu].gen[asn].fetchAndAddRelaxed(1);
		}
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 1106
SIGNATURE:
 for(int cpu = 0; cpu < m_cpuCount; ++cpu) 

BODY (preview):
		for (int cpu = 0; cpu < m_cpuCount; ++cpu) {
			m_asnEpochs[cpu].gen[asn].fetchAndAddRelaxed(1);
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 1119
SIGNATURE:
	void incrementAllASNGenerations() noexcept

BODY (preview):
	void incrementAllASNGenerations() noexcept {
		// Increment ALL ASN generations on ALL CPUs
		for (int cpu = 0; cpu < m_cpuCount; ++cpu) {
			for (int asn = 0; asn < 256; ++asn) {
				m_asnEpochs[cpu].gen[asn].fetchAndAddRelaxed(1);
			}
		}
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 1121
SIGNATURE:
 for(int cpu = 0; cpu < m_cpuCount; ++cpu) 

BODY (preview):
		for (int cpu = 0; cpu < m_cpuCount; ++cpu) {
			for (int asn = 0; asn < 256; ++asn) {
				m_asnEpochs[cpu].gen[asn].fetchAndAddRelaxed(1);
			}
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\alpha_spam_manager.h
LINE: 1122
SIGNATURE:
	 for(int asn = 0; asn < 256; ++asn) 

BODY (preview):
			for (int asn = 0; asn < 256; ++asn) {
				m_asnEpochs[cpu].gen[asn].fetchAndAddRelaxed(1);
			}

================================================================================
FILE: z:\EmulatRApp\pteLib\Alpha_spam_types.h
LINE: 15
SIGNATURE:
		static constexpr quint64 computeVPN(VAType va, PageSizeCode sc) noexcept

BODY (preview):
		static constexpr quint64 computeVPN(VAType va, PageSizeCode sc) noexcept {
			return va >> PageSizeHelpers::pageShift(sc);
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\Alpha_spam_types.h
LINE: 44
SIGNATURE:
*	inline void setAsn(ASNType asn_) noexcept

BODY (preview):
	/*	inline void setAsn(ASNType asn_) noexcept { m_asn = asn_; }*/
/*		inline void setPfn(PFNType pfn_) noexcept { pfn = pfn_; }*/

================================================================================
FILE: z:\EmulatRApp\pteLib\Alpha_spam_types.h
LINE: 45
SIGNATURE:
*		inline void setPfn(PFNType pfn_) noexcept

BODY (preview):
/*		inline void setPfn(PFNType pfn_) noexcept { pfn = pfn_; }*/
	/*	constexpr PFNType Pfn() const noexcept { return pfn; }*/

================================================================================
FILE: z:\EmulatRApp\pteLib\Alpha_spam_types.h
LINE: 48
SIGNATURE:
		constexpr void markLocked() noexcept

BODY (preview):
		constexpr void markLocked()   noexcept { flags.locked = true; }
		constexpr void unlock()       noexcept { flags.locked = false; }

================================================================================
FILE: z:\EmulatRApp\pteLib\Alpha_spam_types.h
LINE: 49
SIGNATURE:
		constexpr void unlock() noexcept

BODY (preview):
		constexpr void unlock()       noexcept { flags.locked = false; }
	};


================================================================================
FILE: z:\EmulatRApp\pteLib\Ev6PTETraits.h
LINE: 57
SIGNATURE:
	static inline PFNType pfn(const AlphaPTE& pte) noexcept

BODY (preview):
	static inline PFNType pfn(const AlphaPTE& pte) noexcept {
		return pte.pfn();
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\Ev6PTETraits.h
LINE: 62
SIGNATURE:
	static inline AlphaN_S::PermMask permMask(const AlphaPTE& pte) noexcept

BODY (preview):
	static inline AlphaN_S::PermMask permMask(const AlphaPTE& pte) noexcept {
		// Build compact permission mask from PTE
		AlphaN_S::PermMask mask = 0;
		bool kre, ere, sre, ure;
		bool kwe, ewe, swe, uwe;

		pte.getReadPermissions(kre, ere, sre, ure);
		pte.getWritePermissions(kwe, ewe, swe, uwe);

		// Pack into mask (customize to your layout)
		if (ure) mask |= (1 << 0);
		if (uwe) mask |= (1 << 1);
		if (kre) mask |= (1 << 2);
		if (kwe) mask |= (1 << 3);


================================================================================
FILE: z:\EmulatRApp\pteLib\Ev6SiliconTLB.h
LINE: 19
SIGNATURE:
	Ev6SPAMShardManager& spam() noexcept

BODY (preview):
	Ev6SPAMShardManager& spam() noexcept { return m_spam; }
	const Ev6SPAMShardManager& spam() const noexcept { return m_spam; }

================================================================================
FILE: z:\EmulatRApp\pteLib\Ev6SiliconTLB_Singleton.h
LINE: 50
SIGNATURE:
*inline PTECache& globalPTECache() noexcept

BODY (preview):
/*inline PTECache& globalPTECache() noexcept {
	static PTECache cache;
	return cache;
} */

================================================================================
FILE: z:\EmulatRApp\pteLib\EV6TLBTag.h
LINE: 69
SIGNATURE:
 	inline void clear() 

BODY (preview):
// 	inline void clear() { vpn = 0; realm = 0; sizeClass = 0; }
// };

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 68
SIGNATURE:
    static GlobalPTESMP& instance() noexcept

BODY (preview):
    static GlobalPTESMP& instance() noexcept {
        static GlobalPTESMP inst;
        return inst;
    }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 78
SIGNATURE:
       for(int i = 0; i < MAX_CPUS; ++i) 

BODY (preview):
        for (int i = 0; i < MAX_CPUS; ++i) {
            m_spam[i] = nullptr;
        }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 88
SIGNATURE:
    static void initialize(int cpuCount) noexcept

BODY (preview):
    static void initialize(int cpuCount) noexcept {
        auto& inst = instance();
        inst.m_cpuCount = cpuCount;

        // Allocate per-CPU SPAM managers
        for (int i = 0; i < cpuCount; ++i) {
            inst.m_spam[i] = new Ev6SPAMShardManager();
            inst.m_spam[i]->attachAsnEpochs(&inst.m_asnEpochs);
        }
    }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 93
SIGNATURE:
       for(int i = 0; i < cpuCount; ++i) 

BODY (preview):
        for (int i = 0; i < cpuCount; ++i) {
            inst.m_spam[i] = new Ev6SPAMShardManager();
            inst.m_spam[i]->attachAsnEpochs(&inst.m_asnEpochs);
        }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 99
SIGNATURE:
    static void shutdown() noexcept

BODY (preview):
    static void shutdown() noexcept {
        auto& inst = instance();
        for (int i = 0; i < inst.m_cpuCount; ++i) {
            delete inst.m_spam[i];
            inst.m_spam[i] = nullptr;
        }
    }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 101
SIGNATURE:
       for(int i = 0; i < inst.m_cpuCount; ++i) 

BODY (preview):
        for (int i = 0; i < inst.m_cpuCount; ++i) {
            delete inst.m_spam[i];
            inst.m_spam[i] = nullptr;
        }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 120
SIGNATURE:
    static Ev6SPAMShardManager& getSPAM(CPUIdType cpuId) noexcept

BODY (preview):
    static Ev6SPAMShardManager& getSPAM(CPUIdType cpuId) noexcept {
        auto& inst = instance();
        Q_ASSERT(cpuId < inst.m_cpuCount);
        Q_ASSERT(inst.m_spam[cpuId] != nullptr);
        return *inst.m_spam[cpuId];
    }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 137
SIGNATURE:
    static quint32 getASNGeneration(ASNType asn) noexcept

BODY (preview):
    static quint32 getASNGeneration(ASNType asn) noexcept {
        return instance().m_asnEpochs.gen[asn].loadRelaxed();
    }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 150
SIGNATURE:
    static quint32 incrementASNGeneration(ASNType asn) noexcept

BODY (preview):
    static quint32 incrementASNGeneration(ASNType asn) noexcept {
        return instance().m_asnEpochs.gen[asn].fetchAndAddRelaxed(1) + 1;
    }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 159
SIGNATURE:
    static const AsnGenTable* getASNEpochTable() noexcept

BODY (preview):
    static const AsnGenTable* getASNEpochTable() noexcept {
        return &instance().m_asnEpochs;
    }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 185
SIGNATURE:
    static quint32 lazyInvalidateASN(ASNType asn) noexcept

BODY (preview):
    static quint32 lazyInvalidateASN(ASNType asn) noexcept {
        // Just increment generation - all CPUs will see stale entries
        return incrementASNGeneration(asn);
    }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 200
SIGNATURE:
    static void lazyInvalidateAll() noexcept

BODY (preview):
    static void lazyInvalidateAll() noexcept {
        // Increment all ASN generations
        for (int asn = 0; asn < 256; ++asn) {
            incrementASNGeneration(asn);
        }
    }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 202
SIGNATURE:
       for(int asn = 0; asn < 256; ++asn) 

BODY (preview):
        for (int asn = 0; asn < 256; ++asn) {
            incrementASNGeneration(asn);
        }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 220
SIGNATURE:
    static void sweepDeadEntries(CPUIdType cpuId, ASNType asn) noexcept

BODY (preview):
    static void sweepDeadEntries(CPUIdType cpuId, ASNType asn) noexcept {
        auto& inst = instance();
        if (cpuId < inst.m_cpuCount && inst.m_spam[cpuId]) {
            const quint32 curGen = getASNGeneration(asn);
            inst.m_spam[cpuId]->sweepDeadForASN(asn, curGen);
        }
    }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 222
SIGNATURE:
       if(cpuId < inst.m_cpuCount && inst.m_spam[cpuId]) 

BODY (preview):
        if (cpuId < inst.m_cpuCount && inst.m_spam[cpuId]) {
            const quint32 curGen = getASNGeneration(asn);
            inst.m_spam[cpuId]->sweepDeadForASN(asn, curGen);
        }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 317
SIGNATURE:
    static void flushCPU(CPUIdType cpuId) noexcept

BODY (preview):
    static void flushCPU(CPUIdType cpuId) noexcept {
        auto& spam = getSPAM(cpuId);
        spam.flushAll();
    }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 337
SIGNATURE:
inline Ev6SPAMShardManager& globalSPAM(CPUIdType cpuId) noexcept

BODY (preview):
inline Ev6SPAMShardManager& globalSPAM(CPUIdType cpuId) noexcept {
    return GlobalPTESMP::getSPAM(cpuId);
}

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 346
SIGNATURE:
inline const AsnGenTable* globalASNEpochs() noexcept

BODY (preview):
inline const AsnGenTable* globalASNEpochs() noexcept {
    return GlobalPTESMP::getASNEpochTable();
}

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 398
SIGNATURE:
inline quint32 invalidateASN(ASNType asn) noexcept

BODY (preview):
inline quint32 invalidateASN(ASNType asn) noexcept {
    return GlobalPTESMP::lazyInvalidateASN(asn);
}

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 422
SIGNATURE:
inline void initializeGlobalPTE(int cpuCount) noexcept

BODY (preview):
inline void initializeGlobalPTE(int cpuCount) noexcept {
    GlobalPTESMP::initialize(cpuCount);
}

================================================================================
FILE: z:\EmulatRApp\pteLib\global_Ev6TLB_Singleton.h
LINE: 426
SIGNATURE:
inline void shutdownGlobalPTE() noexcept

BODY (preview):
inline void shutdownGlobalPTE() noexcept {
    GlobalPTESMP::shutdown();
}

================================================================================
FILE: z:\EmulatRApp\pteLib\global_pte_smp_interface.h
LINE: 49
SIGNATURE:
    static GlobalPTESMP& instance() noexcept

BODY (preview):
    static GlobalPTESMP& instance() noexcept {
        static GlobalPTESMP inst;
        return inst;
    }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_pte_smp_interface.h
LINE: 65
SIGNATURE:
    static void initialize(int cpuCount) noexcept

BODY (preview):
    static void initialize(int cpuCount) noexcept {
        auto& inst = instance();
        inst.m_cpuCount = cpuCount;

        // Create SPAM manager (handles all CPUs)
        inst.m_spamManager = new Ev6SPAMShardManager(cpuCount);

        // NOTE: Your SPAMShardManager already has per-CPU ASN epochs in m_asnEpochs[cpuId]
        // For true SMP coherence, we'd need to modify it to use a SHARED epoch table
        // instead of per-CPU tables. See notes below.
    }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_pte_smp_interface.h
LINE: 77
SIGNATURE:
    static void shutdown() noexcept

BODY (preview):
    static void shutdown() noexcept {
        auto& inst = instance();
        delete inst.m_spamManager;
        inst.m_spamManager = nullptr;
    }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_pte_smp_interface.h
LINE: 95
SIGNATURE:
    static Ev6SPAMShardManager& getSPAM() noexcept

BODY (preview):
    static Ev6SPAMShardManager& getSPAM() noexcept {
        auto& inst = instance();
        Q_ASSERT(inst.m_spamManager != nullptr);
        return *inst.m_spamManager;
    }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_pte_smp_interface.h
LINE: 115
SIGNATURE:
	static quint32 getASNGeneration(CPUIdType cpuId, ASNType asn) noexcept

BODY (preview):
	static quint32 getASNGeneration(CPUIdType cpuId, ASNType asn) noexcept {
		return getSPAM().getASNGeneration(cpuId, asn);  
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\global_pte_smp_interface.h
LINE: 130
SIGNATURE:
	static void lazyInvalidateASN(ASNType asn) noexcept

BODY (preview):
	static void lazyInvalidateASN(ASNType asn) noexcept {
		getSPAM().incrementASNGenerationAllCPUs(asn);  
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\global_pte_smp_interface.h
LINE: 137
SIGNATURE:
	static void lazyInvalidateAll() noexcept

BODY (preview):
	static void lazyInvalidateAll() noexcept {
		getSPAM().incrementAllASNGenerations(); 
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\global_pte_smp_interface.h
LINE: 219
SIGNATURE:
    static void sweepDeadEntries(CPUIdType cpuId, ASNType asn) noexcept

BODY (preview):
    static void sweepDeadEntries(CPUIdType cpuId, ASNType asn) noexcept {
        auto& spam = getSPAM();
        const quint32 curGen = getASNGeneration(cpuId, asn);

        // Sweep this CPU's buckets (background cleanup)
        spam.sweepDeadForASN(asn, curGen);
    }

================================================================================
FILE: z:\EmulatRApp\pteLib\global_pte_smp_interface.h
LINE: 237
SIGNATURE:
inline Ev6SPAMShardManager& globalSPAM() noexcept

BODY (preview):
inline Ev6SPAMShardManager& globalSPAM() noexcept {
    return GlobalPTESMP::getSPAM();
}

================================================================================
FILE: z:\EmulatRApp\pteLib\global_pte_smp_interface.h
LINE: 284
SIGNATURE:
inline void invalidateASN(ASNType asn) noexcept

BODY (preview):
inline void invalidateASN(ASNType asn) noexcept {
    GlobalPTESMP::lazyInvalidateASN(asn);
}

================================================================================
FILE: z:\EmulatRApp\pteLib\global_pte_smp_interface.h
LINE: 304
SIGNATURE:
inline void initializeGlobalPTE(int cpuCount) noexcept

BODY (preview):
inline void initializeGlobalPTE(int cpuCount) noexcept {
    GlobalPTESMP::initialize(cpuCount);
}

================================================================================
FILE: z:\EmulatRApp\pteLib\global_pte_smp_interface.h
LINE: 308
SIGNATURE:
inline void shutdownGlobalPTE() noexcept

BODY (preview):
inline void shutdownGlobalPTE() noexcept {
    GlobalPTESMP::shutdown();
}

================================================================================
FILE: z:\EmulatRApp\pteLib\pte_dual_core.h
LINE: 42
SIGNATURE:
inline constexpr quint8 dtbBankForVA(quint64 va) noexcept

BODY (preview):
inline constexpr quint8 dtbBankForVA(quint64 va) noexcept {
    return (va >> 12) & 0x1;
}

================================================================================
FILE: z:\EmulatRApp\pteLib\pte_dual_core.h
LINE: 49
SIGNATURE:
inline constexpr bool isBank0VA(quint64 va) noexcept

BODY (preview):
inline constexpr bool isBank0VA(quint64 va) noexcept {
    return ((va >> 12) & 0x1) == 0;
}

================================================================================
FILE: z:\EmulatRApp\pteLib\pte_dual_core.h
LINE: 56
SIGNATURE:
inline constexpr bool isBank1VA(quint64 va) noexcept

BODY (preview):
inline constexpr bool isBank1VA(quint64 va) noexcept {
    return ((va >> 12) & 0x1) == 1;
}

================================================================================
FILE: z:\EmulatRApp\pteLib\pte_dual_core.h
LINE: 77
SIGNATURE:
inline constexpr Realm toSPAMRealm(TLBRealm realm) noexcept

BODY (preview):
inline constexpr Realm toSPAMRealm(TLBRealm realm) noexcept {
    return (realm == TLBRealm::ITB) ? Realm::I : Realm::D;
}

================================================================================
FILE: z:\EmulatRApp\pteLib\pte_l2_helpers.h
LINE: 24
SIGNATURE:
 inline void prewarmTLB(quint16 cpuId, Realm realm, quint8 sizeClass, quint64 va) noexcept

BODY (preview):
// inline void prewarmTLB(quint16 cpuId, Realm realm, quint8 sizeClass, quint64 va) noexcept {
// 	quint32 pfn;
// 	PermMask perm;
// 
// 
// 	auto& silicon = Ev6SiliconTLB_Singleton().instance();
// 
// 	// Get reference to SPAMShardManager (TLB hardware implementation)
// 	auto& mgr = silicon.spam();
// 
// 	const quint8 asn = getASN_Active(cpuId);
// 	bool hit = mgr.tlbLookup(cpuId, realm, sizeClass, va, asn, pfn, perm);
// 
// 	if (!hit) {
// 		DEBUG_LOG("TLB_PREFETCH_MISS", "VA: 0x" << std::hex << va);

================================================================================
FILE: z:\EmulatRApp\pteLib\pte_l2_helpers.h
LINE: 37
SIGNATURE:
 if(!hit) 

BODY (preview):
// 	if (!hit) {
// 		DEBUG_LOG("TLB_PREFETCH_MISS", "VA: 0x" << std::hex << va);
// 
// 		// 2) Optional: perform a page-table walk and insert the entry now.
// 		//    This is the part where you "influence prefetch behavior".
// 		//
// 		//    ASA ref: Alpha AXP System Reference Manual,
// 		//    Section 3.7 / 3.8 (Translation Buffer and TBMISS handling).
// 		//
// 		AlphaPTE pte = walkPageTable_EV6(cpuId, va, asn);
// 		mgr.tlbInsert(cpuId, realm, sizeClass, va, asn, /*global=*/false, pte);
// 	}

================================================================================
FILE: z:\EmulatRApp\pteLib\pte_l2_helpers.h
LINE: 54
SIGNATURE:
inline quint64 tagToVA(const Ev6TLBTag& tag) noexcept

BODY (preview):
inline quint64 tagToVA(const Ev6TLBTag& tag) noexcept {
	const quint64 shift = Ev6PTETraits::pageShiftForClass(tag.sizeClass);
	return tag.vpn << shift;
}

================================================================================
FILE: z:\EmulatRApp\pteLib\TemplatePolicyBase.h
LINE: 13
SIGNATURE:
	void invalidate(Entry& entry) 

BODY (preview):
	void invalidate(Entry& entry) {
		entry.flags.valid = false;
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\TemplatePolicyBase.h
LINE: 45
SIGNATURE:
	void set(unsigned way, unsigned v) noexcept

BODY (preview):
	void set(unsigned way, unsigned v) noexcept {
		const unsigned byte = (way * RRPV_BITS) / 8, off = (way * RRPV_BITS) % 8;
		m_rrpv[byte] &= ~(((1u << RRPV_BITS) - 1u) << off);
		m_rrpv[byte] |= (v << off);
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\TemplatePolicyBase.h
LINE: 55
SIGNATURE:
 for(unsigned i = 1; i < AssocWays; ++i) 

BODY (preview):
		for (unsigned i = 1; i < AssocWays; ++i) {
			const unsigned r = get(i);
			if (r > best) { best = r; victim = i; }
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\TemplatePolicyBase.h
LINE: 57
SIGNATURE:
	 if(r > best) 

BODY (preview):
			if (r > best) { best = r; victim = i; }
		}
		return victim;
	}
	void recordAccess(const Entry&, unsigned way) noexcept override { set(way, 0); }
};

// CLOCK
template<typename Entry, unsigned AssocWays>
class ClockPolicy : public ReplacementPolicyBase<Entry, AssocWays> {
	std::bitset<AssocWays> m_ref{};
	unsigned m_hand = 0;
public:
	unsigned selectVictim(const Entry* entries) noexcept override {
		for (unsigned i = 0; i < AssocWays; ++i) if (!entries[i].isValid()) return i;

================================================================================
FILE: z:\EmulatRApp\pteLib\TemplatePolicyBase.h
LINE: 72
SIGNATURE:
 for(;;) 

BODY (preview):
		for (;;) {
			if (!m_ref[m_hand]) { const unsigned v = m_hand; m_hand = (m_hand + 1) % AssocWays; return v; }
			m_ref[m_hand] = false; m_hand = (m_hand + 1) % AssocWays;
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\TemplatePolicyBase.h
LINE: 73
SIGNATURE:
	 if(!m_ref[m_hand]) 

BODY (preview):
			if (!m_ref[m_hand]) { const unsigned v = m_hand; m_hand = (m_hand + 1) % AssocWays; return v; }
			m_ref[m_hand] = false; m_hand = (m_hand + 1) % AssocWays;

================================================================================
FILE: z:\EmulatRApp\pteLib\TemplatePolicyBase.h
LINE: 97
SIGNATURE:
	explicit PolicySelector(ReplacementPolicyType t) 

BODY (preview):
	explicit PolicySelector(ReplacementPolicyType t) {
		switch (t) {
		case ReplacementPolicyType::SRRIP: m_impl = std::make_unique< SRRIPPolicy<Entry, AssocWays> >(); break;
		case ReplacementPolicyType::CLOCK: m_impl = std::make_unique< ClockPolicy<Entry, AssocWays> >(); break;
		default:                           m_impl = std::make_unique< RandomPolicy<Entry, AssocWays> >(); break;
		}
	}

================================================================================
FILE: z:\EmulatRApp\pteLib\TemplatePolicyBase.h
LINE: 98
SIGNATURE:
 switch(t) 

BODY (preview):
		switch (t) {
		case ReplacementPolicyType::SRRIP: m_impl = std::make_unique< SRRIPPolicy<Entry, AssocWays> >(); break;
		case ReplacementPolicyType::CLOCK: m_impl = std::make_unique< ClockPolicy<Entry, AssocWays> >(); break;
		default:                           m_impl = std::make_unique< RandomPolicy<Entry, AssocWays> >(); break;
		}

================================================================================
FILE: z:\EmulatRApp\pteLib\TemplatePolicyBase.h
LINE: 104
SIGNATURE:
	unsigned selectVictim(const Entry* entries) noexcept

BODY (preview):
	unsigned selectVictim(const Entry* entries) noexcept { return m_impl->selectVictim(entries); }
	void recordAccess(const Entry& e, unsigned way) noexcept { m_impl->recordAccess(e, way); }

================================================================================
FILE: z:\EmulatRApp\pteLib\TemplatePolicyBase.h
LINE: 105
SIGNATURE:
	void recordAccess(const Entry& e, unsigned way) noexcept

BODY (preview):
	void recordAccess(const Entry& e, unsigned way) noexcept { m_impl->recordAccess(e, way); }
};



================================================================================
FILE: z:\EmulatRApp\scsiCoreLib\ScsiSenseData.h
LINE: 87
SIGNATURE:
	quint8* bytes() noexcept

BODY (preview):
	quint8* bytes() noexcept { return data; }


================================================================================
FILE: z:\EmulatRApp\scsiCoreLib\ScsiSenseData.h
LINE: 89
SIGNATURE:
	static constexpr int size() noexcept

BODY (preview):
	static constexpr int size() noexcept { return 18; }
};

// ============================================================================
// Simple Sense Builders
// ============================================================================
//
// These inline helpers allow a virtual SCSI device to quickly create correct
// sense data for common error conditions.
//
// Note: ASC/ASCQ codes below use common SBC-3 values. They can be customized
//       later if you implement full ASC/ASCQ tables.
// ============================================================================

// "NO SENSE" (0x00/0x00)

================================================================================
FILE: z:\EmulatRApp\scsiCoreLib\VirtualScsiDevice.h
LINE: 132
SIGNATURE:
	virtual bool flushCache() noexcept

BODY (preview):
	virtual bool flushCache() noexcept { return true; }


================================================================================
FILE: z:\EmulatRApp\scsiCoreLib\VirtualScsiDevice.h
LINE: 141
SIGNATURE:
	virtual void reset() noexcept

BODY (preview):
	virtual void reset() noexcept { /* default: do nothing */ }
};

#endif // VIRTUAL_SCSI_DEVICE_H

================================================================================
FILE: z:\EmulatRApp\palLib_EV6\grains\Pal_HW_MFPR_InstructionGrain.h
LINE: 67
SIGNATURE:
    inline ExecutionBox ExecutionBox_Grain() 

BODY (preview):
    inline ExecutionBox	ExecutionBox_Grain() { box = ExecutionBox::HWBox; }


================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\grains\opr_PERR_InstructionGrain.h
LINE: 60
SIGNATURE:
       while(x) 

BODY (preview):
        while (x) {
            x &= (x - 1);
            ++cnt;
        }

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\grains\Claude\fpOperate_InstructionGrain.h
LINE: 91
SIGNATURE:
		if constexpr(OpCount == OperandCount::Binary) 

BODY (preview):
		if constexpr (OpCount == OperandCount::Binary) {
			result = executeBinaryOp(di, cpuState, fpcrLocal, variant);
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\grains\Claude\fpOperate_InstructionGrain.h
LINE: 94
SIGNATURE:
		else if constexpr(OpCount == OperandCount::Unary) 

BODY (preview):
		else if constexpr (OpCount == OperandCount::Unary) {
			result = executeUnaryOp(di, cpuState, fpcrLocal, variant);
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\grains\Claude\fpOperate_InstructionGrain.h
LINE: 97
SIGNATURE:
		else if constexpr(OpCount == OperandCount::Special) 

BODY (preview):
		else if constexpr (OpCount == OperandCount::Special) {
			executeSpecialOp(di, cpuState, fpcrLocal, variant);
			return;  // Special ops handle their own result storage
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\grains\Claude\fpOperate_InstructionGrain.h
LINE: 110
SIGNATURE:
 if(variant.maskExceptions) 

BODY (preview):
		if (variant.maskExceptions) {
			return;
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\grains\Claude\fpOperate_InstructionGrain.h
LINE: 122
SIGNATURE:
 if(fpcrLocal & AlphaFPCR::EXC_MASK) 

BODY (preview):
		if (fpcrLocal & AlphaFPCR::EXC_MASK) {
			scheduleArithmeticTrap_fp(cpuState, fpcrLocal);
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\grains\Claude\fpOperate_InstructionGrain.h
LINE: 140
SIGNATURE:
 switch(OpKind) 

BODY (preview):
		switch (OpKind) {
		case FPOperationKind::Add:
			return Alpha_FP::addF64_variant(srcA, srcB, fpcrLocal, variant);

		case FPOperationKind::Sub:
			return Alpha_FP::subF64_variant(srcA, srcB, fpcrLocal, variant);

		case FPOperationKind::Mul:
			return Alpha_FP::mulF64_variant(srcA, srcB, fpcrLocal, variant);

		case FPOperationKind::Div:
			return Alpha_FP::divF64_variant(srcA, srcB, fpcrLocal, variant);

		default:
			return 0.0;

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\grains\Claude\fpOperate_InstructionGrain.h
LINE: 169
SIGNATURE:
 switch(OpKind) 

BODY (preview):
		switch (OpKind) {
		case FPOperationKind::Sqrt:
			return Alpha_FP::sqrtF64_variant(srcB, fpcrLocal, variant);

		case FPOperationKind::Abs:
			return std::fabs(srcB);  // No exceptions for ABS

		case FPOperationKind::Neg:
			return -srcB;  // No exceptions for NEG

		case FPOperationKind::CopySign:
			// CPYS: copy sign from Ra to magnitude of Rb
		{
			const double srcA = cpuState.readFpReg(di.ra);
			return std::copysign(srcB, srcA);

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\grains\Claude\fpOperate_InstructionGrain.h
LINE: 205
SIGNATURE:
 switch(OpKind) 

BODY (preview):
		switch (OpKind) {
		case FPOperationKind::Cmp:
			executeCompare(di, cpuState, fpcrLocal);
			break;

		case FPOperationKind::CMove:
			executeConditionalMove(di, cpuState);
			break;

		default:
			break;
		}

================================================================================
FILE: z:\EmulatRApp\grainFactoryLib\grains\Claude\fpOperate_InstructionGrain.h
LINE: 288
SIGNATURE:
 if(condition) 

BODY (preview):
		if (condition) {
			cpuState.writeFpReg(di.rc, srcB);
		}

